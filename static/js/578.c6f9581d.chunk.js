"use strict";(self.webpackChunkmrgrd56_github_io=self.webpackChunkmrgrd56_github_io||[]).push([[578],{16578:function(e,t,n){n.r(t),t.default='import _ = require("../index");\n// tslint:disable-next-line:strict-export-declare-modifiers\ntype GlobalPartial<T> = Partial<T>;\ndeclare module "../index" {\n    type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;\n    type PartialObject<T> = GlobalPartial<T>;\n    type Many<T> = T | ReadonlyArray<T>;\n    type ImpChain<T> =\n        T extends { __trapAny: any } ? Collection<any> & Function<any> & Object<any> & Primitive<any> & String :\n        T extends null | undefined ? never :\n        T extends string | null | undefined ? String :\n        T extends (...args: any) => any ? Function<T> :\n        T extends List<infer U> | null | undefined ? Collection<U> :\n        T extends object | null | undefined ? Object<T> :\n        Primitive<T>;\n    type ExpChain<T> =\n        T extends { __trapAny: any } ? CollectionChain<any> & FunctionChain<any> & ObjectChain<any> & PrimitiveChain<any> & StringChain :\n        T extends null | undefined ? never :\n        T extends string ? StringChain :\n        T extends string | null | undefined ? StringNullableChain :\n        T extends (...args: any) => any ? FunctionChain<T> :\n        T extends List<infer U> | null | undefined ? CollectionChain<U> :\n        T extends object | null | undefined ? ObjectChain<T> :\n        PrimitiveChain<T>;\n    interface LoDashStatic {\n        /**\n        * Creates a lodash object which wraps value to enable implicit method chain sequences.\n        * Methods that operate on and return arrays, collections, and functions can be chained together.\n        * Methods that retrieve a single value or may return a primitive value will automatically end the\n        * chain sequence and return the unwrapped value. Otherwise, the value must be unwrapped with value().\n        *\n        * Explicit chain sequences, which must be unwrapped with value(), may be enabled using _.chain.\n        *\n        * The execution of chained methods is lazy, that is, it\'s deferred until value() is\n        * implicitly or explicitly called.\n        *\n        * Lazy evaluation allows several methods to support shortcut fusion. Shortcut fusion\n        * is an optimization to merge iteratee calls; this avoids the creation of intermediate\n        * arrays and can greatly reduce the number of iteratee executions. Sections of a chain\n        * sequence qualify for shortcut fusion if the section is applied to an array and iteratees\n        * accept only one argument. The heuristic for whether a section qualifies for shortcut\n        * fusion is subject to change.\n        *\n        * Chaining is supported in custom builds as long as the value() method is directly or\n        * indirectly included in the build.\n        *\n        * In addition to lodash methods, wrappers have Array and String methods.\n        * The wrapper Array methods are:\n        * concat, join, pop, push, shift, sort, splice, and unshift.\n        * The wrapper String methods are:\n        * replace and split.\n        *\n        * The wrapper methods that support shortcut fusion are:\n        * at, compact, drop, dropRight, dropWhile, filter, find, findLast, head, initial, last,\n        * map, reject, reverse, slice, tail, take, takeRight, takeRightWhile, takeWhile, and toArray\n        *\n        * The chainable wrapper methods are:\n        * after, ary, assign, assignIn, assignInWith, assignWith, at, before, bind, bindAll, bindKey,\n        * castArray, chain, chunk, commit, compact, concat, conforms, constant, countBy, create,\n        * curry, debounce, defaults, defaultsDeep, defer, delay, difference, differenceBy, differenceWith,\n        * drop, dropRight, dropRightWhile, dropWhile, extend, extendWith, fill, filter, flatMap,\n        * flatMapDeep, flatMapDepth, flatten, flattenDeep, flattenDepth, flip, flow, flowRight,\n        * fromPairs, functions, functionsIn, groupBy, initial, intersection, intersectionBy, intersectionWith,\n        * invert, invertBy, invokeMap, iteratee, keyBy, keys, keysIn, map, mapKeys, mapValues,\n        * matches, matchesProperty, memoize, merge, mergeWith, method, methodOf, mixin, negate,\n        * nthArg, omit, omitBy, once, orderBy, over, overArgs, overEvery, overSome, partial, partialRight,\n        * partition, pick, pickBy, plant, property, propertyOf, pull, pullAll, pullAllBy, pullAllWith, pullAt,\n        * push, range, rangeRight, rearg, reject, remove, rest, reverse, sampleSize, set, setWith,\n        * shuffle, slice, sort, sortBy, sortedUniq, sortedUniqBy, splice, spread, tail, take,\n        * takeRight, takeRightWhile, takeWhile, tap, throttle, thru, toArray, toPairs, toPairsIn,\n        * toPath, toPlainObject, transform, unary, union, unionBy, unionWith, uniq, uniqBy, uniqWith,\n        * unset, unshift, unzip, unzipWith, update, updateWith, values, valuesIn, without, wrap,\n        * xor, xorBy, xorWith, zip, zipObject, zipObjectDeep, and zipWith.\n        *\n        * The wrapper methods that are not chainable by default are:\n        * add, attempt, camelCase, capitalize, ceil, clamp, clone, cloneDeep, cloneDeepWith, cloneWith,\n        * conformsTo, deburr, defaultTo, divide, each, eachRight, endsWith, eq, escape, escapeRegExp,\n        * every, find, findIndex, findKey, findLast, findLastIndex, findLastKey, first, floor, forEach,\n        * forEachRight, forIn, forInRight, forOwn, forOwnRight, get, gt, gte, has, hasIn, head,\n        * identity, includes, indexOf, inRange, invoke, isArguments, isArray, isArrayBuffer,\n        * isArrayLike, isArrayLikeObject, isBoolean, isBuffer, isDate, isElement, isEmpty, isEqual, isEqualWith,\n        * isError, isFinite, isFunction, isInteger, isLength, isMap, isMatch, isMatchWith, isNaN,\n        * isNative, isNil, isNull, isNumber, isObject, isObjectLike, isPlainObject, isRegExp,\n        * isSafeInteger, isSet, isString, isUndefined, isTypedArray, isWeakMap, isWeakSet, join,\n        * kebabCase, last, lastIndexOf, lowerCase, lowerFirst, lt, lte, max, maxBy, mean, meanBy,\n        * min, minBy, multiply, noConflict, noop, now, nth, pad, padEnd, padStart, parseInt, pop,\n        * random, reduce, reduceRight, repeat, result, round, runInContext, sample, shift, size,\n        * snakeCase, some, sortedIndex, sortedIndexBy, sortedLastIndex, sortedLastIndexBy, startCase,\n        * startsWith, stubArray, stubFalse, stubObject, stubString, stubTrue, subtract, sum, sumBy,\n        * template, times, toFinite, toInteger, toJSON, toLength, toLower, toNumber, toSafeInteger,\n        * toString, toUpper, trim, trimEnd, trimStart, truncate, unescape, uniqueId, upperCase,\n        * upperFirst, value, and words.\n        **/\n        <TrapAny extends { __trapAny: any }>(value: TrapAny): Collection<any> & Function<any> & Object<any> & Primitive<any> & String;\n        <T extends null | undefined>(value: T): Primitive<T>;\n        (value: string | null | undefined): String;\n        <T extends (...args: any) => any>(value: T): Function<T>;\n        <T = any>(value: List<T> | null | undefined): Collection<T>;\n        <T extends object>(value: T | null | undefined): Object<T>;\n        <T>(value: T): Primitive<T>;\n        /**\n        * The semantic version number.\n        **/\n        VERSION: string;\n        /**\n        * By default, the template delimiters used by Lo-Dash are similar to those in embedded Ruby\n        * (ERB). Change the following template settings to use alternative delimiters.\n        **/\n        templateSettings: TemplateSettings;\n    }\n    /**\n    * By default, the template delimiters used by Lo-Dash are similar to those in embedded Ruby\n    * (ERB). Change the following template settings to use alternative delimiters.\n    **/\n    interface TemplateSettings {\n        /**\n        * The "escape" delimiter.\n        **/\n        escape?: RegExp | undefined;\n        /**\n        * The "evaluate" delimiter.\n        **/\n        evaluate?: RegExp | undefined;\n        /**\n        * An object to import into the template as local variables.\n        */\n        imports?: Dictionary<any> | undefined;\n        /**\n        * The "interpolate" delimiter.\n        */\n        interpolate?: RegExp | undefined;\n        /**\n        * Used to reference the data object in the template text.\n        */\n        variable?: string | undefined;\n    }\n    /**\n     * Creates a cache object to store key/value pairs.\n     */\n    interface MapCache {\n        /**\n         * Removes `key` and its value from the cache.\n         * @param key The key of the value to remove.\n         * @return Returns `true` if the entry was removed successfully, else `false`.\n         */\n        delete(key: any): boolean;\n        /**\n         * Gets the cached value for `key`.\n         * @param key The key of the value to get.\n         * @return Returns the cached value.\n         */\n        get(key: any): any;\n        /**\n         * Checks if a cached value for `key` exists.\n         * @param key The key of the entry to check.\n         * @return Returns `true` if an entry for `key` exists, else `false`.\n         */\n        has(key: any): boolean;\n        /**\n         * Sets `value` to `key` of the cache.\n         * @param key The key of the value to cache.\n         * @param value The value to cache.\n         * @return Returns the cache object.\n         */\n        set(key: any, value: any): this;\n        /**\n         * Removes all key-value entries from the map.\n         */\n        clear?: (() => void) | undefined;\n    }\n    interface MapCacheConstructor {\n        new (): MapCache;\n    }\n    interface Collection<T> {\n        pop(): T | undefined;\n        push(...items: T[]): this;\n        shift(): T | undefined;\n        sort(compareFn?: (a: T, b: T) => number): this;\n        splice(start: number, deleteCount?: number, ...items: T[]): this;\n        unshift(...items: T[]): this;\n    }\n    interface CollectionChain<T> {\n        pop(): ExpChain<T | undefined>;\n        push(...items: T[]): this;\n        shift(): ExpChain<T | undefined>;\n        sort(compareFn?: (a: T, b: T) => number): this;\n        splice(start: number, deleteCount?: number, ...items: T[]): this;\n        unshift(...items: T[]): this;\n    }\n    interface Function<T extends (...args: any) => any> extends LoDashImplicitWrapper<T> {\n    }\n    interface String extends LoDashImplicitWrapper<string> {\n    }\n    interface Object<T> extends LoDashImplicitWrapper<T> {\n    }\n    interface Collection<T> extends LoDashImplicitWrapper<T[]> {\n    }\n    interface Primitive<T> extends LoDashImplicitWrapper<T> {\n    }\n    interface FunctionChain<T extends (...args: any) => any> extends LoDashExplicitWrapper<T> {\n    }\n    interface StringChain extends LoDashExplicitWrapper<string> {\n    }\n    interface StringNullableChain extends LoDashExplicitWrapper<string | undefined> {\n    }\n    interface ObjectChain<T> extends LoDashExplicitWrapper<T> {\n    }\n    interface CollectionChain<T> extends LoDashExplicitWrapper<T[]> {\n    }\n    interface PrimitiveChain<T> extends LoDashExplicitWrapper<T> {\n    }\n    type NotVoid = unknown;\n    type IterateeShorthand<T> = PropertyName | [PropertyName, any] | PartialShallow<T>;\n    type ArrayIterator<T, TResult> = (value: T, index: number, collection: T[]) => TResult;\n    type ListIterator<T, TResult> = (value: T, index: number, collection: List<T>) => TResult;\n    type ListIteratee<T> = ListIterator<T, NotVoid> | IterateeShorthand<T>;\n    type ListIterateeCustom<T, TResult> = ListIterator<T, TResult> | IterateeShorthand<T>;\n    type ListIteratorTypeGuard<T, S extends T> = (value: T, index: number, collection: List<T>) => value is S;\n    // Note: key should be string, not keyof T, because the actual object may contain extra properties that were not specified in the type.\n    type ObjectIterator<TObject, TResult> = (value: TObject[keyof TObject], key: string, collection: TObject) => TResult;\n    type ObjectIteratee<TObject> = ObjectIterator<TObject, NotVoid> | IterateeShorthand<TObject[keyof TObject]>;\n    type ObjectIterateeCustom<TObject, TResult> = ObjectIterator<TObject, TResult> | IterateeShorthand<TObject[keyof TObject]>;\n    type ObjectIteratorTypeGuard<TObject, S extends TObject[keyof TObject]> = (value: TObject[keyof TObject], key: string, collection: TObject) => value is S;\n    type StringIterator<TResult> = (char: string, index: number, string: string) => TResult;\n    /** @deprecated Use MemoVoidArrayIterator or MemoVoidDictionaryIterator instead. */\n    type MemoVoidIterator<T, TResult> = (prev: TResult, curr: T, indexOrKey: any, list: T[]) => void;\n    /** @deprecated Use MemoListIterator or MemoObjectIterator instead. */\n    type MemoIterator<T, TResult> = (prev: TResult, curr: T, indexOrKey: any, list: T[]) => TResult;\n    type MemoListIterator<T, TResult, TList> = (prev: TResult, curr: T, index: number, list: TList) => TResult;\n    type MemoObjectIterator<T, TResult, TList> = (prev: TResult, curr: T, key: string, list: TList) => TResult;\n    type MemoIteratorCapped<T, TResult> = (prev: TResult, curr: T) => TResult;\n    type MemoIteratorCappedRight<T, TResult> = (curr: T, prev: TResult) => TResult;\n    type MemoVoidArrayIterator<T, TResult> = (acc: TResult, curr: T, index: number, arr: T[]) => void;\n    type MemoVoidDictionaryIterator<T, K extends string | number | symbol, TResult> = (acc: TResult, curr: T, key: K, dict: Record<K, T>) => void;\n    type MemoVoidIteratorCapped<T, TResult> = (acc: TResult, curr: T) => void;\n    type ValueIteratee<T> = ((value: T) => NotVoid) | IterateeShorthand<T>;\n    type ValueIterateeCustom<T, TResult> = ((value: T) => TResult) | IterateeShorthand<T>;\n    type ValueIteratorTypeGuard<T, S extends T> = (value: T) => value is S;\n    type ValueKeyIteratee<T> = ((value: T, key: string) => NotVoid) | IterateeShorthand<T>;\n    type ValueKeyIterateeTypeGuard<T, S extends T> = (value: T, key: string) => value is S;\n    type Comparator<T> = (a: T, b: T) => boolean;\n    type Comparator2<T1, T2> = (a: T1, b: T2) => boolean;\n    type PropertyName = string | number | symbol;\n    type PropertyPath = Many<PropertyName>;\n    /** Common interface between Arrays and jQuery objects */\n    type List<T> = ArrayLike<T>;\n    interface Dictionary<T> {\n        [index: string]: T;\n    }\n    interface NumericDictionary<T> {\n        [index: number]: T;\n    }\n    // Crazy typedef needed get _.omit to work properly with Dictionary and NumericDictionary\n    type AnyKindOfDictionary =\n        | Dictionary<unknown>\n        | NumericDictionary<unknown>;\n    type PartialShallow<T> = {\n        [P in keyof T]?: T[P] extends object ? object : T[P]\n    };\n    // For backwards compatibility\n    type LoDashImplicitArrayWrapper<T> = LoDashImplicitWrapper<T[]>;\n    type LoDashImplicitNillableArrayWrapper<T> = LoDashImplicitWrapper<T[] | null | undefined>;\n    type LoDashImplicitObjectWrapper<T> = LoDashImplicitWrapper<T>;\n    type LoDashImplicitNillableObjectWrapper<T> = LoDashImplicitWrapper<T | null | undefined>;\n    type LoDashImplicitNumberArrayWrapper = LoDashImplicitWrapper<number[]>;\n    type LoDashImplicitStringWrapper = LoDashImplicitWrapper<string>;\n    type LoDashExplicitArrayWrapper<T> = LoDashExplicitWrapper<T[]>;\n    type LoDashExplicitNillableArrayWrapper<T> = LoDashExplicitWrapper<T[] | null | undefined>;\n    type LoDashExplicitObjectWrapper<T> = LoDashExplicitWrapper<T>;\n    type LoDashExplicitNillableObjectWrapper<T> = LoDashExplicitWrapper<T | null | undefined>;\n    type LoDashExplicitNumberArrayWrapper = LoDashExplicitWrapper<number[]>;\n    type LoDashExplicitStringWrapper = LoDashExplicitWrapper<string>;\n    type DictionaryIterator<T, TResult> = ObjectIterator<Dictionary<T>, TResult>;\n    type DictionaryIteratee<T> = ObjectIteratee<Dictionary<T>>;\n    type DictionaryIteratorTypeGuard<T, S extends T> = ObjectIteratorTypeGuard<Dictionary<T>, S>;\n    // NOTE: keys of objects at run time are always strings, even when a NumericDictionary is being iterated.\n    type NumericDictionaryIterator<T, TResult> = (value: T, key: string, collection: NumericDictionary<T>) => TResult;\n    type NumericDictionaryIteratee<T> = NumericDictionaryIterator<T, NotVoid> | IterateeShorthand<T>;\n    type NumericDictionaryIterateeCustom<T, TResult> = NumericDictionaryIterator<T, TResult> | IterateeShorthand<T>;\n}\n'}}]);
//# sourceMappingURL=578.c6f9581d.chunk.js.map