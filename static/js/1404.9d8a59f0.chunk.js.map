{"version":3,"file":"static/js/1404.9d8a59f0.chunk.js","mappings":"oIAAA","sources":["../node_modules/@types/lodash/common/array.d.ts"],"sourcesContent":["export default \"import _ = require(\\\"../index\\\");\\ndeclare module \\\"../index\\\" {\\n    interface LoDashStatic {\\n        /**\\n         * Creates an array of elements split into groups the length of size. If collection canâ€™t be split evenly, the\\n         * final chunk will be the remaining elements.\\n         *\\n         * @param array The array to process.\\n         * @param size The length of each chunk.\\n         * @return Returns the new array containing chunks.\\n         */\\n        chunk<T>(array: List<T> | null | undefined, size?: number): T[][];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.chunk\\n         */\\n        chunk(size?: number): Collection<T[]>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.chunk\\n         */\\n        chunk(size?: number): CollectionChain<T[]>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates an array with all falsey values removed. The values false, null, 0, \\\"\\\", undefined, and NaN are\\n         * falsey.\\n         *\\n         * @param array The array to compact.\\n         * @return Returns the new array of filtered values.\\n         */\\n        compact<T>(array: List<T | null | undefined | false | \\\"\\\" | 0> | null | undefined): T[];\\n    }\\n\\n    type Truthy<T> = T extends null | undefined | false | \\\"\\\" | 0 ? never : T;\\n    interface Collection<T> {\\n        /**\\n         * @see _.compact\\n         */\\n        compact(): Collection<Truthy<T>>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.compact\\n         */\\n        compact(): CollectionChain<Truthy<T>>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a new array concatenating `array` with any additional arrays\\n         * and/or values.\\n         *\\n         * @category Array\\n         * @param [values] The array values to concatenate.\\n         * @returns Returns the new concatenated array.\\n         * @example\\n         *\\n         * var array = [1];\\n         * var other = _.concat(array, 2, [3], [[4]]);\\n         *\\n         * console.log(other);\\n         * // => [1, 2, 3, [4]]\\n         *\\n         * console.log(array);\\n         * // => [1]\\n         */\\n         concat<T>(...values: Array<Many<T>>): T[];\\n    }\\n    interface Primitive<T> {\\n        /**\\n         * @see _.concat\\n         */\\n        concat(...values: Array<Many<T>>): Collection<T>;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.concat\\n         */\\n        concat(...values: Array<Many<T>>): Collection<T>;\\n    }\\n    interface Object<T> {\\n        /**\\n         * @see _.concat\\n         */\\n        concat(...values: Array<Many<T>>): Collection<T>;\\n    }\\n    interface PrimitiveChain<T> {\\n        /**\\n         * @see _.concat\\n         */\\n        concat(...values: Array<Many<T>>): CollectionChain<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.concat\\n         */\\n        concat(...values: Array<Many<T>>): CollectionChain<T>;\\n    }\\n    interface ObjectChain<T> {\\n        /**\\n         * @see _.concat\\n         */\\n        concat(...values: Array<Many<T>>): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates an array of `array` values not included in the other provided arrays using SameValueZero for\\n         * equality comparisons. The order and references of result values are determined by the first array.\\n         *\\n         * @param array The array to inspect.\\n         * @param values The arrays of values to exclude.\\n         * @return Returns the new array of filtered values.\\n         */\\n        difference<T>(array: List<T> | null | undefined, ...values: Array<List<T>>): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.difference\\n         */\\n        difference(...values: Array<List<T>>): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.difference\\n         */\\n        difference(...values: Array<List<T>>): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like _.difference except that it accepts iteratee which is invoked for each element\\n         * of array and values to generate the criterion by which they're compared. The order and references\\n         * of result values are determined by the first array. The iteratee is invoked with one argument: (value).\\n         *\\n         * @param array The array to inspect.\\n         * @param values The values to exclude.\\n         * @param iteratee The iteratee invoked per element.\\n         * @returns Returns the new array of filtered values.\\n         */\\n        differenceBy<T1, T2>(array: List<T1> | null | undefined, values: List<T2>, iteratee: ValueIteratee<T1 | T2>): T1[];\\n        /**\\n         * @see _.differenceBy\\n         */\\n        differenceBy<T1, T2, T3>(array: List<T1> | null | undefined, values1: List<T2>, values2: List<T3>, iteratee: ValueIteratee<T1 | T2 | T3>): T1[];\\n        /**\\n         * @see _.differenceBy\\n         */\\n        differenceBy<T1, T2, T3, T4>(array: List<T1> | null | undefined, values1: List<T2>, values2: List<T3>, values3: List<T4>, iteratee: ValueIteratee<T1 | T2 | T3 | T4>): T1[];\\n        /**\\n         * @see _.differenceBy\\n         */\\n        differenceBy<T1, T2, T3, T4, T5>(array: List<T1> | null | undefined, values1: List<T2>, values2: List<T3>, values3: List<T4>, values4: List<T5>, iteratee: ValueIteratee<T1 | T2 | T3 | T4 | T5>): T1[];\\n        /**\\n         * @see _.differenceBy\\n         */\\n        differenceBy<T1, T2, T3, T4, T5, T6>(array: List<T1> | null | undefined, values1: List<T2>, values2: List<T3>, values3: List<T4>, values4: List<T5>, values5: List<T6>, iteratee: ValueIteratee<T1 | T2 | T3 | T4 | T5 | T6>): T1[];\\n        /**\\n         * @see _.differenceBy\\n         */\\n        differenceBy<T1, T2, T3, T4, T5, T6, T7>(array: List<T1> | null | undefined, values1: List<T2>, values2: List<T3>, values3: List<T4>, values4: List<T5>, values5: List<T6>, ...values: Array<List<T7> | ValueIteratee<T1 | T2 | T3 | T4 | T5 | T6 | T7>>): T1[];\\n        /**\\n         * @see _.differenceBy\\n         */\\n        differenceBy<T>(array: List<T> | null | undefined, ...values: Array<List<T>>): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.differenceBy\\n         */\\n        differenceBy<T2>(values1: List<T2>, iteratee?: ValueIteratee<T | T2>): Collection<T>;\\n        /**\\n         * @see _.differenceBy\\n         */\\n        differenceBy(...values: Array<List<unknown> | ValueIteratee<T>>): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.differenceBy\\n         */\\n        differenceBy<T2>(values1: List<T2>, iteratee?: ValueIteratee<T | T2>): CollectionChain<T>;\\n        /**\\n         * @see _.differenceBy\\n         */\\n        differenceBy(...values: Array<List<unknown> | ValueIteratee<T>>): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like _.difference except that it accepts comparator which is invoked to compare elements\\n         * of array to values. The order and references of result values are determined by the first array. The\\n         * comparator is invoked with two arguments: (arrVal, othVal).\\n         *\\n         * @category Array\\n         * @param [values] The arrays to inspect.\\n         * @param [comparator] The comparator invoked per element.\\n         * @returns Returns the new array of filtered values.\\n         * @example\\n         *\\n         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\\n\\n         * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\\n         * // => [{ 'x': 2, 'y': 1 }]\\n         */\\n        differenceWith<T1, T2>(array: List<T1> | null | undefined, values: List<T2>, comparator: Comparator2<T1, T2>): T1[];\\n        /**\\n         * @see _.differenceWith\\n         */\\n        differenceWith<T1, T2, T3>(array: List<T1> | null | undefined, values1: List<T2>, values2: List<T3>, comparator: Comparator2<T1, T2 | T3>): T1[];\\n        /**\\n         * @see _.differenceWith\\n         */\\n        differenceWith<T1, T2, T3, T4>(array: List<T1> | null | undefined, values1: List<T2>, values2: List<T3>, ...values: Array<List<T4> | Comparator2<T1, T2 | T3 | T4>>): T1[];\\n        /**\\n         * @see _.differenceWith\\n         */\\n        differenceWith<T>(array: List<T> | null | undefined, ...values: Array<List<T>>): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.differenceWith\\n         */\\n        differenceWith<T2>(values: List<T2>, comparator: Comparator2<T, T2>): Collection<T>;\\n        /**\\n         * @see _.differenceWith\\n         */\\n        differenceWith<T2, T3, T4>(...values: Array<List<unknown> | Comparator2<T, never>>): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.differenceWith\\n         */\\n        differenceWith< T2>(values: List<T2>, comparator: Comparator2<T, T2>): CollectionChain<T>;\\n        /**\\n         * @see _.differenceWith\\n         */\\n        differenceWith< T2, T3, T4>(...values: Array<List<unknown> | Comparator2<T, never>>): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a slice of array with n elements dropped from the beginning.\\n         *\\n         * @param array The array to query.\\n         * @param n The number of elements to drop.\\n         * @return Returns the slice of array.\\n         */\\n        drop<T>(array: List<T> | null | undefined, n?: number): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.drop\\n         */\\n        drop(n?: number): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.drop\\n         */\\n        drop(n?: number): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a slice of array with n elements dropped from the end.\\n         *\\n         * @param array The array to query.\\n         * @param n The number of elements to drop.\\n         * @return Returns the slice of array.\\n         */\\n        dropRight<T>(array: List<T> | null | undefined, n?: number): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.dropRight\\n         */\\n        dropRight(n?: number): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.dropRight\\n         */\\n        dropRight(n?: number): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a slice of array excluding elements dropped from the end. Elements are dropped until predicate\\n         * returns falsey. The predicate is invoked with three arguments: (value, index, array).\\n         *\\n         * @param array The array to query.\\n         * @param predicate The function invoked per iteration.\\n         * @return Returns the slice of array.\\n         */\\n        dropRightWhile<T>(array: List<T> | null | undefined, predicate?: ListIteratee<T>): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.dropRightWhile\\n         */\\n        dropRightWhile(predicate?: ListIteratee<T>): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.dropRightWhile\\n         */\\n        dropRightWhile(predicate?: ListIteratee<T>): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a slice of array excluding elements dropped from the beginning. Elements are dropped until predicate\\n         * returns falsey. The predicate is invoked with three arguments: (value, index, array).\\n         *\\n         * @param array The array to query.\\n         * @param predicate The function invoked per iteration.\\n         * @return Returns the slice of array.\\n         */\\n        dropWhile<T>(array: List<T> | null | undefined, predicate?: ListIteratee<T>): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.dropWhile\\n         */\\n        dropWhile(predicate?: ListIteratee<T>): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.dropWhile\\n         */\\n        dropWhile(predicate?: ListIteratee<T>): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Fills elements of array with value from start up to, but not including, end.\\n         *\\n         * Note: This method mutates array.\\n         *\\n         * @param array The array to fill.\\n         * @param value The value to fill array with.\\n         * @param start The start position.\\n         * @param end The end position.\\n         * @return Returns array.\\n         */\\n        fill<T>(array: any[] | null | undefined, value: T): T[];\\n        /**\\n         * @see _.fill\\n         */\\n        fill<T>(array: List<any> | null | undefined, value: T): List<T>;\\n        /**\\n         * @see _.fill\\n         */\\n        fill<T, U>(array: U[] | null | undefined, value: T, start?: number, end?: number): Array<T | U>;\\n        /**\\n         * @see _.fill\\n         */\\n        fill<T, U>(array: List<U> | null | undefined, value: T, start?: number, end?: number): List<T | U>;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.fill\\n         */\\n        fill<U>(value: U, start?: number, end?: number): Collection<T | U>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.fill\\n         */\\n        fill<U>(value: U, start?: number, end?: number): CollectionChain<T | U>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like _.find except that it returns the index of the first element predicate returns truthy\\n         * for instead of the element itself.\\n         *\\n         * @param array The array to search.\\n         * @param predicate The function invoked per iteration.\\n         * @param fromIndex The index to search from.\\n         * @return Returns the index of the found element, else -1.\\n         */\\n        findIndex<T>(array: List<T> | null | undefined, predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): number;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.findIndex\\n         */\\n        findIndex(predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): number;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.findIndex\\n         */\\n        findIndex(predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): PrimitiveChain<number>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like _.findIndex except that it iterates over elements of collection from right to left.\\n         *\\n         * @param array The array to search.\\n         * @param predicate The function invoked per iteration.\\n         * @param fromIndex The index to search from.\\n         * @return Returns the index of the found element, else -1.\\n         */\\n        findLastIndex<T>(array: List<T> | null | undefined, predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): number;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.findLastIndex\\n         */\\n        findLastIndex(predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): number;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.findLastIndex\\n         */\\n        findLastIndex(predicate?: ListIterateeCustom<T, boolean>, fromIndex?: number): PrimitiveChain<number>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * @see _.head\\n         */\\n        first: LoDashStatic[\\\"head\\\"];\\n    }\\n    interface String {\\n        /**\\n         * @see _.first\\n         */\\n        first(): string | undefined;\\n    }\\n    interface StringChain {\\n        /**\\n         * @see _.first\\n         */\\n        first(): StringNullableChain;\\n    }\\n    interface StringNullableChain {\\n        /**\\n         * @see _.first\\n         */\\n        first(): StringNullableChain;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.first\\n         */\\n        first(): T | undefined;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.first\\n         */\\n        first(): ExpChain<T | undefined>;\\n    }\\n    interface RecursiveArray<T> extends Array<T|RecursiveArray<T>> {}\\n    interface ListOfRecursiveArraysOrValues<T> extends List<T|RecursiveArray<T>> {}\\n    interface LoDashStatic {\\n        /**\\n         * Flattens `array` a single level deep.\\n         *\\n         * @param array The array to flatten.\\n         * @return Returns the new flattened array.\\n         */\\n        flatten<T>(array: List<Many<T>> | null | undefined): T[];\\n    }\\n    interface String {\\n        /**\\n         * @see _.flatten\\n         */\\n        flatten(): Collection<string>;\\n    }\\n    interface StringChain {\\n        /**\\n         * @see _.flatten\\n         */\\n        flatten(): CollectionChain<string>;\\n    }\\n    interface StringNullableChain {\\n        /**\\n         * @see _.flatten\\n         */\\n        flatten(): CollectionChain<string>;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.flatten\\n         */\\n        flatten(): T extends Many<infer U> ? Collection<U> : Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.flatten\\n         */\\n        flatten(): T extends Many<infer U> ? CollectionChain<U> : CollectionChain<T>;\\n    }\\n\\n    type Flat<T> = T extends string ? T : (T extends List<any> ? never : T);\\n\\n    interface LoDashStatic {\\n        /**\\n         * Recursively flattens a nested array.\\n         *\\n         * @param array The array to recursively flatten.\\n         * @return Returns the new flattened array.\\n         */\\n        flattenDeep<T>(array: ListOfRecursiveArraysOrValues<T> | null | undefined): Array<Flat<T>>;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.flattenDeep\\n         */\\n        flattenDeep(): T extends ListOfRecursiveArraysOrValues<infer U> ? Collection<Flat<U>> : Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.flattenDeep\\n         */\\n        flattenDeep(): T extends ListOfRecursiveArraysOrValues<infer U> ? CollectionChain<Flat<U>> : CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Recursively flatten array up to depth times.\\n         *\\n         * @param array The array to recursively flatten.\\n         * @param number The maximum recursion depth.\\n         * @return Returns the new flattened array.\\n         */\\n        flattenDepth<T>(array: ListOfRecursiveArraysOrValues<T> | null | undefined, depth?: number): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.flattenDepth\\n         */\\n        flattenDepth(depth?: number): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.flattenDepth\\n         */\\n        flattenDepth(depth?: number): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * The inverse of `_.toPairs`; this method returns an object composed\\n         * from key-value `pairs`.\\n         *\\n         * @category Array\\n         * @param pairs The key-value pairs.\\n         * @returns Returns the new object.\\n         * @example\\n         *\\n         * _.fromPairs([['fred', 30], ['barney', 40]]);\\n         * // => { 'fred': 30, 'barney': 40 }\\n         */\\n        fromPairs<T>(pairs: List<[PropertyName, T]> | null | undefined): Dictionary<T>;\\n        /**\\n         * @see _.fromPairs\\n         */\\n        fromPairs(pairs: List<any[]> | null | undefined): Dictionary<any>;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.fromPairs\\n         */\\n        fromPairs(): Object<Dictionary<T extends [PropertyName, infer U] ? U : any>>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.fromPairs\\n         */\\n        fromPairs(): ObjectChain<Dictionary<T extends [PropertyName, infer U] ? U : any>>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Gets the first element of array.\\n         *\\n         * @alias _.first\\n         *\\n         * @param array The array to query.\\n         * @return Returns the first element of array.\\n         */\\n        head<T>(array: List<T> | null | undefined): T | undefined;\\n    }\\n    interface String {\\n        /**\\n         * @see _.head\\n         */\\n        head(): string | undefined;\\n    }\\n    interface StringChain {\\n        /**\\n         * @see _.head\\n         */\\n        head(): StringNullableChain;\\n    }\\n    interface StringNullableChain {\\n        /**\\n         * @see _.head\\n         */\\n        head(): StringNullableChain;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.head\\n         */\\n        head(): T | undefined;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.head\\n         */\\n        head(): ExpChain<T | undefined>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Gets the index at which the first occurrence of `value` is found in `array`\\n         * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\\n         * for equality comparisons. If `fromIndex` is negative, it's used as the offset\\n         * from the end of `array`.\\n         *\\n         * @category Array\\n         * @param array The array to search.\\n         * @param value The value to search for.\\n         * @param [fromIndex=0] The index to search from.\\n         * @returns Returns the index of the matched value, else `-1`.\\n         * @example\\n         *\\n         * _.indexOf([1, 2, 1, 2], 2);\\n         * // => 1\\n         *\\n         * // using `fromIndex`\\n         * _.indexOf([1, 2, 1, 2], 2, 2);\\n         * // => 3\\n         */\\n        indexOf<T>(array: List<T> | null | undefined, value: T, fromIndex?: number): number;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.indexOf\\n         */\\n        indexOf(value: T, fromIndex?: number): number;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.indexOf\\n         */\\n        indexOf(value: T, fromIndex?: number): PrimitiveChain<number>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Gets all but the last element of array.\\n         *\\n         * @param array The array to query.\\n         * @return Returns the slice of array.\\n         */\\n        initial<T>(array: List<T> | null | undefined): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.initial\\n         */\\n        initial(): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.initial\\n         */\\n        initial(): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates an array of unique values that are included in all of the provided arrays using SameValueZero for\\n         * equality comparisons.\\n         *\\n         * @param arrays The arrays to inspect.\\n         * @return Returns the new array of shared values.\\n         */\\n        intersection<T>(...arrays: Array<List<T> | null | undefined>): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.intersection\\n         */\\n        intersection(...arrays: Array<List<T> | null | undefined>): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.intersection\\n         */\\n        intersection(...arrays: Array<List<T> | null | undefined>): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like `_.intersection` except that it accepts `iteratee`\\n         * which is invoked for each element of each `arrays` to generate the criterion\\n         * by which uniqueness is computed. The iteratee is invoked with one argument: (value).\\n         *\\n         * @category Array\\n         * @param [arrays] The arrays to inspect.\\n         * @param [iteratee=_.identity] The iteratee invoked per element.\\n         * @returns Returns the new array of shared values.\\n         * @example\\n         *\\n         * _.intersectionBy([2.1, 1.2], [4.3, 2.4], Math.floor);\\n         * // => [2.1]\\n         *\\n         * // using the `_.property` iteratee shorthand\\n         * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\\n         * // => [{ 'x': 1 }]\\n         */\\n        intersectionBy<T1, T2>(array: List<T1> | null, values: List<T2>, iteratee: ValueIteratee<T1 | T2>): T1[];\\n        /**\\n         * @see _.intersectionBy\\n         */\\n        intersectionBy<T1, T2, T3>(array: List<T1> | null, values1: List<T2>, values2: List<T3>, iteratee: ValueIteratee<T1 | T2 | T3>): T1[];\\n        /**\\n         * @see _.intersectionBy\\n         */\\n        intersectionBy<T1, T2, T3, T4>(array: List<T1> | null | undefined, values1: List<T2>, values2: List<T3>, ...values: Array<List<T4> | ValueIteratee<T1 | T2 | T3 | T4>>): T1[];\\n        /**\\n         * @see _.intersectionBy\\n         */\\n        intersectionBy<T>(array?: List<T> | null, ...values: Array<List<T>>): T[];\\n        /**\\n         * @see _.intersectionBy\\n         */\\n        intersectionBy<T>(...values: Array<List<T> | ValueIteratee<T>>): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.intersectionBy\\n         */\\n        intersectionBy<T2>(values: List<T2>, iteratee: ValueIteratee<T | T2>): Collection<T>;\\n        /**\\n         * @see _.intersectionBy\\n         */\\n        intersectionBy(...values: Array<List<unknown> | ValueIteratee<T>>): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.intersectionBy\\n         */\\n        intersectionBy<T2>(values: List<T2>, iteratee: ValueIteratee<T | T2>): CollectionChain<T>;\\n        /**\\n         * @see _.intersectionBy\\n         */\\n        intersectionBy(...values: Array<List<unknown> | ValueIteratee<T>>): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates an array of unique `array` values not included in the other\\n         * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\\n         * for equality comparisons.\\n         *\\n         * @category Array\\n         * @param [values] The arrays to inspect.\\n         * @param [comparator] The comparator invoked per element.\\n         * @returns Returns the new array of filtered values.\\n         * @example\\n         *\\n         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\\n         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\\n\\n         * _.intersectionWith(objects, others, _.isEqual);\\n         * // => [{ 'x': 1, 'y': 2 }]\\n         */\\n        intersectionWith<T1, T2>(array: List<T1> | null | undefined, values: List<T2>, comparator: Comparator2<T1, T2>): T1[];\\n        /**\\n         * @see _.intersectionWith\\n         */\\n        intersectionWith<T1, T2, T3>(array: List<T1> | null | undefined, values1: List<T2>, values2: List<T3>, comparator: Comparator2<T1, T2 | T3>): T1[];\\n        /**\\n         * @see _.intersectionWith\\n         */\\n        intersectionWith<T1, T2, T3, T4>(array: List<T1> | null | undefined, values1: List<T2>, values2: List<T3>, ...values: Array<List<T4> | Comparator2<T1, T2 | T3 | T4>>): T1[];\\n        /**\\n         * @see _.intersectionWith\\n         */\\n        intersectionWith<T>(array?: List<T> | null, ...values: Array<List<T> | Comparator2<T, never>>): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.intersectionWith\\n         */\\n        intersectionWith<T2>(values: List<T2>, comparator: Comparator2<T, T2>): Collection<T>;\\n        /**\\n         * @see _.intersectionWith\\n         */\\n        intersectionWith(...values: Array<List<unknown> | Comparator2<T,  never>>): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.intersectionWith\\n         */\\n        intersectionWith<T2>(values: List<T2>, comparator: Comparator2<T, T2>): CollectionChain<T>;\\n        /**\\n         * @see _.intersectionWith\\n         */\\n        intersectionWith(...values: Array<List<unknown> | Comparator2<T,  never>>): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Converts all elements in `array` into a string separated by `separator`.\\n         *\\n         * @param array The array to convert.\\n         * @param separator The element separator.\\n         * @returns Returns the joined string.\\n         */\\n        join(array: List<any> | null | undefined, separator?: string): string;\\n    }\\n    interface String {\\n        /**\\n         * @see _.join\\n         */\\n        join(separator?: string): string;\\n    }\\n    interface StringChain {\\n        /**\\n         * @see _.join\\n         */\\n        join(separator?: string): StringChain;\\n    }\\n    interface StringNullableChain {\\n        /**\\n         * @see _.join\\n         */\\n        join(separator?: string): StringChain;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.join\\n         */\\n        join(separator?: string): string;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.join\\n         */\\n        join(separator?: string): StringChain;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Gets the last element of array.\\n         *\\n         * @param array The array to query.\\n         * @return Returns the last element of array.\\n         */\\n        last<T>(array: List<T> | null | undefined): T | undefined;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.last\\n         */\\n        last(): T | undefined;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.last\\n         */\\n        last(): ExpChain<T | undefined>;\\n    }\\n    interface String {\\n        /**\\n         * @see _.last\\n         */\\n        last(): string | undefined;\\n    }\\n    interface StringChain {\\n        /**\\n         * @see _.last\\n         */\\n        last(): StringNullableChain;\\n    }\\n    interface StringNullableChain {\\n        /**\\n         * @see _.last\\n         */\\n        last(): StringNullableChain;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like _.indexOf except that it iterates over elements of array from right to left.\\n         *\\n         * @param array The array to search.\\n         * @param value The value to search for.\\n         * @param fromIndex The index to search from or true to perform a binary search on a sorted array.\\n         * @return Returns the index of the matched value, else -1.\\n         */\\n        lastIndexOf<T>(array: List<T> | null | undefined, value: T, fromIndex?: true|number): number;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.lastIndexOf\\n         */\\n        lastIndexOf(value: T, fromIndex?: true|number): number;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.lastIndexOf\\n         */\\n        lastIndexOf(value: T, fromIndex?: true|number): PrimitiveChain<number>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Gets the element at index `n` of `array`. If `n` is negative, the nth element from the end is returned.\\n         *\\n         * @param array array The array to query.\\n         * @param value The index of the element to return.\\n         * @return Returns the nth element of `array`.\\n         */\\n        nth<T>(array: List<T> | null | undefined, n?: number): T | undefined;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.nth\\n         */\\n        nth(n?: number): T | undefined;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.nth\\n         */\\n        nth(n?: number): ExpChain<T | undefined>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Removes all provided values from array using SameValueZero for equality comparisons.\\n         *\\n         * Note: Unlike _.without, this method mutates array.\\n         *\\n         * @param array The array to modify.\\n         * @param values The values to remove.\\n         * @return Returns array.\\n         */\\n        pull<T>(array: T[], ...values: T[]): T[];\\n        /**\\n         * @see _.pull\\n         */\\n        pull<T>(array: List<T>, ...values: T[]): List<T>;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.pull\\n         */\\n        pull(...values: T[]): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.pull\\n         */\\n        pull(...values: T[]): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like `_.pull` except that it accepts an array of values to remove.\\n         *\\n         * **Note:** Unlike `_.difference`, this method mutates `array`.\\n         *\\n         * @category Array\\n         * @param array The array to modify.\\n         * @param values The values to remove.\\n         * @returns Returns `array`.\\n         * @example\\n         *\\n         * var array = [1, 2, 3, 1, 2, 3];\\n         *\\n         * _.pull(array, [2, 3]);\\n         * console.log(array);\\n         * // => [1, 1]\\n         */\\n        pullAll<T>(array: T[], values?: List<T>): T[];\\n        /**\\n         * @see _.pullAll\\n         */\\n        pullAll<T>(array: List<T>, values?: List<T>): List<T>;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.pullAll\\n         */\\n        pullAll(values?: List<T>): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.pullAll\\n         */\\n        pullAll(values?: List<T>): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like `_.pullAll` except that it accepts `iteratee` which is\\n         * invoked for each element of `array` and `values` to to generate the criterion\\n         * by which uniqueness is computed. The iteratee is invoked with one argument: (value).\\n         *\\n         * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\\n         *\\n         * @category Array\\n         * @param array The array to modify.\\n         * @param values The values to remove.\\n         * @param [iteratee=_.identity] The iteratee invoked per element.\\n         * @returns Returns `array`.\\n         * @example\\n         *\\n         * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\\n         *\\n         * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\\n         * console.log(array);\\n         * // => [{ 'x': 2 }]\\n         */\\n        pullAllBy<T>(array: T[], values?: List<T>, iteratee?: ValueIteratee<T>): T[];\\n        /**\\n         * @see _.pullAllBy\\n         */\\n        pullAllBy<T>(array: List<T>, values?: List<T>, iteratee?: ValueIteratee<T>): List<T>;\\n        /**\\n         * @see _.pullAllBy\\n         */\\n        pullAllBy<T1, T2>(array: T1[], values: List<T2>, iteratee: ValueIteratee<T1 | T2>): T1[];\\n        /**\\n         * @see _.pullAllBy\\n         */\\n        pullAllBy<T1, T2>(array: List<T1>, values: List<T2>, iteratee: ValueIteratee<T1 | T2>): List<T1>;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.pullAllBy\\n         */\\n        pullAllBy<T2>(values?: List<T2>, iteratee?: ValueIteratee<T | T2>): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.pullAllBy\\n         */\\n        pullAllBy<T2>(values?: List<T2>, iteratee?: ValueIteratee<T | T2>): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like `_.pullAll` except that it accepts `comparator` which is\\n         * invoked to compare elements of array to values. The comparator is invoked with\\n         * two arguments: (arrVal, othVal).\\n         *\\n         * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\\n         *\\n         * @category Array\\n         * @param array The array to modify.\\n         * @param values The values to remove.\\n         * @param [iteratee=_.identity] The iteratee invoked per element.\\n         * @returns Returns `array`.\\n         * @example\\n         *\\n         * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\\n         *\\n         * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\\n         * console.log(array);\\n         * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\\n         */\\n        pullAllWith<T>(array: T[], values?: List<T>, comparator?: Comparator<T>): T[];\\n        /**\\n         * @see _.pullAllWith\\n         */\\n        pullAllWith<T>(array: List<T>, values?: List<T>, comparator?: Comparator<T>): List<T>;\\n        /**\\n         * @see _.pullAllWith\\n         */\\n        pullAllWith<T1, T2>(array: T1[], values: List<T2>, comparator: Comparator2<T1, T2>): T1[];\\n        /**\\n         * @see _.pullAllWith\\n         */\\n        pullAllWith<T1, T2>(array: List<T1>, values: List<T2>, comparator: Comparator2<T1, T2>): List<T1>;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.pullAllWith\\n         */\\n        pullAllWith<T2>(values?: List<T2>, comparator?: Comparator2<T, T2>): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.pullAllWith\\n         */\\n        pullAllWith<T2>(values?: List<T2>, comparator?: Comparator2<T, T2>): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Removes elements from array corresponding to the given indexes and returns an array of the removed elements.\\n         * Indexes may be specified as an array of indexes or as individual arguments.\\n         *\\n         * Note: Unlike _.at, this method mutates array.\\n         *\\n         * @param array The array to modify.\\n         * @param indexes The indexes of elements to remove, specified as individual indexes or arrays of indexes.\\n         * @return Returns the new array of removed elements.\\n         */\\n        pullAt<T>(array: T[], ...indexes: Array<Many<number>>): T[];\\n        /**\\n         * @see _.pullAt\\n         */\\n        pullAt<T>(array: List<T>, ...indexes: Array<Many<number>>): List<T>;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.pullAt\\n         */\\n        pullAt(...indexes: Array<Many<number>>): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.pullAt\\n         */\\n        pullAt(...indexes: Array<Many<number>>): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Removes all elements from array that predicate returns truthy for and returns an array of the removed\\n         * elements. The predicate is invoked with three arguments: (value, index, array).\\n         *\\n         * Note: Unlike _.filter, this method mutates array.\\n         *\\n         * @param array The array to modify.\\n         * @param predicate The function invoked per iteration.\\n         * @return Returns the new array of removed elements.\\n         */\\n        remove<T>(array: List<T>, predicate?: ListIteratee<T>): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.remove\\n         */\\n        remove(predicate?: ListIteratee<T>): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.remove\\n         */\\n        remove(predicate?: ListIteratee<T>): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Reverses `array` so that the first element becomes the last, the second\\n         * element becomes the second to last, and so on.\\n         *\\n         * **Note:** This method mutates `array` and is based on\\n         * [`Array#reverse`](https://mdn.io/Array/reverse).\\n         *\\n         * @category Array\\n         * @returns Returns `array`.\\n         * @example\\n         *\\n         * var array = [1, 2, 3];\\n         *\\n         * _.reverse(array);\\n         * // => [3, 2, 1]\\n         *\\n         * console.log(array);\\n         * // => [3, 2, 1]\\n         */\\n        reverse<TList extends List<any>>(array: TList): TList;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a slice of array from start up to, but not including, end.\\n         *\\n         * @param array The array to slice.\\n         * @param start The start position.\\n         * @param end The end position.\\n         * @return Returns the slice of array.\\n         */\\n        slice<T>(array: List<T> | null | undefined, start?: number, end?: number): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.slice\\n         */\\n        slice(start?: number, end?: number): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.slice\\n         */\\n        slice(start?: number, end?: number): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Uses a binary search to determine the lowest index at which `value` should\\n         * be inserted into `array` in order to maintain its sort order.\\n         *\\n         * @category Array\\n         * @param array The sorted array to inspect.\\n         * @param value The value to evaluate.\\n         * @returns Returns the index at which `value` should be inserted into `array`.\\n         * @example\\n         *\\n         * _.sortedIndex([30, 50], 40);\\n         * // => 1\\n         *\\n         * _.sortedIndex([4, 5], 4);\\n         * // => 0\\n         */\\n        sortedIndex<T>(array: List<T> | null | undefined, value: T): number;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.sortedIndex\\n         */\\n        sortedIndex(value: T): number;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.sortedIndex\\n         */\\n        sortedIndex(value: T): PrimitiveChain<number>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Uses a binary search to determine the lowest index at which `value` should\\n         * be inserted into `array` in order to maintain its sort order.\\n         *\\n         * @category Array\\n         * @param array The sorted array to inspect.\\n         * @param value The value to evaluate.\\n         * @returns Returns the index at which `value` should be inserted into `array`.\\n         * @example\\n         *\\n         * _.sortedIndex([30, 50], 40);\\n         * // => 1\\n         *\\n         * _.sortedIndex([4, 5], 4);\\n         * // => 0\\n         */\\n        sortedIndex<T>(array: List<T> | null | undefined, value: T): number;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.sortedIndex\\n         */\\n        sortedIndex(value: T): number;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.sortedIndex\\n         */\\n        sortedIndex(value: T): PrimitiveChain<number>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like `_.sortedIndex` except that it accepts `iteratee`\\n         * which is invoked for `value` and each element of `array` to compute their\\n         * sort ranking. The iteratee is invoked with one argument: (value).\\n         *\\n         * @category Array\\n         * @param array The sorted array to inspect.\\n         * @param value The value to evaluate.\\n         * @param [iteratee=_.identity] The iteratee invoked per element.\\n         * @returns Returns the index at which `value` should be inserted into `array`.\\n         * @example\\n         *\\n         * var dict = { 'thirty': 30, 'forty': 40, 'fifty': 50 };\\n         *\\n         * _.sortedIndexBy(['thirty', 'fifty'], 'forty', _.propertyOf(dict));\\n         * // => 1\\n         *\\n         * // using the `_.property` iteratee shorthand\\n         * _.sortedIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');\\n         * // => 0\\n         */\\n        sortedIndexBy<T>(array: List<T> | null | undefined, value: T, iteratee?: ValueIteratee<T>): number;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.sortedIndexBy\\n         */\\n        sortedIndexBy(value: T, iteratee?: ValueIteratee<T>): number;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.sortedIndexBy\\n         */\\n        sortedIndexBy(value: T, iteratee?: ValueIteratee<T>): PrimitiveChain<number>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like `_.indexOf` except that it performs a binary\\n         * search on a sorted `array`.\\n         *\\n         * @category Array\\n         * @param array The array to search.\\n         * @param value The value to search for.\\n         * @returns Returns the index of the matched value, else `-1`.\\n         * @example\\n         *\\n         * _.sortedIndexOf([1, 1, 2, 2], 2);\\n         * // => 2\\n         */\\n        sortedIndexOf<T>(array: List<T> | null | undefined, value: T): number;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.sortedIndexOf\\n         */\\n        sortedIndexOf(value: T): number;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.sortedIndexOf\\n         */\\n        sortedIndexOf(value: T): PrimitiveChain<number>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like `_.sortedIndex` except that it returns the highest\\n         * index at which `value` should be inserted into `array` in order to\\n         * maintain its sort order.\\n         *\\n         * @category Array\\n         * @param array The sorted array to inspect.\\n         * @param value The value to evaluate.\\n         * @returns Returns the index at which `value` should be inserted into `array`.\\n         * @example\\n         *\\n         * _.sortedLastIndex([4, 5], 4);\\n         * // => 1\\n         */\\n        sortedLastIndex<T>(array: List<T> | null | undefined, value: T): number;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.sortedLastIndex\\n         */\\n        sortedLastIndex(value: T): number;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.sortedLastIndex\\n         */\\n        sortedLastIndex(value: T): PrimitiveChain<number>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\\n         * which is invoked for `value` and each element of `array` to compute their\\n         * sort ranking. The iteratee is invoked with one argument: (value).\\n         *\\n         * @category Array\\n         * @param array The sorted array to inspect.\\n         * @param value The value to evaluate.\\n         * @param [iteratee=_.identity] The iteratee invoked per element.\\n         * @returns Returns the index at which `value` should be inserted into `array`.\\n         * @example\\n         *\\n         * // using the `_.property` iteratee shorthand\\n         * _.sortedLastIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');\\n         * // => 1\\n         */\\n        sortedLastIndexBy<T>(array: List<T> | null | undefined, value: T, iteratee: ValueIteratee<T>): number;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.sortedLastIndexBy\\n         */\\n        sortedLastIndexBy(value: T, iteratee: ValueIteratee<T>): number;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.sortedLastIndexBy\\n         */\\n        sortedLastIndexBy(value: T, iteratee: ValueIteratee<T>): PrimitiveChain<number>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like `_.lastIndexOf` except that it performs a binary\\n         * search on a sorted `array`.\\n         *\\n         * @category Array\\n         * @param array The array to search.\\n         * @param value The value to search for.\\n         * @returns Returns the index of the matched value, else `-1`.\\n         * @example\\n         *\\n         * _.sortedLastIndexOf([1, 1, 2, 2], 2);\\n         * // => 3\\n         */\\n        sortedLastIndexOf<T>(array: List<T> | null | undefined, value: T): number;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.sortedLastIndexOf\\n         */\\n        sortedLastIndexOf(value: T): number;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.sortedLastIndexOf\\n         */\\n        sortedLastIndexOf(value: T): PrimitiveChain<number>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like `_.uniq` except that it's designed and optimized\\n         * for sorted arrays.\\n         *\\n         * @category Array\\n         * @param array The array to inspect.\\n         * @returns Returns the new duplicate free array.\\n         * @example\\n         *\\n         * _.sortedUniq([1, 1, 2]);\\n         * // => [1, 2]\\n         */\\n        sortedUniq<T>(array: List<T> | null | undefined): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.sortedUniq\\n         */\\n        sortedUniq(): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.sortedUniq\\n         */\\n        sortedUniq(): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like `_.uniqBy` except that it's designed and optimized\\n         * for sorted arrays.\\n         *\\n         * @category Array\\n         * @param array The array to inspect.\\n         * @param [iteratee] The iteratee invoked per element.\\n         * @returns Returns the new duplicate free array.\\n         * @example\\n         *\\n         * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\\n         * // => [1.1, 2.3]\\n         */\\n        sortedUniqBy<T>(array: List<T> | null | undefined, iteratee: ValueIteratee<T>): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.sortedUniqBy\\n         */\\n        sortedUniqBy(iteratee: ValueIteratee<T>): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.sortedUniqBy\\n         */\\n        sortedUniqBy(iteratee: ValueIteratee<T>): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Gets all but the first element of array.\\n         *\\n         * @param array The array to query.\\n         * @return Returns the slice of array.\\n         */\\n        tail<T>(array: List<T> | null | undefined): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.tail\\n         */\\n        tail(): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.tail\\n         */\\n        tail(): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a slice of array with n elements taken from the beginning.\\n         *\\n         * @param array The array to query.\\n         * @param n The number of elements to take.\\n         * @return Returns the slice of array.\\n         */\\n        take<T>(array: List<T> | null | undefined, n?: number): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.take\\n         */\\n        take(n?: number): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.take\\n         */\\n        take(n?: number): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a slice of array with n elements taken from the end.\\n         *\\n         * @param array The array to query.\\n         * @param n The number of elements to take.\\n         * @return Returns the slice of array.\\n         */\\n        takeRight<T>(array: List<T> | null | undefined, n?: number): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.takeRight\\n         */\\n        takeRight(n?: number): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.takeRight\\n         */\\n        takeRight(n?: number): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a slice of array with elements taken from the end. Elements are taken until predicate returns\\n         * falsey. The predicate is invoked with three arguments: (value, index, array).\\n         *\\n         * @param array The array to query.\\n         * @param predicate The function invoked per iteration.\\n         * @return Returns the slice of array.\\n         */\\n        takeRightWhile<T>(array: List<T> | null | undefined, predicate?: ListIteratee<T>): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.takeRightWhile\\n         */\\n        takeRightWhile(predicate?: ListIteratee<T>): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.takeRightWhile\\n         */\\n        takeRightWhile(predicate?: ListIteratee<T>): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a slice of array with elements taken from the beginning. Elements are taken until predicate returns\\n         * falsey. The predicate is invoked with three arguments: (value, index, array).\\n         *\\n         * @param array The array to query.\\n         * @param predicate The function invoked per iteration.\\n         * @return Returns the slice of array.\\n         */\\n        takeWhile<T>(array: List<T> | null | undefined, predicate?: ListIteratee<T>): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.takeWhile\\n         */\\n        takeWhile(predicate?: ListIteratee<T>): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.takeWhile\\n         */\\n        takeWhile(predicate?: ListIteratee<T>): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates an array of unique values, in order, from all of the provided arrays using SameValueZero for\\n         * equality comparisons.\\n         *\\n         * @param arrays The arrays to inspect.\\n         * @return Returns the new array of combined values.\\n         */\\n        union<T>(...arrays: Array<List<T> | null | undefined>): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.union\\n         */\\n        union(...arrays: Array<List<T> | null | undefined>): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.union\\n         */\\n        union(...arrays: Array<List<T> | null | undefined>): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like `_.union` except that it accepts `iteratee` which is\\n         * invoked for each element of each `arrays` to generate the criterion by which\\n         * uniqueness is computed. The iteratee is invoked with one argument: (value).\\n         *\\n         * @param arrays The arrays to inspect.\\n         * @param iteratee The iteratee invoked per element.\\n         * @return Returns the new array of combined values.\\n         */\\n        unionBy<T>(arrays: List<T> | null | undefined, iteratee?: ValueIteratee<T>): T[];\\n        /**\\n         * @see _.unionBy\\n         */\\n        unionBy<T>(arrays1: List<T> | null | undefined, arrays2: List<T> | null | undefined, iteratee?: ValueIteratee<T>): T[];\\n        /**\\n         * @see _.unionBy\\n         */\\n        unionBy<T>(arrays1: List<T> | null | undefined, arrays2: List<T> | null | undefined, arrays3: List<T> | null | undefined, iteratee?: ValueIteratee<T>): T[];\\n        /**\\n         * @see _.unionBy\\n         */\\n        unionBy<T>(arrays1: List<T> | null | undefined, arrays2: List<T> | null | undefined, arrays3: List<T> | null | undefined, arrays4: List<T> | null | undefined, iteratee?: ValueIteratee<T>): T[];\\n        /**\\n         * @see _.unionBy\\n         */\\n        unionBy<T>(arrays1: List<T> | null | undefined, arrays2: List<T> | null | undefined, arrays3: List<T> | null | undefined, arrays4: List<T> | null | undefined, arrays5: List<T> | null | undefined, ...iteratee: Array<ValueIteratee<T> | List<T> | null | undefined>): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.unionBy\\n         */\\n        unionBy(arrays2: List<T> | null | undefined, iteratee?: ValueIteratee<T>): Collection<T>;\\n        /**\\n         * @see _.unionBy\\n         */\\n        unionBy(...iteratee: Array<ValueIteratee<T> | List<T> | null | undefined>): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.unionBy\\n         */\\n        unionBy(arrays2: List<T> | null | undefined, iteratee?: ValueIteratee<T>): CollectionChain<T>;\\n        /**\\n         * @see _.unionBy\\n         */\\n        unionBy(...iteratee: Array<ValueIteratee<T> | List<T> | null | undefined>): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like `_.union` except that it accepts `comparator` which\\n         * is invoked to compare elements of `arrays`. The comparator is invoked\\n         * with two arguments: (arrVal, othVal).\\n         *\\n         * @category Array\\n         * @param [arrays] The arrays to inspect.\\n         * @param [comparator] The comparator invoked per element.\\n         * @returns Returns the new array of combined values.\\n         * @example\\n         *\\n         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\\n         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\\n         *\\n         * _.unionWith(objects, others, _.isEqual);\\n         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\\n         */\\n        unionWith<T>(arrays: List<T> | null | undefined, comparator?: Comparator<T>): T[];\\n        /**\\n         * @see _.unionWith\\n         */\\n        unionWith<T>(arrays: List<T> | null | undefined, arrays2: List<T> | null | undefined, comparator?: Comparator<T>): T[];\\n        /**\\n         * @see _.unionWith\\n         */\\n        unionWith<T>(arrays: List<T> | null | undefined, arrays2: List<T> | null | undefined, arrays3: List<T> | null | undefined, ...comparator: Array<Comparator<T> | List<T> | null | undefined>): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.unionWith\\n         */\\n        unionWith(arrays2: List<T> | null | undefined, comparator?: Comparator<T>): Collection<T>;\\n        /**\\n         * @see _.unionWith\\n         */\\n        unionWith(...comparator: Array<Comparator<T> | List<T> | null | undefined>): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.unionWith\\n         */\\n        unionWith(arrays2: List<T> | null | undefined, comparator?: Comparator<T>): CollectionChain<T>;\\n        /**\\n         * @see _.unionWith\\n         */\\n        unionWith(...comparator: Array<Comparator<T> | List<T> | null | undefined>): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a duplicate-free version of an array, using\\n         * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\\n         * for equality comparisons, in which only the first occurrence of each element\\n         * is kept.\\n         *\\n         * @category Array\\n         * @param array The array to inspect.\\n         * @returns Returns the new duplicate free array.\\n         * @example\\n         *\\n         * _.uniq([2, 1, 2]);\\n         * // => [2, 1]\\n         */\\n        uniq<T>(array: List<T> | null | undefined): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.uniq\\n         */\\n        uniq(): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.uniq\\n         */\\n        uniq(): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like `_.uniq` except that it accepts `iteratee` which is\\n         * invoked for each element in `array` to generate the criterion by which\\n         * uniqueness is computed. The iteratee is invoked with one argument: (value).\\n         *\\n         * @category Array\\n         * @param array The array to inspect.\\n         * @param [iteratee=_.identity] The iteratee invoked per element.\\n         * @returns Returns the new duplicate free array.\\n         * @example\\n         *\\n         * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\\n         * // => [2.1, 1.2]\\n         *\\n         * // using the `_.property` iteratee shorthand\\n         * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\\n         * // => [{ 'x': 1 }, { 'x': 2 }]\\n         */\\n        uniqBy<T>(array: List<T> | null | undefined, iteratee: ValueIteratee<T>): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.uniqBy\\n         */\\n        uniqBy(iteratee: ValueIteratee<T>): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.uniqBy\\n         */\\n        uniqBy(iteratee: ValueIteratee<T>): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like `_.uniq` except that it accepts `comparator` which\\n         * is invoked to compare elements of `array`. The comparator is invoked with\\n         * two arguments: (arrVal, othVal).\\n         *\\n         * @category Array\\n         * @param array The array to inspect.\\n         * @param [comparator] The comparator invoked per element.\\n         * @returns Returns the new duplicate free array.\\n         * @example\\n         *\\n         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 },  { 'x': 1, 'y': 2 }];\\n         *\\n         * _.uniqWith(objects, _.isEqual);\\n         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\\n         */\\n        uniqWith<T>(array: List<T> | null | undefined, comparator?: Comparator<T>): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.uniqWith\\n         */\\n        uniqWith(comparator?: Comparator<T>): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.uniqWith\\n         */\\n        uniqWith(comparator?: Comparator<T>): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like _.zip except that it accepts an array of grouped elements and creates an array\\n         * regrouping the elements to their pre-zip configuration.\\n         *\\n         * @param array The array of grouped elements to process.\\n         * @return Returns the new array of regrouped elements.\\n         */\\n        unzip<T>(array: T[][] | List<List<T>> | null | undefined): T[][];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.unzip\\n         */\\n        unzip(): T extends List<infer U> ? Collection<U[]> : unknown;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.unzip\\n         */\\n        unzip(): T extends List<infer U> ? CollectionChain<U[]> : unknown;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like _.unzip except that it accepts an iteratee to specify how regrouped values should be\\n         * combined. The iteratee is invoked with four arguments: (accumulator, value, index, group).\\n         *\\n         * @param array The array of grouped elements to process.\\n         * @param iteratee The function to combine regrouped values.\\n         * @return Returns the new array of regrouped elements.\\n         */\\n        unzipWith<T, TResult>(array: List<List<T>> | null | undefined, iteratee: (...values: T[]) => TResult): TResult[];\\n        /**\\n         * @see _.unzipWith\\n         */\\n        unzipWith<T>(array: List<List<T>> | null | undefined): T[][];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.unzipWith\\n         */\\n        unzipWith<TResult>(iteratee: (...values: Array<T extends List<infer U> ? U : unknown>) => TResult): Collection<TResult>;\\n        /**\\n         * @see _.unzipWith\\n         */\\n        unzipWith(): T extends List<infer U> ? Collection<U[]> : unknown;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.unzipWith\\n         */\\n        unzipWith<TResult>(iteratee: (...values: Array<T extends List<infer U> ? U : unknown>) => TResult): CollectionChain<TResult>;\\n        /**\\n         * @see _.unzipWith\\n         */\\n        unzipWith(): T extends List<infer U> ? CollectionChain<U[]> : unknown;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates an array excluding all provided values using SameValueZero for equality comparisons.\\n         *\\n         * @param array The array to filter.\\n         * @param values The values to exclude.\\n         * @return Returns the new array of filtered values.\\n         */\\n        without<T>(array: List<T> | null | undefined, ...values: T[]): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.without\\n         */\\n        without(...values: T[]): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.without\\n         */\\n        without(...values: T[]): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates an array of unique values that is the symmetric difference of the provided arrays.\\n         *\\n         * @param arrays The arrays to inspect.\\n         * @return Returns the new array of values.\\n         */\\n        xor<T>(...arrays: Array<List<T> | null | undefined>): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.xor\\n         */\\n        xor(...arrays: Array<List<T> | null | undefined>): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.xor\\n         */\\n        xor(...arrays: Array<List<T> | null | undefined>): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like `_.xor` except that it accepts `iteratee` which is\\n         * invoked for each element of each `arrays` to generate the criterion by which\\n         * uniqueness is computed. The iteratee is invoked with one argument: (value).\\n         *\\n         * @category Array\\n         * @param [arrays] The arrays to inspect.\\n         * @param [iteratee=_.identity] The iteratee invoked per element.\\n         * @returns Returns the new array of values.\\n         * @example\\n         *\\n         * _.xorBy([2.1, 1.2], [4.3, 2.4], Math.floor);\\n         * // => [1.2, 4.3]\\n         *\\n         * // using the `_.property` iteratee shorthand\\n         * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\\n         * // => [{ 'x': 2 }]\\n         */\\n        xorBy<T>(arrays: List<T> | null | undefined, iteratee?: ValueIteratee<T>): T[];\\n        /**\\n         * @see _.xorBy\\n         */\\n        xorBy<T>(arrays: List<T> | null | undefined, arrays2: List<T> | null | undefined, iteratee?: ValueIteratee<T>): T[];\\n        /**\\n         * @see _.xorBy\\n         */\\n        xorBy<T>(arrays: List<T> | null | undefined, arrays2: List<T> | null | undefined, arrays3: List<T> | null | undefined, ...iteratee: Array<ValueIteratee<T> | List<T> | null | undefined>): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.xorBy\\n         */\\n        xorBy(arrays2: List<T> | null | undefined, iteratee?: ValueIteratee<T>): Collection<T>;\\n        /**\\n         * @see _.xorBy\\n         */\\n        xorBy(...iteratee: Array<ValueIteratee<T> | List<T> | null | undefined>): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.xorBy\\n         */\\n        xorBy(arrays2: List<T> | null | undefined, iteratee?: ValueIteratee<T>): CollectionChain<T>;\\n        /**\\n         * @see _.xorBy\\n         */\\n        xorBy(...iteratee: Array<ValueIteratee<T> | List<T> | null | undefined>): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like `_.xor` except that it accepts `comparator` which is\\n         * invoked to compare elements of `arrays`. The comparator is invoked with\\n         * two arguments: (arrVal, othVal).\\n         *\\n         * @category Array\\n         * @param [arrays] The arrays to inspect.\\n         * @param [comparator] The comparator invoked per element.\\n         * @returns Returns the new array of values.\\n         * @example\\n         *\\n         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\\n         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\\n         *\\n         * _.xorWith(objects, others, _.isEqual);\\n         * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\\n         */\\n        xorWith<T>(arrays: List<T> | null | undefined, comparator?: Comparator<T>): T[];\\n        /**\\n         * @see _.xorWith\\n         */\\n        xorWith<T>(arrays: List<T> | null | undefined, arrays2: List<T> | null | undefined, comparator?: Comparator<T>): T[];\\n        /**\\n         * @see _.xorWith\\n         */\\n        xorWith<T>(arrays: List<T> | null | undefined, arrays2: List<T> | null | undefined, arrays3: List<T> | null | undefined, ...comparator: Array<Comparator<T> | List<T> | null | undefined>): T[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.xorWith\\n         */\\n        xorWith(arrays2: List<T> | null | undefined, comparator?: Comparator<T>): Collection<T>;\\n        /**\\n         * @see _.xorWith\\n         */\\n        xorWith(...comparator: Array<Comparator<T> | List<T> | null | undefined>): Collection<T>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.xorWith\\n         */\\n        xorWith(arrays2: List<T> | null | undefined, comparator?: Comparator<T>): CollectionChain<T>;\\n        /**\\n         * @see _.xorWith\\n         */\\n        xorWith(...comparator: Array<Comparator<T> | List<T> | null | undefined>): CollectionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates an array of grouped elements, the first of which contains the first elements of the given arrays,\\n         * the second of which contains the second elements of the given arrays, and so on.\\n         *\\n         * @param arrays The arrays to process.\\n         * @return Returns the new array of grouped elements.\\n         */\\n        zip<T1, T2>(arrays1: List<T1>, arrays2: List<T2>): Array<[T1 | undefined, T2 | undefined]>;\\n        /**\\n         * @see _.zip\\n         */\\n        zip<T1, T2, T3>(arrays1: List<T1>, arrays2: List<T2>, arrays3: List<T3>): Array<[T1 | undefined, T2 | undefined, T3 | undefined]>;\\n        /**\\n         * @see _.zip\\n         */\\n        zip<T1, T2, T3, T4>(arrays1: List<T1>, arrays2: List<T2>, arrays3: List<T3>, arrays4: List<T4>): Array<[T1 | undefined, T2 | undefined, T3 | undefined, T4 | undefined]>;\\n        /**\\n         * @see _.zip\\n         */\\n        zip<T1, T2, T3, T4, T5>(arrays1: List<T1>, arrays2: List<T2>, arrays3: List<T3>, arrays4: List<T4>, arrays5: List<T5>): Array<[T1 | undefined, T2 | undefined, T3 | undefined, T4 | undefined, T5 | undefined]>;\\n        /**\\n         * @see _.zip\\n         */\\n        zip<T>(...arrays: Array<List<T> | null | undefined>): Array<Array<T | undefined>>;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.zip\\n         */\\n        zip<T2>(arrays2: List<T2>): Collection<[T | undefined, T2 | undefined]>;\\n        /**\\n         * @see _.zip\\n         */\\n        zip(...arrays: Array<List<T> | null | undefined>): Collection<Array<T | undefined>>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.zip\\n         */\\n        zip<T2>(arrays2: List<T2>): CollectionChain<[T | undefined, T2 | undefined]>;\\n        /**\\n         * @see _.zip\\n         */\\n        zip(...arrays: Array<List<T> | null | undefined>): CollectionChain<Array<T | undefined>>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like _.fromPairs except that it accepts two arrays, one of property\\n         * identifiers and one of corresponding values.\\n         *\\n         * @param props The property names.\\n         * @param values The property values.\\n         * @return Returns the new object.\\n         */\\n        zipObject<T>(props: List<PropertyName>, values: List<T>): Dictionary<T>;\\n        /**\\n         * @see _.zipObject\\n         */\\n        zipObject(props?: List<PropertyName>): Dictionary<undefined>;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.zipObject\\n         */\\n        zipObject<U>(values: List<U>): Object<Dictionary<U>>;\\n        /**\\n         * @see _.zipObject\\n         */\\n        zipObject(): Object<Dictionary<undefined>>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.zipObject\\n         */\\n        zipObject<U>(values: List<U>): ObjectChain<Dictionary<U>>;\\n        /**\\n         * @see _.zipObject\\n         */\\n        zipObject(): ObjectChain<Dictionary<undefined>>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like _.zipObject except that it supports property paths.\\n         *\\n         * @param paths The property names.\\n         * @param values The property values.\\n         * @return Returns the new object.\\n         */\\n        zipObjectDeep(paths?: List<PropertyPath>, values?: List<any>): object;\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.zipObjectDeep\\n         */\\n        zipObjectDeep(values?: List<any>): Object<object>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.zipObjectDeep\\n         */\\n        zipObjectDeep(values?: List<any>): ObjectChain<object>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * This method is like _.zip except that it accepts an iteratee to specify how grouped values should be\\n         * combined. The iteratee is invoked with four arguments: (accumulator, value, index,\\n         * group).\\n         * @param arrays The arrays to process.\\n         * @param iteratee The function to combine grouped values.\\n         * @return Returns the new array of grouped elements.\\n         */\\n        zipWith<T, TResult>(arrays: List<T>, iteratee: (value1: T) => TResult): TResult[];\\n        /**\\n         * @see _.zipWith\\n         */\\n        zipWith<T1, T2, TResult>(arrays1: List<T1>, arrays2: List<T2>, iteratee: (value1: T1, value2: T2) => TResult): TResult[];\\n        /**\\n         * @see _.zipWith\\n         */\\n        zipWith<T1, T2, T3, TResult>(arrays1: List<T1>, arrays2: List<T2>, arrays3: List<T3>, iteratee: (value1: T1, value2: T2, value3: T3) => TResult): TResult[];\\n        /**\\n         * @see _.zipWith\\n         */\\n        zipWith<T1, T2, T3, T4, TResult>(arrays1: List<T1>, arrays2: List<T2>, arrays3: List<T3>, arrays4: List<T4>, iteratee: (value1: T1, value2: T2, value3: T3, value4: T4) => TResult): TResult[];\\n        /**\\n         * @see _.zipWith\\n         */\\n        zipWith<T1, T2, T3, T4, T5, TResult>(arrays1: List<T1>, arrays2: List<T2>, arrays3: List<T3>, arrays4: List<T4>, arrays5: List<T5>, iteratee: (value1: T1, value2: T2, value3: T3, value4: T4, value5: T5) => TResult): TResult[];\\n        /**\\n         * @see _.zipWith\\n         */\\n        zipWith<T, TResult>(...iteratee: Array<((...group: T[]) => TResult) | List<T> | null | undefined>): TResult[];\\n    }\\n    interface Collection<T> {\\n        /**\\n         * @see _.zipWith\\n         */\\n        zipWith<T2, TResult>(arrays2: List<T2>, iteratee: (value1: T, value2: T2) => TResult): Collection<TResult>;\\n        /**\\n         * @see _.zipWith\\n         */\\n        zipWith<T2, T3, TResult>(arrays2: List<T2>, arrays3: List<T3>, iteratee: (value1: T, value2: T2, value3: T3) => TResult): Collection<TResult>;\\n        /**\\n         * @see _.zipWith\\n         */\\n        zipWith<TResult>(...iteratee: Array<((...group: T[]) => TResult) | List<T> | null | undefined>): Collection<TResult>;\\n    }\\n    interface CollectionChain<T> {\\n        /**\\n         * @see _.zipWith\\n         */\\n        zipWith<T2, TResult>(arrays2: List<T2>, iteratee: (value1: T, value2: T2) => TResult): CollectionChain<TResult>;\\n        /**\\n         * @see _.zipWith\\n         */\\n        zipWith<T2, T3, TResult>(arrays2: List<T2>, arrays3: List<T3>, iteratee: (value1: T, value2: T2, value3: T3) => TResult): CollectionChain<TResult>;\\n        /**\\n         * @see _.zipWith\\n         */\\n        zipWith<TResult>(...iteratee: Array<((...group: T[]) => TResult) | List<T> | null | undefined>): CollectionChain<TResult>;\\n    }\\n}\\n\";"],"names":[],"sourceRoot":""}