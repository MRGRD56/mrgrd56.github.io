{"version":3,"file":"static/js/4271.cbfd8aef.chunk.js","mappings":"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","sources":["../node_modules/@mui/icons-material/node_modules/@babel/runtime/helpers/interopRequireDefault.js","../node_modules/@mui/icons-material/Css.js","../node_modules/@mui/icons-material/Html.js","../node_modules/@mui/icons-material/Javascript.js","../node_modules/@mui/icons-material/esm/VerticalSplit.js","../node_modules/@mui/icons-material/esm/ViewHeadline.js","../node_modules/@mui/icons-material/utils/createSvgIcon.js","../node_modules/@mui/material/utils/createChainedFunction.js","../node_modules/@mui/utils/esm/createChainedFunction.js","../node_modules/@mui/material/utils/debounce.js","../node_modules/@mui/utils/esm/debounce.js","../node_modules/@mui/material/utils/deprecatedPropType.js","../node_modules/@mui/utils/esm/deprecatedPropType.js","../node_modules/@mui/material/utils/isMuiElement.js","../node_modules/@mui/utils/esm/isMuiElement.js","../node_modules/@mui/utils/esm/ownerDocument.js","../node_modules/@mui/material/utils/ownerDocument.js","../node_modules/@mui/material/utils/ownerWindow.js","../node_modules/@mui/utils/esm/ownerWindow.js","../node_modules/@mui/material/utils/requirePropFactory.js","../node_modules/@mui/utils/esm/requirePropFactory.js","../node_modules/@mui/utils/esm/setRef.js","../node_modules/@mui/material/utils/setRef.js","../node_modules/@mui/utils/esm/useEnhancedEffect.js","../node_modules/@mui/material/utils/useEnhancedEffect.js","../node_modules/@mui/utils/esm/useId.js","../node_modules/@mui/material/utils/useId.js","../node_modules/@mui/material/utils/unsupportedProp.js","../node_modules/@mui/utils/esm/unsupportedProp.js","../node_modules/@mui/material/utils/useControlled.js","../node_modules/@mui/utils/esm/useControlled.js","../node_modules/@mui/material/utils/useEventCallback.js","../node_modules/@mui/utils/esm/useEventCallback.js","../node_modules/@mui/material/utils/useForkRef.js","../node_modules/@mui/utils/esm/useIsFocusVisible.js","../node_modules/@mui/utils/esm/useForkRef.js","../node_modules/@mui/material/utils/useIsFocusVisible.js","../node_modules/@mui/material/utils/index.js","../node_modules/antd/es/_util/responsiveObserve.js","../node_modules/antd/es/grid/row.js","../node_modules/antd/es/row/index.js","../node_modules/emmet-monaco-es/dist/emmet-monaco.esm.js","../node_modules/uuid/dist/esm-browser/rng.js","../node_modules/uuid/dist/esm-browser/regex.js","../node_modules/uuid/dist/esm-browser/stringify.js","../node_modules/uuid/dist/esm-browser/validate.js","../node_modules/uuid/dist/esm-browser/v4.js"],"sourcesContent":["function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nmodule.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\n\nvar _jsxRuntime = require(\"react/jsx-runtime\");\n\nvar _default = (0, _createSvgIcon.default)( /*#__PURE__*/(0, _jsxRuntime.jsx)(\"path\", {\n  d: \"M9.5 14v-1H11v.5h2v-1h-2.5c-.55 0-1-.45-1-1V10c0-.55.45-1 1-1h3c.55 0 1 .45 1 1v1H13v-.5h-2v1h2.5c.55 0 1 .45 1 1V14c0 .55-.45 1-1 1h-3c-.55 0-1-.45-1-1zm7.5 1h3c.55 0 1-.45 1-1v-1.5c0-.55-.45-1-1-1h-2.5v-1h2v.5H21v-1c0-.55-.45-1-1-1h-3c-.55 0-1 .45-1 1v1.5c0 .55.45 1 1 1h2.5v1h-2V13H16v1c0 .55.45 1 1 1zm-9-5c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-1H6.5v.5h-2v-3h2v.5H8v-1z\"\n}), 'Css');\n\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\n\nvar _jsxRuntime = require(\"react/jsx-runtime\");\n\nvar _default = (0, _createSvgIcon.default)( /*#__PURE__*/(0, _jsxRuntime.jsx)(\"path\", {\n  d: \"M3.5 9H5v6H3.5v-2.5h-2V15H0V9h1.5v2h2V9zm14 0H13c-.55 0-1 .45-1 1v5h1.5v-4.5h1V14H16v-3.51h1V15h1.5v-5c0-.55-.45-1-1-1zM11 9H6v1.5h1.75V15h1.5v-4.5H11V9zm13 6v-1.5h-2.5V9H20v6h4z\"\n}), 'Html');\n\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\n\nvar _jsxRuntime = require(\"react/jsx-runtime\");\n\nvar _default = (0, _createSvgIcon.default)( /*#__PURE__*/(0, _jsxRuntime.jsx)(\"path\", {\n  d: \"M12 14v-1h1.5v.5h2v-1H13c-.55 0-1-.45-1-1V10c0-.55.45-1 1-1h3c.55 0 1 .45 1 1v1h-1.5v-.5h-2v1H16c.55 0 1 .45 1 1V14c0 .55-.45 1-1 1h-3c-.55 0-1-.45-1-1zM9 9v4.5H7.5v-1H6v1c0 .83.67 1.5 1.5 1.5H9c.83 0 1.5-.67 1.5-1.5V9H9z\"\n}), 'Javascript');\n\nexports.default = _default;","import createSvgIcon from './utils/createSvgIcon';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"M3 15h8v-2H3v2zm0 4h8v-2H3v2zm0-8h8V9H3v2zm0-6v2h8V5H3zm10 0h8v14h-8V5z\"\n}), 'VerticalSplit');","import createSvgIcon from './utils/createSvgIcon';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"M4 15h16v-2H4v2zm0 4h16v-2H4v2zm0-8h16V9H4v2zm0-6v2h16V5H4z\"\n}), 'ViewHeadline');","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function () {\n    return _utils.createSvgIcon;\n  }\n});\n\nvar _utils = require(\"@mui/material/utils\");","import { unstable_createChainedFunction as createChainedFunction } from '@mui/utils';\nexport default createChainedFunction;","/**\n * Safe chained function.\n *\n * Will only create a new function if needed,\n * otherwise will pass back existing functions or null.\n */\nexport default function createChainedFunction(...funcs) {\n  return funcs.reduce((acc, func) => {\n    if (func == null) {\n      return acc;\n    }\n\n    return function chainedFunction(...args) {\n      acc.apply(this, args);\n      func.apply(this, args);\n    };\n  }, () => {});\n}","import { unstable_debounce as debounce } from '@mui/utils';\nexport default debounce;","// Corresponds to 10 frames at 60 Hz.\n// A few bytes payload overhead when lodash/debounce is ~3 kB and debounce ~300 B.\nexport default function debounce(func, wait = 166) {\n  let timeout;\n\n  function debounced(...args) {\n    const later = () => {\n      func.apply(this, args);\n    };\n\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  }\n\n  debounced.clear = () => {\n    clearTimeout(timeout);\n  };\n\n  return debounced;\n}","import { unstable_deprecatedPropType as deprecatedPropType } from '@mui/utils';\nexport default deprecatedPropType;","export default function deprecatedPropType(validator, reason) {\n  if (process.env.NODE_ENV === 'production') {\n    return () => null;\n  }\n\n  return (props, propName, componentName, location, propFullName) => {\n    const componentNameSafe = componentName || '<<anonymous>>';\n    const propFullNameSafe = propFullName || propName;\n\n    if (typeof props[propName] !== 'undefined') {\n      return new Error(`The ${location} \\`${propFullNameSafe}\\` of ` + `\\`${componentNameSafe}\\` is deprecated. ${reason}`);\n    }\n\n    return null;\n  };\n}","import { unstable_isMuiElement as isMuiElement } from '@mui/utils';\nexport default isMuiElement;","import * as React from 'react';\nexport default function isMuiElement(element, muiNames) {\n  return /*#__PURE__*/React.isValidElement(element) && muiNames.indexOf(element.type.muiName) !== -1;\n}","export default function ownerDocument(node) {\n  return node && node.ownerDocument || document;\n}","import { unstable_ownerDocument as ownerDocument } from '@mui/utils';\nexport default ownerDocument;","import { unstable_ownerWindow as ownerWindow } from '@mui/utils';\nexport default ownerWindow;","import ownerDocument from './ownerDocument';\nexport default function ownerWindow(node) {\n  const doc = ownerDocument(node);\n  return doc.defaultView || window;\n}","import { unstable_requirePropFactory as requirePropFactory } from '@mui/utils';\nexport default requirePropFactory;","import _extends from \"@babel/runtime/helpers/esm/extends\";\nexport default function requirePropFactory(componentNameInError, Component) {\n  if (process.env.NODE_ENV === 'production') {\n    return () => null;\n  } // eslint-disable-next-line react/forbid-foreign-prop-types\n\n\n  const prevPropTypes = Component ? _extends({}, Component.propTypes) : null;\n\n  const requireProp = requiredProp => (props, propName, componentName, location, propFullName, ...args) => {\n    const propFullNameSafe = propFullName || propName;\n    const defaultTypeChecker = prevPropTypes == null ? void 0 : prevPropTypes[propFullNameSafe];\n\n    if (defaultTypeChecker) {\n      const typeCheckerResult = defaultTypeChecker(props, propName, componentName, location, propFullName, ...args);\n\n      if (typeCheckerResult) {\n        return typeCheckerResult;\n      }\n    }\n\n    if (typeof props[propName] !== 'undefined' && !props[requiredProp]) {\n      return new Error(`The prop \\`${propFullNameSafe}\\` of ` + `\\`${componentNameInError}\\` can only be used together with the \\`${requiredProp}\\` prop.`);\n    }\n\n    return null;\n  };\n\n  return requireProp;\n}","/**\n * TODO v5: consider making it private\n *\n * passes {value} to {ref}\n *\n * WARNING: Be sure to only call this inside a callback that is passed as a ref.\n * Otherwise, make sure to cleanup the previous {ref} if it changes. See\n * https://github.com/mui/material-ui/issues/13539\n *\n * Useful if you want to expose the ref of an inner component to the public API\n * while still using it inside the component.\n * @param ref A ref callback or ref object. If anything falsy, this is a no-op.\n */\nexport default function setRef(ref, value) {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref) {\n    ref.current = value;\n  }\n}","import { unstable_setRef as setRef } from '@mui/utils';\nexport default setRef;","import * as React from 'react';\nconst useEnhancedEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\nexport default useEnhancedEffect;","import { unstable_useEnhancedEffect as useEnhancedEffect } from '@mui/utils';\nexport default useEnhancedEffect;","import * as React from 'react';\nlet globalId = 0;\n\nfunction useGlobalId(idOverride) {\n  const [defaultId, setDefaultId] = React.useState(idOverride);\n  const id = idOverride || defaultId;\n  React.useEffect(() => {\n    if (defaultId == null) {\n      // Fallback to this default id when possible.\n      // Use the incrementing value for client-side rendering only.\n      // We can't use it server-side.\n      // If you want to use random values please consider the Birthday Problem: https://en.wikipedia.org/wiki/Birthday_problem\n      globalId += 1;\n      setDefaultId(`mui-${globalId}`);\n    }\n  }, [defaultId]);\n  return id;\n} // eslint-disable-next-line no-useless-concat -- Workaround for https://github.com/webpack/webpack/issues/14814\n\n\nconst maybeReactUseId = React['useId' + ''];\n/**\n *\n * @example <div id={useId()} />\n * @param idOverride\n * @returns {string}\n */\n\nexport default function useId(idOverride) {\n  if (maybeReactUseId !== undefined) {\n    const reactId = maybeReactUseId();\n    return idOverride != null ? idOverride : reactId;\n  } // eslint-disable-next-line react-hooks/rules-of-hooks -- `React.useId` is invariant at runtime.\n\n\n  return useGlobalId(idOverride);\n}","import { unstable_useId as useId } from '@mui/utils';\nexport default useId;","import { unstable_unsupportedProp as unsupportedProp } from '@mui/utils';\nexport default unsupportedProp;","export default function unsupportedProp(props, propName, componentName, location, propFullName) {\n  if (process.env.NODE_ENV === 'production') {\n    return null;\n  }\n\n  const propFullNameSafe = propFullName || propName;\n\n  if (typeof props[propName] !== 'undefined') {\n    return new Error(`The prop \\`${propFullNameSafe}\\` is not supported. Please remove it.`);\n  }\n\n  return null;\n}","import { unstable_useControlled as useControlled } from '@mui/utils';\nexport default useControlled;","/* eslint-disable react-hooks/rules-of-hooks, react-hooks/exhaustive-deps */\nimport * as React from 'react';\nexport default function useControlled({\n  controlled,\n  default: defaultProp,\n  name,\n  state = 'value'\n}) {\n  // isControlled is ignored in the hook dependency lists as it should never change.\n  const {\n    current: isControlled\n  } = React.useRef(controlled !== undefined);\n  const [valueState, setValue] = React.useState(defaultProp);\n  const value = isControlled ? controlled : valueState;\n\n  if (process.env.NODE_ENV !== 'production') {\n    React.useEffect(() => {\n      if (isControlled !== (controlled !== undefined)) {\n        console.error([`MUI: A component is changing the ${isControlled ? '' : 'un'}controlled ${state} state of ${name} to be ${isControlled ? 'un' : ''}controlled.`, 'Elements should not switch from uncontrolled to controlled (or vice versa).', `Decide between using a controlled or uncontrolled ${name} ` + 'element for the lifetime of the component.', \"The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.\", 'More info: https://fb.me/react-controlled-components'].join('\\n'));\n      }\n    }, [state, name, controlled]);\n    const {\n      current: defaultValue\n    } = React.useRef(defaultProp);\n    React.useEffect(() => {\n      if (!isControlled && defaultValue !== defaultProp) {\n        console.error([`MUI: A component is changing the default ${state} state of an uncontrolled ${name} after being initialized. ` + `To suppress this warning opt to use a controlled ${name}.`].join('\\n'));\n      }\n    }, [JSON.stringify(defaultProp)]);\n  }\n\n  const setValueIfUncontrolled = React.useCallback(newValue => {\n    if (!isControlled) {\n      setValue(newValue);\n    }\n  }, []);\n  return [value, setValueIfUncontrolled];\n}","import { unstable_useEventCallback as useEventCallback } from '@mui/utils';\nexport default useEventCallback;","import * as React from 'react';\nimport useEnhancedEffect from './useEnhancedEffect';\n/**\n * https://github.com/facebook/react/issues/14099#issuecomment-440013892\n */\n\nexport default function useEventCallback(fn) {\n  const ref = React.useRef(fn);\n  useEnhancedEffect(() => {\n    ref.current = fn;\n  });\n  return React.useCallback((...args) => // @ts-expect-error hide `this`\n  // tslint:disable-next-line:ban-comma-operator\n  (0, ref.current)(...args), []);\n}","import { unstable_useForkRef as useForkRef } from '@mui/utils';\nexport default useForkRef;","// based on https://github.com/WICG/focus-visible/blob/v4.1.5/src/focus-visible.js\nimport * as React from 'react';\nlet hadKeyboardEvent = true;\nlet hadFocusVisibleRecently = false;\nlet hadFocusVisibleRecentlyTimeout;\nconst inputTypesWhitelist = {\n  text: true,\n  search: true,\n  url: true,\n  tel: true,\n  email: true,\n  password: true,\n  number: true,\n  date: true,\n  month: true,\n  week: true,\n  time: true,\n  datetime: true,\n  'datetime-local': true\n};\n/**\n * Computes whether the given element should automatically trigger the\n * `focus-visible` class being added, i.e. whether it should always match\n * `:focus-visible` when focused.\n * @param {Element} node\n * @returns {boolean}\n */\n\nfunction focusTriggersKeyboardModality(node) {\n  const {\n    type,\n    tagName\n  } = node;\n\n  if (tagName === 'INPUT' && inputTypesWhitelist[type] && !node.readOnly) {\n    return true;\n  }\n\n  if (tagName === 'TEXTAREA' && !node.readOnly) {\n    return true;\n  }\n\n  if (node.isContentEditable) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Keep track of our keyboard modality state with `hadKeyboardEvent`.\n * If the most recent user interaction was via the keyboard;\n * and the key press did not include a meta, alt/option, or control key;\n * then the modality is keyboard. Otherwise, the modality is not keyboard.\n * @param {KeyboardEvent} event\n */\n\n\nfunction handleKeyDown(event) {\n  if (event.metaKey || event.altKey || event.ctrlKey) {\n    return;\n  }\n\n  hadKeyboardEvent = true;\n}\n/**\n * If at any point a user clicks with a pointing device, ensure that we change\n * the modality away from keyboard.\n * This avoids the situation where a user presses a key on an already focused\n * element, and then clicks on a different element, focusing it with a\n * pointing device, while we still think we're in keyboard modality.\n */\n\n\nfunction handlePointerDown() {\n  hadKeyboardEvent = false;\n}\n\nfunction handleVisibilityChange() {\n  if (this.visibilityState === 'hidden') {\n    // If the tab becomes active again, the browser will handle calling focus\n    // on the element (Safari actually calls it twice).\n    // If this tab change caused a blur on an element with focus-visible,\n    // re-apply the class when the user switches back to the tab.\n    if (hadFocusVisibleRecently) {\n      hadKeyboardEvent = true;\n    }\n  }\n}\n\nfunction prepare(doc) {\n  doc.addEventListener('keydown', handleKeyDown, true);\n  doc.addEventListener('mousedown', handlePointerDown, true);\n  doc.addEventListener('pointerdown', handlePointerDown, true);\n  doc.addEventListener('touchstart', handlePointerDown, true);\n  doc.addEventListener('visibilitychange', handleVisibilityChange, true);\n}\n\nexport function teardown(doc) {\n  doc.removeEventListener('keydown', handleKeyDown, true);\n  doc.removeEventListener('mousedown', handlePointerDown, true);\n  doc.removeEventListener('pointerdown', handlePointerDown, true);\n  doc.removeEventListener('touchstart', handlePointerDown, true);\n  doc.removeEventListener('visibilitychange', handleVisibilityChange, true);\n}\n\nfunction isFocusVisible(event) {\n  const {\n    target\n  } = event;\n\n  try {\n    return target.matches(':focus-visible');\n  } catch (error) {// Browsers not implementing :focus-visible will throw a SyntaxError.\n    // We use our own heuristic for those browsers.\n    // Rethrow might be better if it's not the expected error but do we really\n    // want to crash if focus-visible malfunctioned?\n  } // No need for validFocusTarget check. The user does that by attaching it to\n  // focusable events only.\n\n\n  return hadKeyboardEvent || focusTriggersKeyboardModality(target);\n}\n\nexport default function useIsFocusVisible() {\n  const ref = React.useCallback(node => {\n    if (node != null) {\n      prepare(node.ownerDocument);\n    }\n  }, []);\n  const isFocusVisibleRef = React.useRef(false);\n  /**\n   * Should be called if a blur event is fired\n   */\n\n  function handleBlurVisible() {\n    // checking against potential state variable does not suffice if we focus and blur synchronously.\n    // React wouldn't have time to trigger a re-render so `focusVisible` would be stale.\n    // Ideally we would adjust `isFocusVisible(event)` to look at `relatedTarget` for blur events.\n    // This doesn't work in IE11 due to https://github.com/facebook/react/issues/3751\n    // TODO: check again if React releases their internal changes to focus event handling (https://github.com/facebook/react/pull/19186).\n    if (isFocusVisibleRef.current) {\n      // To detect a tab/window switch, we look for a blur event followed\n      // rapidly by a visibility change.\n      // If we don't see a visibility change within 100ms, it's probably a\n      // regular focus change.\n      hadFocusVisibleRecently = true;\n      window.clearTimeout(hadFocusVisibleRecentlyTimeout);\n      hadFocusVisibleRecentlyTimeout = window.setTimeout(() => {\n        hadFocusVisibleRecently = false;\n      }, 100);\n      isFocusVisibleRef.current = false;\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Should be called if a blur event is fired\n   */\n\n\n  function handleFocusVisible(event) {\n    if (isFocusVisible(event)) {\n      isFocusVisibleRef.current = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  return {\n    isFocusVisibleRef,\n    onFocus: handleFocusVisible,\n    onBlur: handleBlurVisible,\n    ref\n  };\n}","import * as React from 'react';\nimport setRef from './setRef';\nexport default function useForkRef(refA, refB) {\n  /**\n   * This will create a new function if the ref props change and are defined.\n   * This means react will call the old forkRef with `null` and the new forkRef\n   * with the ref. Cleanup naturally emerges from this behavior.\n   */\n  return React.useMemo(() => {\n    if (refA == null && refB == null) {\n      return null;\n    }\n\n    return refValue => {\n      setRef(refA, refValue);\n      setRef(refB, refValue);\n    };\n  }, [refA, refB]);\n}","import { unstable_useIsFocusVisible as useIsFocusVisible } from '@mui/utils';\nexport default useIsFocusVisible;","import { unstable_ClassNameGenerator as ClassNameGenerator } from '@mui/base/className';\nexport { default as capitalize } from './capitalize';\nexport { default as createChainedFunction } from './createChainedFunction';\nexport { default as createSvgIcon } from './createSvgIcon';\nexport { default as debounce } from './debounce';\nexport { default as deprecatedPropType } from './deprecatedPropType';\nexport { default as isMuiElement } from './isMuiElement';\nexport { default as ownerDocument } from './ownerDocument';\nexport { default as ownerWindow } from './ownerWindow';\nexport { default as requirePropFactory } from './requirePropFactory';\nexport { default as setRef } from './setRef';\nexport { default as unstable_useEnhancedEffect } from './useEnhancedEffect';\nexport { default as unstable_useId } from './useId';\nexport { default as unsupportedProp } from './unsupportedProp';\nexport { default as useControlled } from './useControlled';\nexport { default as useEventCallback } from './useEventCallback';\nexport { default as useForkRef } from './useForkRef';\nexport { default as useIsFocusVisible } from './useIsFocusVisible'; // TODO: remove this export once ClassNameGenerator is stable\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\nexport const unstable_ClassNameGenerator = {\n  configure: generator => {\n    console.warn(['MUI: `ClassNameGenerator` import from `@mui/material/utils` is outdated and might cause unexpected issues.', '', \"You should use `import { unstable_ClassNameGenerator } from '@mui/material/className'` instead\", '', 'The detail of the issue: https://github.com/mui/material-ui/issues/30011#issuecomment-1024993401', '', 'The updated documentation: https://mui.com/guides/classname-generator/'].join('\\n'));\n    ClassNameGenerator.configure(generator);\n  }\n};","import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nexport var responsiveArray = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];\nexport var responsiveMap = {\n  xs: '(max-width: 575px)',\n  sm: '(min-width: 576px)',\n  md: '(min-width: 768px)',\n  lg: '(min-width: 992px)',\n  xl: '(min-width: 1200px)',\n  xxl: '(min-width: 1600px)'\n};\nvar subscribers = new Map();\nvar subUid = -1;\nvar screens = {};\nvar responsiveObserve = {\n  matchHandlers: {},\n  dispatch: function dispatch(pointMap) {\n    screens = pointMap;\n    subscribers.forEach(function (func) {\n      return func(screens);\n    });\n    return subscribers.size >= 1;\n  },\n  subscribe: function subscribe(func) {\n    if (!subscribers.size) this.register();\n    subUid += 1;\n    subscribers.set(subUid, func);\n    func(screens);\n    return subUid;\n  },\n  unsubscribe: function unsubscribe(token) {\n    subscribers[\"delete\"](token);\n    if (!subscribers.size) this.unregister();\n  },\n  unregister: function unregister() {\n    var _this = this;\n\n    Object.keys(responsiveMap).forEach(function (screen) {\n      var matchMediaQuery = responsiveMap[screen];\n      var handler = _this.matchHandlers[matchMediaQuery];\n      handler === null || handler === void 0 ? void 0 : handler.mql.removeListener(handler === null || handler === void 0 ? void 0 : handler.listener);\n    });\n    subscribers.clear();\n  },\n  register: function register() {\n    var _this2 = this;\n\n    Object.keys(responsiveMap).forEach(function (screen) {\n      var matchMediaQuery = responsiveMap[screen];\n\n      var listener = function listener(_ref) {\n        var matches = _ref.matches;\n\n        _this2.dispatch(_extends(_extends({}, screens), _defineProperty({}, screen, matches)));\n      };\n\n      var mql = window.matchMedia(matchMediaQuery);\n      mql.addListener(listener);\n      _this2.matchHandlers[matchMediaQuery] = {\n        mql: mql,\n        listener: listener\n      };\n      listener(mql);\n    });\n  }\n};\nexport default responsiveObserve;","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport * as React from 'react';\nimport classNames from 'classnames';\nimport { ConfigContext } from '../config-provider';\nimport RowContext from './RowContext';\nimport { tuple } from '../_util/type';\nimport ResponsiveObserve, { responsiveArray } from '../_util/responsiveObserve';\nimport useFlexGapSupport from '../_util/hooks/useFlexGapSupport';\nvar RowAligns = tuple('top', 'middle', 'bottom', 'stretch');\nvar RowJustify = tuple('start', 'end', 'center', 'space-around', 'space-between', 'space-evenly');\nvar Row = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  var _classNames;\n\n  var customizePrefixCls = props.prefixCls,\n      justify = props.justify,\n      align = props.align,\n      className = props.className,\n      style = props.style,\n      children = props.children,\n      _props$gutter = props.gutter,\n      gutter = _props$gutter === void 0 ? 0 : _props$gutter,\n      wrap = props.wrap,\n      others = __rest(props, [\"prefixCls\", \"justify\", \"align\", \"className\", \"style\", \"children\", \"gutter\", \"wrap\"]);\n\n  var _React$useContext = React.useContext(ConfigContext),\n      getPrefixCls = _React$useContext.getPrefixCls,\n      direction = _React$useContext.direction;\n\n  var _React$useState = React.useState({\n    xs: true,\n    sm: true,\n    md: true,\n    lg: true,\n    xl: true,\n    xxl: true\n  }),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      screens = _React$useState2[0],\n      setScreens = _React$useState2[1];\n\n  var supportFlexGap = useFlexGapSupport();\n  var gutterRef = React.useRef(gutter); // ================================== Effect ==================================\n\n  React.useEffect(function () {\n    var token = ResponsiveObserve.subscribe(function (screen) {\n      var currentGutter = gutterRef.current || 0;\n\n      if (!Array.isArray(currentGutter) && _typeof(currentGutter) === 'object' || Array.isArray(currentGutter) && (_typeof(currentGutter[0]) === 'object' || _typeof(currentGutter[1]) === 'object')) {\n        setScreens(screen);\n      }\n    });\n    return function () {\n      return ResponsiveObserve.unsubscribe(token);\n    };\n  }, []); // ================================== Render ==================================\n\n  var getGutter = function getGutter() {\n    var results = [0, 0];\n    var normalizedGutter = Array.isArray(gutter) ? gutter : [gutter, 0];\n    normalizedGutter.forEach(function (g, index) {\n      if (_typeof(g) === 'object') {\n        for (var i = 0; i < responsiveArray.length; i++) {\n          var breakpoint = responsiveArray[i];\n\n          if (screens[breakpoint] && g[breakpoint] !== undefined) {\n            results[index] = g[breakpoint];\n            break;\n          }\n        }\n      } else {\n        results[index] = g || 0;\n      }\n    });\n    return results;\n  };\n\n  var prefixCls = getPrefixCls('row', customizePrefixCls);\n  var gutters = getGutter();\n  var classes = classNames(prefixCls, (_classNames = {}, _defineProperty(_classNames, \"\".concat(prefixCls, \"-no-wrap\"), wrap === false), _defineProperty(_classNames, \"\".concat(prefixCls, \"-\").concat(justify), justify), _defineProperty(_classNames, \"\".concat(prefixCls, \"-\").concat(align), align), _defineProperty(_classNames, \"\".concat(prefixCls, \"-rtl\"), direction === 'rtl'), _classNames), className); // Add gutter related style\n\n  var rowStyle = {};\n  var horizontalGutter = gutters[0] > 0 ? gutters[0] / -2 : undefined;\n  var verticalGutter = gutters[1] > 0 ? gutters[1] / -2 : undefined;\n\n  if (horizontalGutter) {\n    rowStyle.marginLeft = horizontalGutter;\n    rowStyle.marginRight = horizontalGutter;\n  }\n\n  if (supportFlexGap) {\n    // Set gap direct if flex gap support\n    var _gutters = _slicedToArray(gutters, 2);\n\n    rowStyle.rowGap = _gutters[1];\n  } else if (verticalGutter) {\n    rowStyle.marginTop = verticalGutter;\n    rowStyle.marginBottom = verticalGutter;\n  } // \"gutters\" is a new array in each rendering phase, it'll make 'React.useMemo' effectless.\n  // So we deconstruct \"gutters\" variable here.\n\n\n  var _gutters2 = _slicedToArray(gutters, 2),\n      gutterH = _gutters2[0],\n      gutterV = _gutters2[1];\n\n  var rowContext = React.useMemo(function () {\n    return {\n      gutter: [gutterH, gutterV],\n      wrap: wrap,\n      supportFlexGap: supportFlexGap\n    };\n  }, [gutterH, gutterV, wrap, supportFlexGap]);\n  return /*#__PURE__*/React.createElement(RowContext.Provider, {\n    value: rowContext\n  }, /*#__PURE__*/React.createElement(\"div\", _extends({}, others, {\n    className: classes,\n    style: _extends(_extends({}, rowStyle), style),\n    ref: ref\n  }), children));\n});\nRow.displayName = 'Row';\nexport default Row;","import { Row } from '../grid';\nexport default Row;","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\n\n/**\n * Check if given code is a number\n */\nfunction isNumber$1(code) {\n    return code > 47 && code < 58;\n}\n/**\n * Check if given character code is alpha code (letter through A to Z)\n */\nfunction isAlpha$1(code, from, to) {\n    from = from || 65; // A\n    to = to || 90; // Z\n    code &= ~32; // quick hack to convert any char code to uppercase char code\n    return code >= from && code <= to;\n}\nfunction isAlphaNumericWord(code) {\n    return isNumber$1(code) || isAlphaWord(code);\n}\nfunction isAlphaWord(code) {\n    return code === 95 /* _ */ || isAlpha$1(code);\n}\n/**\n * Check if given character code is a white-space character: a space character\n * or line breaks\n */\nfunction isWhiteSpace$3(code) {\n    return code === 32 /* space */\n        || code === 9 /* tab */\n        || code === 160; /* non-breaking space */\n}\n/**\n * Check if given character code is a space character\n */\nfunction isSpace(code) {\n    return isWhiteSpace$3(code)\n        || code === 10 /* LF */\n        || code === 13; /* CR */\n}\n/**\n * Check if given character code is a quote character\n */\nfunction isQuote$2(code) {\n    return code === 39 /* ' */ || code === 34 /* \" */;\n}\n\n/**\n * A streaming, character code-based string reader\n */\nclass Scanner {\n    constructor(str, start, end) {\n        if (end == null && typeof str === 'string') {\n            end = str.length;\n        }\n        this.string = str;\n        this.pos = this.start = start || 0;\n        this.end = end || 0;\n    }\n    /**\n     * Returns true only if the stream is at the end of the file.\n     */\n    eof() {\n        return this.pos >= this.end;\n    }\n    /**\n     * Creates a new stream instance which is limited to given `start` and `end`\n     * range. E.g. its `eof()` method will look at `end` property, not actual\n     * stream end\n     */\n    limit(start, end) {\n        return new Scanner(this.string, start, end);\n    }\n    /**\n     * Returns the next character code in the stream without advancing it.\n     * Will return NaN at the end of the file.\n     */\n    peek() {\n        return this.string.charCodeAt(this.pos);\n    }\n    /**\n     * Returns the next character in the stream and advances it.\n     * Also returns <code>undefined</code> when no more characters are available.\n     */\n    next() {\n        if (this.pos < this.string.length) {\n            return this.string.charCodeAt(this.pos++);\n        }\n    }\n    /**\n     * `match` can be a character code or a function that takes a character code\n     * and returns a boolean. If the next character in the stream 'matches'\n     * the given argument, it is consumed and returned.\n     * Otherwise, `false` is returned.\n     */\n    eat(match) {\n        const ch = this.peek();\n        const ok = typeof match === 'function' ? match(ch) : ch === match;\n        if (ok) {\n            this.next();\n        }\n        return ok;\n    }\n    /**\n     * Repeatedly calls <code>eat</code> with the given argument, until it\n     * fails. Returns <code>true</code> if any characters were eaten.\n     */\n    eatWhile(match) {\n        const start = this.pos;\n        while (!this.eof() && this.eat(match)) { /* */ }\n        return this.pos !== start;\n    }\n    /**\n     * Backs up the stream n characters. Backing it up further than the\n     * start of the current token will cause things to break, so be careful.\n     */\n    backUp(n) {\n        this.pos -= (n || 1);\n    }\n    /**\n     * Get the string between the start of the current token and the\n     * current stream position.\n     */\n    current() {\n        return this.substring(this.start, this.pos);\n    }\n    /**\n     * Returns substring for given range\n     */\n    substring(start, end) {\n        return this.string.slice(start, end);\n    }\n    /**\n     * Creates error object with current stream state\n     */\n    error(message, pos = this.pos) {\n        return new ScannerError(`${message} at ${pos + 1}`, pos, this.string);\n    }\n}\nclass ScannerError extends Error {\n    constructor(message, pos, str) {\n        super(message);\n        this.pos = pos;\n        this.string = str;\n    }\n}\n\nfunction tokenScanner$1(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek$3(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction next(scanner) {\n    return scanner.tokens[scanner.pos++];\n}\nfunction slice(scanner, from = scanner.start, to = scanner.pos) {\n    return scanner.tokens.slice(from, to);\n}\nfunction readable$1(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume$2(scanner, test) {\n    const token = peek$3(scanner);\n    if (token && test(token)) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error$1(scanner, message, token = peek$3(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction abbreviation(abbr, options = {}) {\n    const scanner = tokenScanner$1(abbr);\n    const result = statements(scanner, options);\n    if (readable$1(scanner)) {\n        throw error$1(scanner, 'Unexpected character');\n    }\n    return result;\n}\nfunction statements(scanner, options) {\n    const result = {\n        type: 'TokenGroup',\n        elements: []\n    };\n    let ctx = result;\n    let node;\n    const stack = [];\n    while (readable$1(scanner)) {\n        if (node = element$2(scanner, options) || group(scanner, options)) {\n            ctx.elements.push(node);\n            if (consume$2(scanner, isChildOperator)) {\n                stack.push(ctx);\n                ctx = node;\n            }\n            else if (consume$2(scanner, isSiblingOperator$1)) {\n                continue;\n            }\n            else if (consume$2(scanner, isClimbOperator)) {\n                do {\n                    if (stack.length) {\n                        ctx = stack.pop();\n                    }\n                } while (consume$2(scanner, isClimbOperator));\n            }\n        }\n        else {\n            break;\n        }\n    }\n    return result;\n}\n/**\n * Consumes group from given scanner\n */\nfunction group(scanner, options) {\n    if (consume$2(scanner, isGroupStart)) {\n        const result = statements(scanner, options);\n        const token = next(scanner);\n        if (isBracket$2(token, 'group', false)) {\n            result.repeat = repeater(scanner);\n        }\n        return result;\n    }\n}\n/**\n * Consumes single element from given scanner\n */\nfunction element$2(scanner, options) {\n    let attr;\n    const elem = {\n        type: 'TokenElement',\n        name: void 0,\n        attributes: void 0,\n        value: void 0,\n        repeat: void 0,\n        selfClose: false,\n        elements: []\n    };\n    if (elementName(scanner, options)) {\n        elem.name = slice(scanner);\n    }\n    while (readable$1(scanner)) {\n        scanner.start = scanner.pos;\n        if (!elem.repeat && !isEmpty(elem) && consume$2(scanner, isRepeater)) {\n            elem.repeat = scanner.tokens[scanner.pos - 1];\n        }\n        else if (!elem.value && text(scanner)) {\n            elem.value = getText(scanner);\n        }\n        else if (attr = shortAttribute(scanner, 'id', options) || shortAttribute(scanner, 'class', options) || attributeSet(scanner)) {\n            if (!elem.attributes) {\n                elem.attributes = Array.isArray(attr) ? attr.slice() : [attr];\n            }\n            else {\n                elem.attributes = elem.attributes.concat(attr);\n            }\n        }\n        else {\n            if (!isEmpty(elem) && consume$2(scanner, isCloseOperator)) {\n                elem.selfClose = true;\n                if (!elem.repeat && consume$2(scanner, isRepeater)) {\n                    elem.repeat = scanner.tokens[scanner.pos - 1];\n                }\n            }\n            break;\n        }\n    }\n    return !isEmpty(elem) ? elem : void 0;\n}\n/**\n * Consumes attribute set from given scanner\n */\nfunction attributeSet(scanner) {\n    if (consume$2(scanner, isAttributeSetStart)) {\n        const attributes = [];\n        let attr;\n        while (readable$1(scanner)) {\n            if (attr = attribute(scanner)) {\n                attributes.push(attr);\n            }\n            else if (consume$2(scanner, isAttributeSetEnd)) {\n                break;\n            }\n            else if (!consume$2(scanner, isWhiteSpace$2)) {\n                throw error$1(scanner, `Unexpected \"${peek$3(scanner).type}\" token`);\n            }\n        }\n        return attributes;\n    }\n}\n/**\n * Consumes attribute shorthand (class or id) from given scanner\n */\nfunction shortAttribute(scanner, type, options) {\n    if (isOperator$1(peek$3(scanner), type)) {\n        scanner.pos++;\n        const attr = {\n            name: [createLiteral$1(type)]\n        };\n        // Consume expression after shorthand start for React-like components\n        if (options.jsx && text(scanner)) {\n            attr.value = getText(scanner);\n            attr.expression = true;\n        }\n        else {\n            attr.value = literal$2(scanner) ? slice(scanner) : void 0;\n        }\n        return attr;\n    }\n}\n/**\n * Consumes single attribute from given scanner\n */\nfunction attribute(scanner) {\n    if (quoted(scanner)) {\n        // Consumed quoted value: its a value for default attribute\n        return {\n            value: slice(scanner)\n        };\n    }\n    if (literal$2(scanner, true)) {\n        return {\n            name: slice(scanner),\n            value: consume$2(scanner, isEquals) && (quoted(scanner) || literal$2(scanner, true))\n                ? slice(scanner)\n                : void 0\n        };\n    }\n}\nfunction repeater(scanner) {\n    return isRepeater(peek$3(scanner))\n        ? scanner.tokens[scanner.pos++]\n        : void 0;\n}\n/**\n * Consumes quoted value from given scanner, if possible\n */\nfunction quoted(scanner) {\n    const start = scanner.pos;\n    const quote = peek$3(scanner);\n    if (isQuote$1(quote)) {\n        scanner.pos++;\n        while (readable$1(scanner)) {\n            if (isQuote$1(next(scanner), quote.single)) {\n                scanner.start = start;\n                return true;\n            }\n        }\n        throw error$1(scanner, 'Unclosed quote', quote);\n    }\n    return false;\n}\n/**\n * Consumes literal (unquoted value) from given scanner\n */\nfunction literal$2(scanner, allowBrackets) {\n    const start = scanner.pos;\n    const brackets = {\n        attribute: 0,\n        expression: 0,\n        group: 0\n    };\n    while (readable$1(scanner)) {\n        const token = peek$3(scanner);\n        if (brackets.expression) {\n            // If were inside expression, we should consume all content in it\n            if (isBracket$2(token, 'expression')) {\n                brackets[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else if (isQuote$1(token) || isOperator$1(token) || isWhiteSpace$2(token) || isRepeater(token)) {\n            break;\n        }\n        else if (isBracket$2(token)) {\n            if (!allowBrackets) {\n                break;\n            }\n            if (token.open) {\n                brackets[token.context]++;\n            }\n            else if (!brackets[token.context]) {\n                // Stop if found unmatched closing brace: it must be handled\n                // by parent consumer\n                break;\n            }\n            else {\n                brackets[token.context]--;\n            }\n        }\n        scanner.pos++;\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes element name from given scanner\n */\nfunction elementName(scanner, options) {\n    const start = scanner.pos;\n    if (options.jsx && consume$2(scanner, isCapitalizedLiteral)) {\n        // Check for edge case: consume immediate capitalized class names\n        // for React-like components, e.g. `Foo.Bar.Baz`\n        while (readable$1(scanner)) {\n            const { pos } = scanner;\n            if (!consume$2(scanner, isClassNameOperator) || !consume$2(scanner, isCapitalizedLiteral)) {\n                scanner.pos = pos;\n                break;\n            }\n        }\n    }\n    while (readable$1(scanner) && consume$2(scanner, isElementName)) {\n        // empty\n    }\n    if (scanner.pos !== start) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes text value from given scanner\n */\nfunction text(scanner) {\n    const start = scanner.pos;\n    if (consume$2(scanner, isTextStart)) {\n        let brackets = 0;\n        while (readable$1(scanner)) {\n            const token = next(scanner);\n            if (isBracket$2(token, 'expression')) {\n                if (token.open) {\n                    brackets++;\n                }\n                else if (!brackets) {\n                    break;\n                }\n                else {\n                    brackets--;\n                }\n            }\n        }\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\nfunction getText(scanner) {\n    let from = scanner.start;\n    let to = scanner.pos;\n    if (isBracket$2(scanner.tokens[from], 'expression', true)) {\n        from++;\n    }\n    if (isBracket$2(scanner.tokens[to - 1], 'expression', false)) {\n        to--;\n    }\n    return slice(scanner, from, to);\n}\nfunction isBracket$2(token, context, isOpen) {\n    return Boolean(token && token.type === 'Bracket'\n        && (!context || token.context === context)\n        && (isOpen == null || token.open === isOpen));\n}\nfunction isOperator$1(token, type) {\n    return Boolean(token && token.type === 'Operator' && (!type || token.operator === type));\n}\nfunction isQuote$1(token, isSingle) {\n    return Boolean(token && token.type === 'Quote' && (isSingle == null || token.single === isSingle));\n}\nfunction isWhiteSpace$2(token) {\n    return Boolean(token && token.type === 'WhiteSpace');\n}\nfunction isEquals(token) {\n    return isOperator$1(token, 'equal');\n}\nfunction isRepeater(token) {\n    return Boolean(token && token.type === 'Repeater');\n}\nfunction isLiteral$2(token) {\n    return token.type === 'Literal';\n}\nfunction isCapitalizedLiteral(token) {\n    if (isLiteral$2(token)) {\n        const ch = token.value.charCodeAt(0);\n        return ch >= 65 && ch <= 90;\n    }\n    return false;\n}\nfunction isElementName(token) {\n    return token.type === 'Literal' || token.type === 'RepeaterNumber' || token.type === 'RepeaterPlaceholder';\n}\nfunction isClassNameOperator(token) {\n    return isOperator$1(token, 'class');\n}\nfunction isAttributeSetStart(token) {\n    return isBracket$2(token, 'attribute', true);\n}\nfunction isAttributeSetEnd(token) {\n    return isBracket$2(token, 'attribute', false);\n}\nfunction isTextStart(token) {\n    return isBracket$2(token, 'expression', true);\n}\nfunction isGroupStart(token) {\n    return isBracket$2(token, 'group', true);\n}\nfunction createLiteral$1(value) {\n    return { type: 'Literal', value };\n}\nfunction isEmpty(elem) {\n    return !elem.name && !elem.value && !elem.attributes;\n}\nfunction isChildOperator(token) {\n    return isOperator$1(token, 'child');\n}\nfunction isSiblingOperator$1(token) {\n    return isOperator$1(token, 'sibling');\n}\nfunction isClimbOperator(token) {\n    return isOperator$1(token, 'climb');\n}\nfunction isCloseOperator(token) {\n    return isOperator$1(token, 'close');\n}\n\n/**\n * If consumes escape character, sets current stream range to escaped value\n */\nfunction escaped(scanner) {\n    if (scanner.eat(92 /* Escape */)) {\n        scanner.start = scanner.pos;\n        if (!scanner.eof()) {\n            scanner.pos++;\n        }\n        return true;\n    }\n    return false;\n}\n\nfunction tokenize$1(source) {\n    const scanner = new Scanner(source);\n    const result = [];\n    const ctx = {\n        group: 0,\n        attribute: 0,\n        expression: 0,\n        quote: 0\n    };\n    let ch = 0;\n    let token;\n    while (!scanner.eof()) {\n        ch = scanner.peek();\n        token = getToken$1(scanner, ctx);\n        if (token) {\n            result.push(token);\n            if (token.type === 'Quote') {\n                ctx.quote = ch === ctx.quote ? 0 : ch;\n            }\n            else if (token.type === 'Bracket') {\n                ctx[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else {\n            throw scanner.error('Unexpected character');\n        }\n    }\n    return result;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken$1(scanner, ctx) {\n    return field$2(scanner, ctx)\n        || repeaterPlaceholder(scanner)\n        || repeaterNumber(scanner)\n        || repeater$1(scanner)\n        || whiteSpace$1(scanner)\n        || literal$1$1(scanner, ctx)\n        || operator$1(scanner)\n        || quote(scanner)\n        || bracket$1(scanner);\n}\n/**\n * Consumes literal from given scanner\n */\nfunction literal$1$1(scanner, ctx) {\n    const start = scanner.pos;\n    let value = '';\n    while (!scanner.eof()) {\n        // Consume escaped sequence no matter of context\n        if (escaped(scanner)) {\n            value += scanner.current();\n            continue;\n        }\n        const ch = scanner.peek();\n        if (ch === ctx.quote || ch === 36 /* Dollar */ || isAllowedOperator(ch, ctx)) {\n            // 1. Found matching quote\n            // 2. The `$` character has special meaning in every context\n            // 3. Depending on context, some characters should be treated as operators\n            break;\n        }\n        if (ctx.expression && ch === 125 /* CurlyBracketClose */) {\n            break;\n        }\n        if (!ctx.quote && !ctx.expression) {\n            // Consuming element name\n            if (!ctx.attribute && !isElementName$1(ch)) {\n                break;\n            }\n            if (isAllowedSpace(ch, ctx) || isAllowedRepeater(ch, ctx) || isQuote$2(ch) || bracketType(ch)) {\n                // Stop for characters not allowed in unquoted literal\n                break;\n            }\n        }\n        value += scanner.string[scanner.pos++];\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return {\n            type: 'Literal',\n            value,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace$1(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos,\n            value: scanner.substring(start, scanner.pos)\n        };\n    }\n}\n/**\n * Consumes quote from given scanner\n */\nfunction quote(scanner) {\n    const ch = scanner.peek();\n    if (isQuote$2(ch)) {\n        return {\n            type: 'Quote',\n            single: ch === 39 /* SingleQuote */,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket$1(scanner) {\n    const ch = scanner.peek();\n    const context = bracketType(ch);\n    if (context) {\n        return {\n            type: 'Bracket',\n            open: isOpenBracket$2(ch),\n            context,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator$1(scanner) {\n    const op = operatorType$1(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes node repeat token from current stream position and returns its\n * parsed value\n */\nfunction repeater$1(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(42 /* Asterisk */)) {\n        scanner.start = scanner.pos;\n        let count = 1;\n        let implicit = false;\n        if (scanner.eatWhile(isNumber$1)) {\n            count = Number(scanner.current());\n        }\n        else {\n            implicit = true;\n        }\n        return {\n            type: 'Repeater',\n            count,\n            value: 0,\n            implicit,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes repeater placeholder `$#` from given scanner\n */\nfunction repeaterPlaceholder(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(36 /* Dollar */) && scanner.eat(35 /* Hash */)) {\n        return {\n            type: 'RepeaterPlaceholder',\n            value: void 0,\n            start,\n            end: scanner.pos\n        };\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes numbering token like `$` from given scanner state\n */\nfunction repeaterNumber(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(36 /* Dollar */)) {\n        const size = scanner.pos - start;\n        let reverse = false;\n        let base = 1;\n        let parent = 0;\n        if (scanner.eat(64 /* At */)) {\n            // Consume numbering modifiers\n            while (scanner.eat(94 /* Climb */)) {\n                parent++;\n            }\n            reverse = scanner.eat(45 /* Dash */);\n            scanner.start = scanner.pos;\n            if (scanner.eatWhile(isNumber$1)) {\n                base = Number(scanner.current());\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'RepeaterNumber',\n            size,\n            reverse,\n            base,\n            parent,\n            start,\n            end: scanner.pos\n        };\n    }\n}\nfunction field$2(scanner, ctx) {\n    const start = scanner.pos;\n    // Fields are allowed inside expressions and attributes\n    if ((ctx.expression || ctx.attribute) && scanner.eat(36 /* Dollar */) && scanner.eat(123 /* CurlyBracketOpen */)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber$1)) {\n            // Its a field\n            index = Number(scanner.current());\n            name = scanner.eat(58 /* Colon */) ? consumePlaceholder$2(scanner) : '';\n        }\n        else if (isAlpha$1(scanner.peek())) {\n            // Its a variable\n            name = consumePlaceholder$2(scanner);\n        }\n        if (scanner.eat(125 /* CurlyBracketClose */)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then theres no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder$2(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(123 /* CurlyBracketOpen */)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(125 /* CurlyBracketClose */)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Check if given character code is an operator and its allowed in current context\n */\nfunction isAllowedOperator(ch, ctx) {\n    const op = operatorType$1(ch);\n    if (!op || ctx.quote || ctx.expression) {\n        // No operators inside quoted values or expressions\n        return false;\n    }\n    // Inside attributes, only `equals` is allowed\n    return !ctx.attribute || op === 'equal';\n}\n/**\n * Check if given character is a space character and is allowed to be consumed\n * as a space token in current context\n */\nfunction isAllowedSpace(ch, ctx) {\n    return isSpace(ch) && !ctx.expression;\n}\n/**\n * Check if given character can be consumed as repeater in current context\n */\nfunction isAllowedRepeater(ch, ctx) {\n    return ch === 42 /* Asterisk */ && !ctx.attribute && !ctx.expression;\n}\n/**\n * If given character is a bracket, returns its type\n */\nfunction bracketType(ch) {\n    if (ch === 40 /* RoundBracketOpen */ || ch === 41 /* RoundBracketClose */) {\n        return 'group';\n    }\n    if (ch === 91 /* SquareBracketOpen */ || ch === 93 /* SquareBracketClose */) {\n        return 'attribute';\n    }\n    if (ch === 123 /* CurlyBracketOpen */ || ch === 125 /* CurlyBracketClose */) {\n        return 'expression';\n    }\n}\n/**\n * If given character is an operator, returns its type\n */\nfunction operatorType$1(ch) {\n    return (ch === 62 /* Child */ && 'child')\n        || (ch === 43 /* Sibling */ && 'sibling')\n        || (ch === 94 /* Climb */ && 'climb')\n        || (ch === 46 /* Dot */ && 'class')\n        || (ch === 35 /* Hash */ && 'id')\n        || (ch === 47 /* Slash */ && 'close')\n        || (ch === 61 /* Equals */ && 'equal')\n        || void 0;\n}\n/**\n * Check if given character is an open bracket\n */\nfunction isOpenBracket$2(ch) {\n    return ch === 123 /* CurlyBracketOpen */\n        || ch === 91 /* SquareBracketOpen */\n        || ch === 40 /* RoundBracketOpen */;\n}\n/**\n * Check if given character is allowed in element name\n */\nfunction isElementName$1(ch) {\n    return isAlphaNumericWord(ch)\n        || ch === 45 /* Dash */\n        || ch === 58 /* Colon */\n        || ch === 33 /* Excl */;\n}\n\nconst operators = {\n    child: '>',\n    class: '.',\n    climb: '^',\n    id: '#',\n    equal: '=',\n    close: '/',\n    sibling: '+'\n};\nconst tokenVisitor = {\n    Literal(token) {\n        return token.value;\n    },\n    Quote(token) {\n        return token.single ? '\\'' : '\"';\n    },\n    Bracket(token) {\n        if (token.context === 'attribute') {\n            return token.open ? '[' : ']';\n        }\n        else if (token.context === 'expression') {\n            return token.open ? '{' : '}';\n        }\n        else {\n            return token.open ? '(' : '}';\n        }\n    },\n    Operator(token) {\n        return operators[token.operator];\n    },\n    Field(token, state) {\n        if (token.index != null) {\n            // Its a field: by default, return TextMate-compatible field\n            return token.name\n                ? `\\${${token.index}:${token.name}}`\n                : `\\${${token.index}`;\n        }\n        else if (token.name) {\n            // Its a variable\n            return state.getVariable(token.name);\n        }\n        return '';\n    },\n    RepeaterPlaceholder(token, state) {\n        // Find closest implicit repeater\n        let repeater;\n        for (let i = state.repeaters.length - 1; i >= 0; i--) {\n            if (state.repeaters[i].implicit) {\n                repeater = state.repeaters[i];\n                break;\n            }\n        }\n        state.inserted = true;\n        return state.getText(repeater && repeater.value);\n    },\n    RepeaterNumber(token, state) {\n        let value = 1;\n        const lastIx = state.repeaters.length - 1;\n        // const repeaterIx = Math.max(0, state.repeaters.length - 1 - token.parent);\n        const repeater = state.repeaters[lastIx];\n        if (repeater) {\n            value = token.reverse\n                ? token.base + repeater.count - repeater.value - 1\n                : token.base + repeater.value;\n            if (token.parent) {\n                const parentIx = Math.max(0, lastIx - token.parent);\n                if (parentIx !== lastIx) {\n                    const parentRepeater = state.repeaters[parentIx];\n                    value += repeater.count * parentRepeater.value;\n                }\n            }\n        }\n        let result = String(value);\n        while (result.length < token.size) {\n            result = '0' + result;\n        }\n        return result;\n    },\n    WhiteSpace(token) {\n        return token.value;\n    }\n};\n/**\n * Converts given value token to string\n */\nfunction stringify$1(token, state) {\n    if (!tokenVisitor[token.type]) {\n        throw new Error(`Unknown token ${token.type}`);\n    }\n    return tokenVisitor[token.type](token, state);\n}\n\nconst urlRegex = /^((https?:|ftp:|file:)?\\/\\/|(www|ftp)\\.)[^ ]*$/;\nconst emailRegex = /^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,5}$/;\n/**\n * Converts given token-based abbreviation into simplified and unrolled node-based\n * abbreviation\n */\nfunction convert(abbr, options = {}) {\n    let textInserted = false;\n    let cleanText;\n    if (options.text) {\n        if (Array.isArray(options.text)) {\n            cleanText = options.text.filter(s => s.trim());\n        }\n        else {\n            cleanText = options.text;\n        }\n    }\n    const result = {\n        type: 'Abbreviation',\n        children: convertGroup(abbr, {\n            inserted: false,\n            repeaters: [],\n            text: options.text,\n            cleanText,\n            repeatGuard: options.maxRepeat || Number.POSITIVE_INFINITY,\n            getText(pos) {\n                var _a;\n                textInserted = true;\n                let value;\n                if (Array.isArray(options.text)) {\n                    if (pos !== undefined && pos >= 0 && pos < cleanText.length) {\n                        return cleanText[pos];\n                    }\n                    value = pos !== undefined ? options.text[pos] : options.text.join('\\n');\n                }\n                else {\n                    value = (_a = options.text) !== null && _a !== void 0 ? _a : '';\n                }\n                return value;\n            },\n            getVariable(name) {\n                const varValue = options.variables && options.variables[name];\n                return varValue != null ? varValue : name;\n            }\n        })\n    };\n    if (options.text != null && !textInserted) {\n        // Text given but no implicitly repeated elements: insert it into\n        // deepest child\n        const deepest = deepestNode(last$1(result.children));\n        if (deepest) {\n            const text = Array.isArray(options.text) ? options.text.join('\\n') : options.text;\n            insertText(deepest, text);\n            if (deepest.name === 'a' && options.href) {\n                // Automatically update value of `<a>` element if inserting URL or email\n                insertHref(deepest, text);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Converts given statement to abbreviation nodes\n */\nfunction convertStatement(node, state) {\n    let result = [];\n    if (node.repeat) {\n        // Node is repeated: we should create copies of given node\n        // and supply context token with actual repeater state\n        const original = node.repeat;\n        const repeat = Object.assign({}, original);\n        repeat.count = repeat.implicit && Array.isArray(state.text)\n            ? state.cleanText.length\n            : (repeat.count || 1);\n        let items;\n        state.repeaters.push(repeat);\n        for (let i = 0; i < repeat.count; i++) {\n            repeat.value = i;\n            node.repeat = repeat;\n            items = isGroup(node)\n                ? convertGroup(node, state)\n                : convertElement(node, state);\n            if (repeat.implicit && !state.inserted) {\n                // Its an implicit repeater but no repeater placeholders found inside,\n                // we should insert text into deepest node\n                const target = last$1(items);\n                const deepest = target && deepestNode(target);\n                if (deepest) {\n                    insertText(deepest, state.getText(repeat.value));\n                }\n            }\n            result = result.concat(items);\n            // We should output at least one repeated item even if its reached\n            // repeat limit\n            if (--state.repeatGuard <= 0) {\n                break;\n            }\n        }\n        state.repeaters.pop();\n        node.repeat = original;\n        if (repeat.implicit) {\n            state.inserted = true;\n        }\n    }\n    else {\n        result = result.concat(isGroup(node) ? convertGroup(node, state) : convertElement(node, state));\n    }\n    return result;\n}\nfunction convertElement(node, state) {\n    let children = [];\n    const elem = {\n        type: 'AbbreviationNode',\n        name: node.name && stringifyName(node.name, state),\n        value: node.value && stringifyValue$1(node.value, state),\n        attributes: void 0,\n        children,\n        repeat: node.repeat && Object.assign({}, node.repeat),\n        selfClosing: node.selfClose,\n    };\n    let result = [elem];\n    for (const child of node.elements) {\n        children = children.concat(convertStatement(child, state));\n    }\n    if (node.attributes) {\n        elem.attributes = [];\n        for (const attr of node.attributes) {\n            elem.attributes.push(convertAttribute(attr, state));\n        }\n    }\n    // In case if current node is a text-only snippet without fields, we should\n    // put all children as siblings\n    if (!elem.name && !elem.attributes && elem.value && !elem.value.some(isField$1)) {\n        // XXX its unclear that `children` is not bound to `elem`\n        // due to concat operation\n        result = result.concat(children);\n    }\n    else {\n        elem.children = children;\n    }\n    return result;\n}\nfunction convertGroup(node, state) {\n    let result = [];\n    for (const child of node.elements) {\n        result = result.concat(convertStatement(child, state));\n    }\n    if (node.repeat) {\n        result = attachRepeater(result, node.repeat);\n    }\n    return result;\n}\nfunction convertAttribute(node, state) {\n    let implied = false;\n    let isBoolean = false;\n    let valueType = node.expression ? 'expression' : 'raw';\n    let value;\n    const name = node.name && stringifyName(node.name, state);\n    if (name && name[0] === '!') {\n        implied = true;\n    }\n    if (name && name[name.length - 1] === '.') {\n        isBoolean = true;\n    }\n    if (node.value) {\n        const tokens = node.value.slice();\n        if (isQuote$1(tokens[0])) {\n            // Its a quoted value: remove quotes from output but mark attribute\n            // value as quoted\n            const quote = tokens.shift();\n            if (tokens.length && last$1(tokens).type === quote.type) {\n                tokens.pop();\n            }\n            valueType = quote.single ? 'singleQuote' : 'doubleQuote';\n        }\n        else if (isBracket$2(tokens[0], 'expression', true)) {\n            // Value is expression: remove brackets but mark value type\n            valueType = 'expression';\n            tokens.shift();\n            if (isBracket$2(last$1(tokens), 'expression', false)) {\n                tokens.pop();\n            }\n        }\n        value = stringifyValue$1(tokens, state);\n    }\n    return {\n        name: isBoolean || implied\n            ? name.slice(implied ? 1 : 0, isBoolean ? -1 : void 0)\n            : name,\n        value,\n        boolean: isBoolean,\n        implied,\n        valueType\n    };\n}\n/**\n * Converts given token list to string\n */\nfunction stringifyName(tokens, state) {\n    let str = '';\n    for (let i = 0; i < tokens.length; i++) {\n        str += stringify$1(tokens[i], state);\n    }\n    return str;\n}\n/**\n * Converts given token list to value list\n */\nfunction stringifyValue$1(tokens, state) {\n    const result = [];\n    let str = '';\n    for (let i = 0, token; i < tokens.length; i++) {\n        token = tokens[i];\n        if (isField$1(token)) {\n            // We should keep original fields in output since some editors has their\n            // own syntax for field or doesnt support fields at all so we should\n            // capture actual field location in output stream\n            if (str) {\n                result.push(str);\n                str = '';\n            }\n            result.push(token);\n        }\n        else {\n            str += stringify$1(token, state);\n        }\n    }\n    if (str) {\n        result.push(str);\n    }\n    return result;\n}\nfunction isGroup(node) {\n    return node.type === 'TokenGroup';\n}\nfunction isField$1(token) {\n    return typeof token === 'object' && token.type === 'Field' && token.index != null;\n}\nfunction last$1(arr) {\n    return arr[arr.length - 1];\n}\nfunction deepestNode(node) {\n    return node.children.length ? deepestNode(last$1(node.children)) : node;\n}\nfunction insertText(node, text) {\n    if (node.value) {\n        const lastToken = last$1(node.value);\n        if (typeof lastToken === 'string') {\n            node.value[node.value.length - 1] += text;\n        }\n        else {\n            node.value.push(text);\n        }\n    }\n    else {\n        node.value = [text];\n    }\n}\nfunction insertHref(node, text) {\n    var _a;\n    let href = '';\n    if (urlRegex.test(text)) {\n        href = text;\n        if (!/\\w+:/.test(href) && !href.startsWith('//')) {\n            href = `http://${href}`;\n        }\n    }\n    else if (emailRegex.test(text)) {\n        href = `mailto:${text}`;\n    }\n    const hrefAttribute = (_a = node.attributes) === null || _a === void 0 ? void 0 : _a.find(attr => attr.name === 'href');\n    if (!hrefAttribute) {\n        if (!node.attributes) {\n            node.attributes = [];\n        }\n        node.attributes.push({ name: 'href', value: [href], valueType: 'doubleQuote' });\n    }\n    else if (!hrefAttribute.value) {\n        hrefAttribute.value = [href];\n    }\n}\nfunction attachRepeater(items, repeater) {\n    for (const item of items) {\n        if (!item.repeat) {\n            item.repeat = Object.assign({}, repeater);\n        }\n    }\n    return items;\n}\n\n/**\n * Parses given abbreviation into node tree\n */\nfunction parseAbbreviation(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize$1(abbr) : abbr;\n        return convert(abbreviation(tokens, options), options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\nfunction tokenize(abbr, isValue) {\n    let brackets = 0;\n    let token;\n    const scanner = new Scanner(abbr);\n    const tokens = [];\n    while (!scanner.eof()) {\n        token = getToken(scanner, brackets === 0 && !isValue);\n        if (!token) {\n            throw scanner.error('Unexpected character');\n        }\n        if (token.type === 'Bracket') {\n            if (!brackets && token.open) {\n                mergeTokens(scanner, tokens);\n            }\n            brackets += token.open ? 1 : -1;\n            if (brackets < 0) {\n                throw scanner.error('Unexpected bracket', token.start);\n            }\n        }\n        tokens.push(token);\n        // Forcibly consume next operator after unit-less numeric value or color:\n        // next dash `-` must be used as value delimiter\n        if (shouldConsumeDashAfter(token) && (token = operator(scanner))) {\n            tokens.push(token);\n        }\n    }\n    return tokens;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken(scanner, short) {\n    return field$1(scanner)\n        || numberValue(scanner)\n        || colorValue(scanner)\n        || stringValue(scanner)\n        || bracket(scanner)\n        || operator(scanner)\n        || whiteSpace(scanner)\n        || literal$1(scanner, short);\n}\nfunction field$1(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(36 /* Dollar */) && scanner.eat(123 /* CurlyBracketOpen */)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber$1)) {\n            // Its a field\n            index = Number(scanner.current());\n            name = scanner.eat(58 /* Colon */) ? consumePlaceholder$1(scanner) : '';\n        }\n        else if (isAlpha$1(scanner.peek())) {\n            // Its a variable\n            name = consumePlaceholder$1(scanner);\n        }\n        if (scanner.eat(125 /* CurlyBracketClose */)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then theres no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder$1(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(123 /* CurlyBracketOpen */)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(125 /* CurlyBracketClose */)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Consumes literal from given scanner\n * @param short Use short notation for consuming value.\n * The difference between short and full notation is that first one uses\n * alpha characters only and used for extracting keywords from abbreviation,\n * while full notation also supports numbers and dashes\n */\nfunction literal$1(scanner, short) {\n    const start = scanner.pos;\n    if (scanner.eat(isIdentPrefix)) {\n        // SCSS or LESS variable\n        // NB a bit dirty hack: if abbreviation starts with identifier prefix,\n        // consume alpha characters only to allow embedded variables\n        scanner.eatWhile(start ? isKeyword : isLiteral);\n    }\n    else if (scanner.eat(isAlphaWord)) {\n        scanner.eatWhile(short ? isLiteral : isKeyword);\n    }\n    else {\n        // Allow dots only at the beginning of literal\n        scanner.eat(46 /* Dot */);\n        scanner.eatWhile(isLiteral);\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return createLiteral(scanner, scanner.start = start);\n    }\n}\nfunction createLiteral(scanner, start = scanner.start, end = scanner.pos) {\n    return {\n        type: 'Literal',\n        value: scanner.substring(start, end),\n        start,\n        end\n    };\n}\n/**\n * Consumes numeric CSS value (number with optional unit) from current stream,\n * if possible\n */\nfunction numberValue(scanner) {\n    const start = scanner.pos;\n    if (consumeNumber(scanner)) {\n        scanner.start = start;\n        const rawValue = scanner.current();\n        // eat unit, which can be a % or alpha word\n        scanner.start = scanner.pos;\n        scanner.eat(37 /* Percent */) || scanner.eatWhile(isAlphaWord);\n        return {\n            type: 'NumberValue',\n            value: Number(rawValue),\n            rawValue,\n            unit: scanner.current(),\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes quoted string value from given scanner\n */\nfunction stringValue(scanner) {\n    const ch = scanner.peek();\n    const start = scanner.pos;\n    let finished = false;\n    if (isQuote$2(ch)) {\n        scanner.pos++;\n        while (!scanner.eof()) {\n            // Do not throw error on malformed string\n            if (scanner.eat(ch)) {\n                finished = true;\n                break;\n            }\n            else {\n                scanner.pos++;\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'StringValue',\n            value: scanner.substring(start + 1, scanner.pos - (finished ? 1 : 0)),\n            quote: ch === 39 /* SingleQuote */ ? 'single' : 'double',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes a color token from given string\n */\nfunction colorValue(scanner) {\n    // supported color variations:\n    // #abc    #aabbccc\n    // #0      #000000\n    // #fff.5  rgba(255, 255, 255, 0.5)\n    // #t      transparent\n    const start = scanner.pos;\n    if (scanner.eat(35 /* Hash */)) {\n        const valueStart = scanner.pos;\n        let color = '';\n        let alpha = '';\n        if (scanner.eatWhile(isHex)) {\n            color = scanner.substring(valueStart, scanner.pos);\n            alpha = colorAlpha(scanner);\n        }\n        else if (scanner.eat(116 /* Transparent */)) {\n            color = '0';\n            alpha = colorAlpha(scanner) || '0';\n        }\n        else {\n            alpha = colorAlpha(scanner);\n        }\n        if (color || alpha || scanner.eof()) {\n            const { r, g, b, a } = parseColor(color, alpha);\n            return {\n                type: 'ColorValue',\n                r, g, b, a,\n                raw: scanner.substring(start + 1, scanner.pos),\n                start,\n                end: scanner.pos\n            };\n        }\n        else {\n            // Consumed # but no actual value: invalid color value, treat it as literal\n            return createLiteral(scanner, start);\n        }\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes alpha value of color: `.1`\n */\nfunction colorAlpha(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(46 /* Dot */)) {\n        scanner.start = start;\n        if (scanner.eatWhile(isNumber$1)) {\n            return scanner.current();\n        }\n        return '1';\n    }\n    return '';\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket(scanner) {\n    const ch = scanner.peek();\n    if (isBracket(ch)) {\n        return {\n            type: 'Bracket',\n            open: ch === 40 /* RoundBracketOpen */,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator(scanner) {\n    const op = operatorType(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Eats number value from given stream\n * @return Returns `true` if number was consumed\n */\nfunction consumeNumber(stream) {\n    const start = stream.pos;\n    stream.eat(45 /* Dash */);\n    const afterNegative = stream.pos;\n    const hasDecimal = stream.eatWhile(isNumber$1);\n    const prevPos = stream.pos;\n    if (stream.eat(46 /* Dot */)) {\n        // Its perfectly valid to have numbers like `1.`, which enforces\n        // value to float unit type\n        const hasFloat = stream.eatWhile(isNumber$1);\n        if (!hasDecimal && !hasFloat) {\n            // Lone dot\n            stream.pos = prevPos;\n        }\n    }\n    // Edge case: consumed dash only: not a number, bail-out\n    if (stream.pos === afterNegative) {\n        stream.pos = start;\n    }\n    return stream.pos !== start;\n}\nfunction isIdentPrefix(code) {\n    return code === 64 /* At */ || code === 36 /* Dollar */;\n}\n/**\n * If given character is an operator, returns its type\n */\nfunction operatorType(ch) {\n    return (ch === 43 /* Sibling */ && \"+\" /* Sibling */)\n        || (ch === 33 /* Excl */ && \"!\" /* Important */)\n        || (ch === 44 /* Comma */ && \",\" /* ArgumentDelimiter */)\n        || (ch === 58 /* Colon */ && \":\" /* PropertyDelimiter */)\n        || (ch === 45 /* Dash */ && \"-\" /* ValueDelimiter */)\n        || void 0;\n}\n/**\n * Check if given code is a hex value (/0-9a-f/)\n */\nfunction isHex(code) {\n    return isNumber$1(code) || isAlpha$1(code, 65, 70); // A-F\n}\nfunction isKeyword(code) {\n    return isAlphaNumericWord(code) || code === 45 /* Dash */;\n}\nfunction isBracket(code) {\n    return code === 40 /* RoundBracketOpen */ || code === 41 /* RoundBracketClose */;\n}\nfunction isLiteral(code) {\n    return isAlphaWord(code) || code === 37 /* Percent */ || code === 47 /* Slash */;\n}\n/**\n * Parses given color value from abbreviation into RGBA format\n */\nfunction parseColor(value, alpha) {\n    let r = '0';\n    let g = '0';\n    let b = '0';\n    let a = Number(alpha != null && alpha !== '' ? alpha : 1);\n    if (value === 't') {\n        a = 0;\n    }\n    else {\n        switch (value.length) {\n            case 0:\n                break;\n            case 1:\n                r = g = b = value + value;\n                break;\n            case 2:\n                r = g = b = value;\n                break;\n            case 3:\n                r = value[0] + value[0];\n                g = value[1] + value[1];\n                b = value[2] + value[2];\n                break;\n            default:\n                value += value;\n                r = value.slice(0, 2);\n                g = value.slice(2, 4);\n                b = value.slice(4, 6);\n        }\n    }\n    return {\n        r: parseInt(r, 16),\n        g: parseInt(g, 16),\n        b: parseInt(b, 16),\n        a\n    };\n}\n/**\n * Check if scanner reader must consume dash after given token.\n * Used in cases where user must explicitly separate numeric values\n */\nfunction shouldConsumeDashAfter(token) {\n    return token.type === 'ColorValue' || (token.type === 'NumberValue' && !token.unit);\n}\n/**\n * Merges last adjacent tokens into a single literal.\n * This function is used to overcome edge case when function name was parsed\n * as a list of separate tokens. For example, a `scale3d()` value will be\n * parsed as literal and number tokens (`scale` and `3d`) which is a perfectly\n * valid abbreviation but undesired result. This function will detect last adjacent\n * literal and number values and combine them into single literal\n */\nfunction mergeTokens(scanner, tokens) {\n    let start = 0;\n    let end = 0;\n    while (tokens.length) {\n        const token = last(tokens);\n        if (token.type === 'Literal' || token.type === 'NumberValue') {\n            start = token.start;\n            if (!end) {\n                end = token.end;\n            }\n            tokens.pop();\n        }\n        else {\n            break;\n        }\n    }\n    if (start !== end) {\n        tokens.push(createLiteral(scanner, start, end));\n    }\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\nfunction tokenScanner(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek$2(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction readable(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume$1(scanner, test) {\n    if (test(peek$2(scanner))) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error(scanner, message, token = peek$2(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction parser(tokens, options = {}) {\n    const scanner = tokenScanner(tokens);\n    const result = [];\n    let property;\n    while (readable(scanner)) {\n        if (property = consumeProperty(scanner, options)) {\n            result.push(property);\n        }\n        else if (!consume$1(scanner, isSiblingOperator)) {\n            throw error(scanner, 'Unexpected token');\n        }\n    }\n    return result;\n}\n/**\n * Consumes single CSS property\n */\nfunction consumeProperty(scanner, options) {\n    let name;\n    let important = false;\n    let valueFragment;\n    const value = [];\n    const token = peek$2(scanner);\n    const valueMode = !!options.value;\n    if (!valueMode && isLiteral$1(token) && !isFunctionStart(scanner)) {\n        scanner.pos++;\n        name = token.value;\n        // Consume any following value delimiter after property name\n        consume$1(scanner, isValueDelimiter);\n    }\n    // Skip whitespace right after property name, if any\n    if (valueMode) {\n        consume$1(scanner, isWhiteSpace$1);\n    }\n    while (readable(scanner)) {\n        if (consume$1(scanner, isImportant)) {\n            important = true;\n        }\n        else if (valueFragment = consumeValue(scanner, valueMode)) {\n            value.push(valueFragment);\n        }\n        else if (!consume$1(scanner, isFragmentDelimiter)) {\n            break;\n        }\n    }\n    if (name || value.length || important) {\n        return { name, value, important };\n    }\n}\n/**\n * Consumes single value fragment, e.g. all value tokens before comma\n */\nfunction consumeValue(scanner, inArgument) {\n    const result = [];\n    let token;\n    let args;\n    while (readable(scanner)) {\n        token = peek$2(scanner);\n        if (isValue(token)) {\n            scanner.pos++;\n            if (isLiteral$1(token) && (args = consumeArguments(scanner))) {\n                result.push({\n                    type: 'FunctionCall',\n                    name: token.value,\n                    arguments: args\n                });\n            }\n            else {\n                result.push(token);\n            }\n        }\n        else if (isValueDelimiter(token) || (inArgument && isWhiteSpace$1(token))) {\n            scanner.pos++;\n        }\n        else {\n            break;\n        }\n    }\n    return result.length\n        ? { type: 'CSSValue', value: result }\n        : void 0;\n}\nfunction consumeArguments(scanner) {\n    const start = scanner.pos;\n    if (consume$1(scanner, isOpenBracket$1)) {\n        const args = [];\n        let value;\n        while (readable(scanner) && !consume$1(scanner, isCloseBracket$1)) {\n            if (value = consumeValue(scanner, true)) {\n                args.push(value);\n            }\n            else if (!consume$1(scanner, isWhiteSpace$1) && !consume$1(scanner, isArgumentDelimiter)) {\n                throw error(scanner, 'Unexpected token');\n            }\n        }\n        scanner.start = start;\n        return args;\n    }\n}\nfunction isLiteral$1(token) {\n    return token && token.type === 'Literal';\n}\nfunction isBracket$1(token, open) {\n    return token && token.type === 'Bracket' && (open == null || token.open === open);\n}\nfunction isOpenBracket$1(token) {\n    return isBracket$1(token, true);\n}\nfunction isCloseBracket$1(token) {\n    return isBracket$1(token, false);\n}\nfunction isWhiteSpace$1(token) {\n    return token && token.type === 'WhiteSpace';\n}\nfunction isOperator(token, operator) {\n    return token && token.type === 'Operator' && (!operator || token.operator === operator);\n}\nfunction isSiblingOperator(token) {\n    return isOperator(token, \"+\" /* Sibling */);\n}\nfunction isArgumentDelimiter(token) {\n    return isOperator(token, \",\" /* ArgumentDelimiter */);\n}\nfunction isFragmentDelimiter(token) {\n    return isArgumentDelimiter(token);\n}\nfunction isImportant(token) {\n    return isOperator(token, \"!\" /* Important */);\n}\nfunction isValue(token) {\n    return token.type === 'StringValue'\n        || token.type === 'ColorValue'\n        || token.type === 'NumberValue'\n        || token.type === 'Literal'\n        || token.type === 'Field';\n}\nfunction isValueDelimiter(token) {\n    return isOperator(token, \":\" /* PropertyDelimiter */)\n        || isOperator(token, \"-\" /* ValueDelimiter */);\n}\nfunction isFunctionStart(scanner) {\n    const t1 = scanner.tokens[scanner.pos];\n    const t2 = scanner.tokens[scanner.pos + 1];\n    return t1 && t2 && isLiteral$1(t1) && t2.type === 'Bracket';\n}\n\n/**\n * Parses given abbreviation into property set\n */\nfunction parse$2(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize(abbr, options && options.value) : abbr;\n        return parser(tokens, options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\n/**\n * Merges attributes in current node: de-duplicates attributes with the same name\n * and merges class names\n */\nfunction mergeAttributes(node, config) {\n    if (!node.attributes) {\n        return;\n    }\n    const attributes = [];\n    const lookup = {};\n    for (const attr of node.attributes) {\n        if (attr.name) {\n            const attrName = attr.name;\n            if (attrName in lookup) {\n                const prev = lookup[attrName];\n                if (attrName === 'class') {\n                    prev.value = mergeValue(prev.value, attr.value, ' ');\n                }\n                else {\n                    mergeDeclarations(prev, attr, config);\n                }\n            }\n            else {\n                // Create new attribute instance so we can safely modify it later\n                attributes.push(lookup[attrName] = Object.assign({}, attr));\n            }\n        }\n        else {\n            attributes.push(attr);\n        }\n    }\n    node.attributes = attributes;\n}\n/**\n * Merges two token lists into single list. Adjacent strings are merged together\n */\nfunction mergeValue(prev, next, glue) {\n    if (prev && next) {\n        if (prev.length && glue) {\n            append(prev, glue);\n        }\n        for (const t of next) {\n            append(prev, t);\n        }\n        return prev;\n    }\n    const result = prev || next;\n    return result && result.slice();\n}\n/**\n * Merges data from `src` attribute into `dest` and returns it\n */\nfunction mergeDeclarations(dest, src, config) {\n    dest.name = src.name;\n    if (!config.options['output.reverseAttributes']) {\n        dest.value = src.value;\n    }\n    // Keep high-priority properties\n    if (!dest.implied) {\n        dest.implied = src.implied;\n    }\n    if (!dest.boolean) {\n        dest.boolean = src.boolean;\n    }\n    if (dest.valueType !== 'expression') {\n        dest.valueType = src.valueType;\n    }\n    return dest;\n}\nfunction append(tokens, value) {\n    const lastIx = tokens.length - 1;\n    if (typeof tokens[lastIx] === 'string' && typeof value === 'string') {\n        tokens[lastIx] += value;\n    }\n    else {\n        tokens.push(value);\n    }\n}\n\n/**\n * Walks over each child node of given markup abbreviation AST node (not including\n * given one) and invokes `fn` on each node.\n * The `fn` callback accepts context node, list of ancestor nodes and optional\n * state object\n */\nfunction walk(node, fn, state) {\n    const ancestors = [node];\n    const callback = (ctx) => {\n        fn(ctx, ancestors, state);\n        ancestors.push(ctx);\n        ctx.children.forEach(callback);\n        ancestors.pop();\n    };\n    node.children.forEach(callback);\n}\n/**\n * Finds node which is the deepest for in current node or node itself.\n */\nfunction findDeepest(node) {\n    let parent;\n    while (node.children.length) {\n        parent = node;\n        node = node.children[node.children.length - 1];\n    }\n    return { parent, node };\n}\nfunction isNode(node) {\n    return node.type === 'AbbreviationNode';\n}\n\n/**\n * Finds matching snippet from `registry` and resolves it into a parsed abbreviation.\n * Resolved node is then updated or replaced with matched abbreviation tree.\n *\n * A HTML registry basically contains aliases to another Emmet abbreviations,\n * e.g. a predefined set of name, attributes and so on, possibly a complex\n * abbreviation with multiple elements. So we have to get snippet, parse it\n * and recursively resolve it.\n */\nfunction resolveSnippets(abbr, config) {\n    const stack = [];\n    const reversed = config.options['output.reverseAttributes'];\n    const resolve = (child) => {\n        const snippet = child.name && config.snippets[child.name];\n        // A snippet in stack means circular reference.\n        // It can be either a user error or a perfectly valid snippet like\n        // \"img\": \"img[src alt]/\", e.g. an element with predefined shape.\n        // In any case, simply stop parsing and keep element as is\n        if (!snippet || stack.includes(snippet)) {\n            return null;\n        }\n        const snippetAbbr = parseAbbreviation(snippet, config);\n        stack.push(snippet);\n        walkResolve(snippetAbbr, resolve);\n        stack.pop();\n        // Add attributes from current node into every top-level node of parsed abbreviation\n        for (const topNode of snippetAbbr.children) {\n            if (child.attributes) {\n                const from = topNode.attributes || [];\n                const to = child.attributes || [];\n                topNode.attributes = reversed ? to.concat(from) : from.concat(to);\n            }\n            mergeNodes(child, topNode);\n        }\n        return snippetAbbr;\n    };\n    walkResolve(abbr, resolve);\n    return abbr;\n}\nfunction walkResolve(node, resolve, config) {\n    let children = [];\n    for (const child of node.children) {\n        const resolved = resolve(child);\n        if (resolved) {\n            children = children.concat(resolved.children);\n            const deepest = findDeepest(resolved);\n            if (isNode(deepest.node)) {\n                deepest.node.children = deepest.node.children.concat(walkResolve(child, resolve));\n            }\n        }\n        else {\n            children.push(child);\n            child.children = walkResolve(child, resolve);\n        }\n    }\n    return node.children = children;\n}\n/**\n * Adds data from first node into second node\n */\nfunction mergeNodes(from, to) {\n    if (from.selfClosing) {\n        to.selfClosing = true;\n    }\n    if (from.value != null) {\n        to.value = from.value;\n    }\n    if (from.repeat) {\n        to.repeat = from.repeat;\n    }\n}\n\nfunction createOutputStream(options, level = 0) {\n    return {\n        options,\n        value: '',\n        level,\n        offset: 0,\n        line: 0,\n        column: 0\n    };\n}\n/**\n * Pushes plain string into output stream without newline processing\n */\nfunction push(stream, text) {\n    const processText = stream.options['output.text'];\n    _push(stream, processText(text, stream.offset, stream.line, stream.column));\n}\n/**\n * Pushes given string with possible newline formatting into output\n */\nfunction pushString(stream, value) {\n    // If given value contains newlines, we should push content line-by-line and\n    // use `pushNewline()` to maintain proper line/column state\n    const lines = splitByLines(value);\n    for (let i = 0, il = lines.length - 1; i <= il; i++) {\n        push(stream, lines[i]);\n        if (i !== il) {\n            pushNewline(stream, true);\n        }\n    }\n}\n/**\n * Pushes new line into given output stream\n */\nfunction pushNewline(stream, indent) {\n    const baseIndent = stream.options['output.baseIndent'];\n    const newline = stream.options['output.newline'];\n    push(stream, newline + baseIndent);\n    stream.line++;\n    stream.column = baseIndent.length;\n    if (indent) {\n        pushIndent(stream, indent === true ? stream.level : indent);\n    }\n}\n/**\n * Adds indentation of `size` to current output stream\n */\nfunction pushIndent(stream, size = stream.level) {\n    const indent = stream.options['output.indent'];\n    push(stream, indent.repeat(Math.max(size, 0)));\n}\n/**\n * Pushes field/tabstop into output stream\n */\nfunction pushField(stream, index, placeholder) {\n    const field = stream.options['output.field'];\n    // NB: use `_push` instead of `push` to skip text processing\n    _push(stream, field(index, placeholder, stream.offset, stream.line, stream.column));\n}\n/**\n * Returns given tag name formatted according to given config\n */\nfunction tagName(name, config) {\n    return strCase(name, config.options['output.tagCase']);\n}\n/**\n * Returns given attribute name formatted according to given config\n */\nfunction attrName(name, config) {\n    return strCase(name, config.options['output.attributeCase']);\n}\n/**\n * Returns character for quoting value of given attribute\n */\nfunction attrQuote(attr, config, isOpen) {\n    if (attr.valueType === 'expression') {\n        return isOpen ? '{' : '}';\n    }\n    return config.options['output.attributeQuotes'] === 'single' ? '\\'' : '\"';\n}\n/**\n * Check if given attribute is boolean\n */\nfunction isBooleanAttribute(attr, config) {\n    return attr.boolean\n        || config.options['output.booleanAttributes'].includes((attr.name || '').toLowerCase());\n}\n/**\n * Returns a token for self-closing tag, depending on current options\n */\nfunction selfClose(config) {\n    switch (config.options['output.selfClosingStyle']) {\n        case 'xhtml': return ' /';\n        case 'xml': return '/';\n        default: return '';\n    }\n}\n/**\n * Check if given tag name belongs to inline-level element\n * @param node Parsed node or tag name\n */\nfunction isInline(node, config) {\n    if (typeof node === 'string') {\n        return config.options.inlineElements.includes(node.toLowerCase());\n    }\n    // inline node is a node either with inline-level name or text-only node\n    return node.name ? isInline(node.name, config) : Boolean(node.value && !node.attributes);\n}\n/**\n * Splits given text by lines\n */\nfunction splitByLines(text) {\n    return text.split(/\\r\\n|\\r|\\n/g);\n}\n/**\n * Pushes raw string into output stream without any processing\n */\nfunction _push(stream, text) {\n    stream.value += text;\n    stream.offset += text.length;\n    stream.column += text.length;\n}\nfunction strCase(str, type) {\n    if (type) {\n        return type === 'upper' ? str.toUpperCase() : str.toLowerCase();\n    }\n    return str;\n}\n\nconst elementMap = {\n    p: 'span',\n    ul: 'li',\n    ol: 'li',\n    table: 'tr',\n    tr: 'td',\n    tbody: 'tr',\n    thead: 'tr',\n    tfoot: 'tr',\n    colgroup: 'col',\n    select: 'option',\n    optgroup: 'option',\n    audio: 'source',\n    video: 'source',\n    object: 'param',\n    map: 'area'\n};\nfunction implicitTag(node, ancestors, config) {\n    if (!node.name && node.attributes) {\n        resolveImplicitTag(node, ancestors, config);\n    }\n}\nfunction resolveImplicitTag(node, ancestors, config) {\n    const parent = getParentElement(ancestors);\n    const contextName = config.context ? config.context.name : '';\n    const parentName = lowercase(parent ? parent.name : contextName);\n    node.name = elementMap[parentName]\n        || (isInline(parentName, config) ? 'span' : 'div');\n}\nfunction lowercase(str) {\n    return (str || '').toLowerCase();\n}\n/**\n * Returns closest element node from given ancestors list\n */\nfunction getParentElement(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const elem = ancestors[i];\n        if (isNode(elem)) {\n            return elem;\n        }\n    }\n}\n\nvar latin = {\n\t\"common\": [\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\", \"consectetur\", \"adipisicing\", \"elit\"],\n\t\"words\": [\"exercitationem\", \"perferendis\", \"perspiciatis\", \"laborum\", \"eveniet\",\n\t\t\"sunt\", \"iure\", \"nam\", \"nobis\", \"eum\", \"cum\", \"officiis\", \"excepturi\",\n\t\t\"odio\", \"consectetur\", \"quasi\", \"aut\", \"quisquam\", \"vel\", \"eligendi\",\n\t\t\"itaque\", \"non\", \"odit\", \"tempore\", \"quaerat\", \"dignissimos\",\n\t\t\"facilis\", \"neque\", \"nihil\", \"expedita\", \"vitae\", \"vero\", \"ipsum\",\n\t\t\"nisi\", \"animi\", \"cumque\", \"pariatur\", \"velit\", \"modi\", \"natus\",\n\t\t\"iusto\", \"eaque\", \"sequi\", \"illo\", \"sed\", \"ex\", \"et\", \"voluptatibus\",\n\t\t\"tempora\", \"veritatis\", \"ratione\", \"assumenda\", \"incidunt\", \"nostrum\",\n\t\t\"placeat\", \"aliquid\", \"fuga\", \"provident\", \"praesentium\", \"rem\",\n\t\t\"necessitatibus\", \"suscipit\", \"adipisci\", \"quidem\", \"possimus\",\n\t\t\"voluptas\", \"debitis\", \"sint\", \"accusantium\", \"unde\", \"sapiente\",\n\t\t\"voluptate\", \"qui\", \"aspernatur\", \"laudantium\", \"soluta\", \"amet\",\n\t\t\"quo\", \"aliquam\", \"saepe\", \"culpa\", \"libero\", \"ipsa\", \"dicta\",\n\t\t\"reiciendis\", \"nesciunt\", \"doloribus\", \"autem\", \"impedit\", \"minima\",\n\t\t\"maiores\", \"repudiandae\", \"ipsam\", \"obcaecati\", \"ullam\", \"enim\",\n\t\t\"totam\", \"delectus\", \"ducimus\", \"quis\", \"voluptates\", \"dolores\",\n\t\t\"molestiae\", \"harum\", \"dolorem\", \"quia\", \"voluptatem\", \"molestias\",\n\t\t\"magni\", \"distinctio\", \"omnis\", \"illum\", \"dolorum\", \"voluptatum\", \"ea\",\n\t\t\"quas\", \"quam\", \"corporis\", \"quae\", \"blanditiis\", \"atque\", \"deserunt\",\n\t\t\"laboriosam\", \"earum\", \"consequuntur\", \"hic\", \"cupiditate\",\n\t\t\"quibusdam\", \"accusamus\", \"ut\", \"rerum\", \"error\", \"minus\", \"eius\",\n\t\t\"ab\", \"ad\", \"nemo\", \"fugit\", \"officia\", \"at\", \"in\", \"id\", \"quos\",\n\t\t\"reprehenderit\", \"numquam\", \"iste\", \"fugiat\", \"sit\", \"inventore\",\n\t\t\"beatae\", \"repellendus\", \"magnam\", \"recusandae\", \"quod\", \"explicabo\",\n\t\t\"doloremque\", \"aperiam\", \"consequatur\", \"asperiores\", \"commodi\",\n\t\t\"optio\", \"dolor\", \"labore\", \"temporibus\", \"repellat\", \"veniam\",\n\t\t\"architecto\", \"est\", \"esse\", \"mollitia\", \"nulla\", \"a\", \"similique\",\n\t\t\"eos\", \"alias\", \"dolore\", \"tenetur\", \"deleniti\", \"porro\", \"facere\",\n\t\t\"maxime\", \"corrupti\"]\n};\n\nvar ru = {\n\t\"common\": [\"-\", \"\", \"\", \"\", \" \", \"\", \" \", \"\", \"\", \"\"],\n\t\"words\": [\"\", \" \", \"\", \"\", \"\", \" \", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \" \", \"\", \"\",\"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\",\"\", \"\", \"\", \"lorem\", \"ipsum\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\",  \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\",\n\t\t\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n};\n\nvar sp = {\n\t\"common\": [\"mujer\", \"uno\", \"dolor\", \"ms\", \"de\", \"poder\", \"mismo\", \"si\"],\n\t\"words\": [\"ejercicio\", \"preferencia\", \"perspicacia\", \"laboral\", \"pao\",\n\t\t\"suntuoso\", \"molde\", \"namibia\", \"planeador\", \"mirar\", \"dems\", \"oficinista\", \"excepcin\",\n\t\t\"odio\", \"consecuencia\", \"casi\", \"auto\", \"chicharra\", \"velo\", \"elixir\",\n\t\t\"ataque\", \"no\", \"odio\", \"temporal\", \"curum\", \"dignsimo\",\n\t\t\"facilismo\", \"letra\", \"nihilista\", \"expedicin\", \"alma\", \"alveolar\", \"aparte\",\n\t\t\"len\", \"animal\", \"como\", \"paria\", \"belleza\", \"modo\", \"natividad\",\n\t\t\"justo\", \"ataque\", \"squito\", \"pillo\", \"sed\", \"ex\", \"y\", \"voluminoso\",\n\t\t\"temporalidad\", \"verdades\", \"racional\", \"asuncin\", \"incidente\", \"marejada\",\n\t\t\"placenta\", \"amanecer\", \"fuga\", \"previsor\", \"presentacin\", \"lejos\",\n\t\t\"necesariamente\", \"sospechoso\", \"adiposidad\", \"quindo\", \"pcima\",\n\t\t\"voluble\", \"dbito\", \"sinti\", \"accesorio\", \"falda\", \"sapiencia\",\n\t\t\"volutas\", \"queso\", \"permacultura\", \"laudo\", \"soluciones\", \"entero\",\n\t\t\"pan\", \"litro\", \"tonelada\", \"culpa\", \"libertario\", \"mosca\", \"dictado\",\n\t\t\"reincidente\", \"nascimiento\", \"dolor\", \"escolar\", \"impedimento\", \"mnima\",\n\t\t\"mayores\", \"repugnante\", \"dulce\", \"obcecado\", \"montaa\", \"enigma\",\n\t\t\"total\", \"deletreo\", \"dcima\", \"cbala\", \"fotografa\", \"dolores\",\n\t\t\"molesto\", \"olvido\", \"paciencia\", \"resiliencia\", \"voluntad\", \"molestias\",\n\t\t\"magnfico\", \"distincin\", \"ovni\", \"marejada\", \"cerro\", \"torre\", \"y\",\n\t\t\"abogada\", \"manantial\", \"corporal\", \"agua\", \"crepsculo\", \"ataque\", \"desierto\",\n\t\t\"laboriosamente\", \"angustia\", \"afortunado\", \"alma\", \"encefalograma\",\n\t\t\"materialidad\", \"cosas\", \"o\", \"renuncia\", \"error\", \"menos\", \"conejo\",\n\t\t\"abada\", \"analfabeto\", \"remo\", \"fugacidad\", \"oficio\", \"en\", \"almcigo\", \"vos\", \"pan\",\n\t\t\"represin\", \"nmeros\", \"triste\", \"refugiado\", \"trote\", \"inventor\",\n\t\t\"corchea\", \"repelente\", \"magma\", \"recusado\", \"patrn\", \"explcito\",\n\t\t\"paloma\", \"sndrome\", \"inmune\", \"autoinmune\", \"comodidad\",\n\t\t\"ley\", \"vietnamita\", \"demonio\", \"tasmania\", \"repeler\", \"apndice\",\n\t\t\"arquitecto\", \"columna\", \"yugo\", \"computador\", \"mula\", \"a\", \"propsito\",\n\t\t\"fantasa\", \"alias\", \"rayo\", \"tenedor\", \"deleznable\", \"ventana\", \"cara\",\n\t\t\"anemia\", \"corrupto\"]\n};\n\nconst vocabularies = { ru, sp, latin };\nconst reLorem = /^lorem([a-z]*)(\\d*)(-\\d*)?$/i;\nfunction lorem(node, ancestors, config) {\n    let m;\n    if (node.name && (m = node.name.match(reLorem))) {\n        const db = vocabularies[m[1]] || vocabularies.latin;\n        const minWordCount = m[2] ? Math.max(1, Number(m[2])) : 30;\n        const maxWordCount = m[3] ? Math.max(minWordCount, Number(m[3].slice(1))) : minWordCount;\n        const wordCount = rand(minWordCount, maxWordCount);\n        const repeat = node.repeat || findRepeater(ancestors);\n        node.name = node.attributes = void 0;\n        node.value = [paragraph(db, wordCount, !repeat || repeat.value === 0)];\n        if (node.repeat && ancestors.length > 1) {\n            resolveImplicitTag(node, ancestors, config);\n        }\n    }\n}\n/**\n * Returns random integer between <code>from</code> and <code>to</code> values\n */\nfunction rand(from, to) {\n    return Math.floor(Math.random() * (to - from) + from);\n}\nfunction sample(arr, count) {\n    const len = arr.length;\n    const iterations = Math.min(len, count);\n    const result = [];\n    while (result.length < iterations) {\n        const str = arr[rand(0, len)];\n        if (!result.includes(str)) {\n            result.push(str);\n        }\n    }\n    return result;\n}\nfunction choice(val) {\n    return val[rand(0, val.length - 1)];\n}\nfunction sentence(words, end) {\n    if (words.length) {\n        words = [capitalize(words[0])].concat(words.slice(1));\n    }\n    return words.join(' ') + (end || choice('?!...')); // more dots than question marks\n}\nfunction capitalize(word) {\n    return word[0].toUpperCase() + word.slice(1);\n}\n/**\n * Insert commas at randomly selected words. This function modifies values\n * inside `words` array\n */\nfunction insertCommas(words) {\n    if (words.length < 2) {\n        return words;\n    }\n    words = words.slice();\n    const len = words.length;\n    const hasComma = /,$/;\n    let totalCommas = 0;\n    if (len > 3 && len <= 6) {\n        totalCommas = rand(0, 1);\n    }\n    else if (len > 6 && len <= 12) {\n        totalCommas = rand(0, 2);\n    }\n    else {\n        totalCommas = rand(1, 4);\n    }\n    for (let i = 0, pos; i < totalCommas; i++) {\n        pos = rand(0, len - 2);\n        if (!hasComma.test(words[pos])) {\n            words[pos] += ',';\n        }\n    }\n    return words;\n}\n/**\n * Generate a paragraph of \"Lorem ipsum\" text\n * @param dict Words dictionary\n * @param wordCount Words count in paragraph\n * @param startWithCommon Should paragraph start with common \"lorem ipsum\" sentence.\n */\nfunction paragraph(dict, wordCount, startWithCommon) {\n    const result = [];\n    let totalWords = 0;\n    let words;\n    if (startWithCommon && dict.common) {\n        words = dict.common.slice(0, wordCount);\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words), '.'));\n    }\n    while (totalWords < wordCount) {\n        words = sample(dict.words, Math.min(rand(2, 30), wordCount - totalWords));\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words)));\n    }\n    return result.join(' ');\n}\nfunction findRepeater(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const element = ancestors[i];\n        if (element.type === 'AbbreviationNode' && element.repeat) {\n            return element.repeat;\n        }\n    }\n}\n\n/**\n * JSX transformer: replaces `class` and `for` attributes with `className` and\n * `htmlFor` attributes respectively\n */\nfunction jsx(node) {\n    if (node.attributes) {\n        node.attributes.forEach(rename);\n    }\n}\nfunction rename(attr) {\n    if (attr.name === 'class') {\n        attr.name = 'className';\n    }\n    else if (attr.name === 'for') {\n        attr.name = 'htmlFor';\n    }\n}\n\n/**\n * XSL transformer: removes `select` attributes from certain nodes that contain\n * children\n */\nfunction xsl(node) {\n    if (matchesName(node.name) && node.attributes && (node.children.length || node.value)) {\n        node.attributes = node.attributes.filter(isAllowed);\n    }\n}\nfunction isAllowed(attr) {\n    return attr.name !== 'select';\n}\nfunction matchesName(name) {\n    return name === 'xsl:variable' || name === 'xsl:with-param';\n}\n\nconst reElement = /^(-+)([a-z0-9]+[a-z0-9-]*)/i;\nconst reModifier = /^(_+)([a-z0-9]+[a-z0-9-_]*)/i;\nconst blockCandidates1 = (className) => /^[a-z]\\-/i.test(className);\nconst blockCandidates2 = (className) => /^[a-z]/i.test(className);\nfunction bem(node, ancestors, config) {\n    expandClassNames(node);\n    expandShortNotation(node, ancestors, config);\n}\n/**\n * Expands existing class names in BEM notation in given `node`.\n * For example, if node contains `b__el_mod` class name, this method ensures\n * that element contains `b__el` class as well\n */\nfunction expandClassNames(node) {\n    const data = getBEMData(node);\n    const classNames = [];\n    for (const cl of data.classNames) {\n        // remove all modifiers and element prefixes from class name to get a base element name\n        const ix = cl.indexOf('_');\n        if (ix > 0 && !cl.startsWith('-')) {\n            classNames.push(cl.slice(0, ix));\n            classNames.push(cl.slice(ix));\n        }\n        else {\n            classNames.push(cl);\n        }\n    }\n    if (classNames.length) {\n        data.classNames = classNames.filter(uniqueClass);\n        data.block = findBlockName(data.classNames);\n        updateClass(node, data.classNames.join(' '));\n    }\n}\n/**\n * Expands short BEM notation, e.g. `-element` and `_modifier`\n */\nfunction expandShortNotation(node, ancestors, config) {\n    const data = getBEMData(node);\n    const classNames = [];\n    const { options } = config;\n    const path = ancestors.slice(1).concat(node);\n    for (let cl of data.classNames) {\n        let prefix = '';\n        let m;\n        const originalClass = cl;\n        // parse element definition (could be only one)\n        if (m = cl.match(reElement)) {\n            prefix = getBlockName(path, m[1].length, config.context) + options['bem.element'] + m[2];\n            classNames.push(prefix);\n            cl = cl.slice(m[0].length);\n        }\n        // parse modifiers definitions\n        if (m = cl.match(reModifier)) {\n            if (!prefix) {\n                prefix = getBlockName(path, m[1].length);\n                classNames.push(prefix);\n            }\n            classNames.push(`${prefix}${options['bem.modifier']}${m[2]}`);\n            cl = cl.slice(m[0].length);\n        }\n        if (cl === originalClass) {\n            // class name wasnt modified: its not a BEM-specific class,\n            // add it as-is into output\n            classNames.push(originalClass);\n        }\n    }\n    const arrClassNames = classNames.filter(uniqueClass);\n    if (arrClassNames.length) {\n        updateClass(node, arrClassNames.join(' '));\n    }\n}\n/**\n * Returns BEM data from given abbreviation node\n */\nfunction getBEMData(node) {\n    if (!node._bem) {\n        let classValue = '';\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (attr.name === 'class' && attr.value) {\n                    classValue = stringifyValue(attr.value);\n                    break;\n                }\n            }\n        }\n        node._bem = parseBEM(classValue);\n    }\n    return node._bem;\n}\nfunction getBEMDataFromContext(context) {\n    if (!context._bem) {\n        context._bem = parseBEM(context.attributes && context.attributes.class || '');\n    }\n    return context._bem;\n}\n/**\n * Parses BEM data from given class name\n */\nfunction parseBEM(classValue) {\n    const classNames = classValue ? classValue.split(/\\s+/) : [];\n    return {\n        classNames,\n        block: findBlockName(classNames)\n    };\n}\n/**\n * Returns block name for given `node` by `prefix`, which tells the depth of\n * of parent node lookup\n */\nfunction getBlockName(ancestors, depth = 0, context) {\n    const maxParentIx = 0;\n    let parentIx = Math.max(ancestors.length - depth, maxParentIx);\n    do {\n        const parent = ancestors[parentIx];\n        if (parent) {\n            const data = getBEMData(parent);\n            if (data.block) {\n                return data.block;\n            }\n        }\n    } while (maxParentIx < parentIx--);\n    if (context) {\n        const data = getBEMDataFromContext(context);\n        if (data.block) {\n            return data.block;\n        }\n    }\n    return '';\n}\nfunction findBlockName(classNames) {\n    return find(classNames, blockCandidates1)\n        || find(classNames, blockCandidates2)\n        || void 0;\n}\n/**\n * Finds class name from given list which may be used as block name\n */\nfunction find(classNames, filter) {\n    for (const cl of classNames) {\n        if (reElement.test(cl) || reModifier.test(cl)) {\n            break;\n        }\n        if (filter(cl)) {\n            return cl;\n        }\n    }\n}\nfunction updateClass(node, value) {\n    for (const attr of node.attributes) {\n        if (attr.name === 'class') {\n            attr.value = [value];\n            break;\n        }\n    }\n}\nfunction stringifyValue(value) {\n    let result = '';\n    for (const t of value) {\n        result += typeof t === 'string' ? t : t.name;\n    }\n    return result;\n}\nfunction uniqueClass(item, ix, arr) {\n    return !!item && arr.indexOf(item) === ix;\n}\n\nfunction walk$1(abbr, visitor, state) {\n    const callback = (ctx, index, items) => {\n        const { parent, current } = state;\n        state.parent = current;\n        state.current = ctx;\n        visitor(ctx, index, items, state, next);\n        state.current = current;\n        state.parent = parent;\n    };\n    const next = (node, index, items) => {\n        state.ancestors.push(state.current);\n        callback(node, index, items);\n        state.ancestors.pop();\n    };\n    abbr.children.forEach(callback);\n}\nfunction createWalkState(config) {\n    return {\n        // @ts-ignore: Will set value in iterator\n        current: null,\n        parent: void 0,\n        ancestors: [],\n        config,\n        field: 1,\n        out: createOutputStream(config.options)\n    };\n}\n\nconst caret = [{ type: 'Field', index: 0, name: '' }];\n/**\n * Check if given node is a snippet: a node without name and attributes\n */\nfunction isSnippet(node) {\n    return node ? !node.name && !node.attributes : false;\n}\n/**\n * Check if given node is inline-level element, e.g. element with explicitly\n * defined node name\n */\nfunction isInlineElement(node, config) {\n    return node ? isInline(node, config) : false;\n}\n/**\n * Check if given value token is a field\n */\nfunction isField(token) {\n    return typeof token === 'object' && token.type === 'Field';\n}\nfunction pushTokens(tokens, state) {\n    const { out } = state;\n    let largestIndex = -1;\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            pushString(out, t);\n        }\n        else {\n            pushField(out, state.field + t.index, t.name);\n            if (t.index > largestIndex) {\n                largestIndex = t.index;\n            }\n        }\n    }\n    if (largestIndex !== -1) {\n        state.field += largestIndex + 1;\n    }\n}\n/**\n * Splits given value token by lines: returns array where each entry is a token list\n * for a single line\n */\nfunction splitByLines$1(tokens) {\n    const result = [];\n    let line = [];\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            const lines = t.split(/\\r\\n?|\\n/g);\n            line.push(lines.shift() || '');\n            while (lines.length) {\n                result.push(line);\n                line = [lines.shift() || ''];\n            }\n        }\n        else {\n            line.push(t);\n        }\n    }\n    line.length && result.push(line);\n    return result;\n}\n/**\n * Check if given attribute should be outputted\n */\nfunction shouldOutputAttribute(attr) {\n    // In case if attribute is implied, check if it has a defined value:\n    // either non-empty value or quoted empty value\n    return !attr.implied || attr.valueType !== 'raw' || (!!attr.value && attr.value.length > 0);\n}\n\n/**\n * Splits given string into template tokens.\n * Template is a string which contains placeholders which are uppercase names\n * between `[` and `]`, for example: `[PLACEHOLDER]`.\n * Unlike other templates, a placeholder may contain extra characters before and\n * after name: `[%PLACEHOLDER.]`. If data for `PLACEHOLDER` is defined, it will\n * be outputted with with these extra character, otherwise will be completely omitted.\n */\nfunction template(text) {\n    const tokens = [];\n    const scanner = { pos: 0, text };\n    let placeholder;\n    let offset = scanner.pos;\n    let pos = scanner.pos;\n    while (scanner.pos < scanner.text.length) {\n        pos = scanner.pos;\n        if (placeholder = consumePlaceholder(scanner)) {\n            if (offset !== scanner.pos) {\n                tokens.push(text.slice(offset, pos));\n            }\n            tokens.push(placeholder);\n            offset = scanner.pos;\n        }\n        else {\n            scanner.pos++;\n        }\n    }\n    if (offset !== scanner.pos) {\n        tokens.push(text.slice(offset));\n    }\n    return tokens;\n}\n/**\n * Consumes placeholder like `[#ID]` from given scanner\n */\nfunction consumePlaceholder(scanner) {\n    if (peek(scanner) === 91 /* Start */) {\n        const start = ++scanner.pos;\n        let namePos = start;\n        let afterPos = start;\n        let stack = 1;\n        while (scanner.pos < scanner.text.length) {\n            const code = peek(scanner);\n            if (isTokenStart(code)) {\n                namePos = scanner.pos;\n                while (isToken(peek(scanner))) {\n                    scanner.pos++;\n                }\n                afterPos = scanner.pos;\n            }\n            else {\n                if (code === 91 /* Start */) {\n                    stack++;\n                }\n                else if (code === 93 /* End */) {\n                    if (--stack === 0) {\n                        return {\n                            before: scanner.text.slice(start, namePos),\n                            after: scanner.text.slice(afterPos, scanner.pos++),\n                            name: scanner.text.slice(namePos, afterPos)\n                        };\n                    }\n                }\n                scanner.pos++;\n            }\n        }\n    }\n}\nfunction peek(scanner, pos = scanner.pos) {\n    return scanner.text.charCodeAt(pos);\n}\nfunction isTokenStart(code) {\n    return code >= 65 && code <= 90; // A-Z\n}\nfunction isToken(code) {\n    return isTokenStart(code)\n        || (code > 47 && code < 58) /* 0-9 */\n        || code === 95 /* Underscore */\n        || code === 45 /* Dash */;\n}\n\nfunction createCommentState(config) {\n    const { options } = config;\n    return {\n        enabled: options['comment.enabled'],\n        trigger: options['comment.trigger'],\n        before: options['comment.before'] ? template(options['comment.before']) : void 0,\n        after: options['comment.after'] ? template(options['comment.after']) : void 0\n    };\n}\n/**\n * Adds comment prefix for given node, if required\n */\nfunction commentNodeBefore(node, state) {\n    if (shouldComment(node, state) && state.comment.before) {\n        output(node, state.comment.before, state);\n    }\n}\n/**\n * Adds comment suffix for given node, if required\n */\nfunction commentNodeAfter(node, state) {\n    if (shouldComment(node, state) && state.comment.after) {\n        output(node, state.comment.after, state);\n    }\n}\n/**\n * Check if given node should be commented\n */\nfunction shouldComment(node, state) {\n    const { comment } = state;\n    if (!comment.enabled || !comment.trigger || !node.name || !node.attributes) {\n        return false;\n    }\n    for (const attr of node.attributes) {\n        if (attr.name && comment.trigger.includes(attr.name)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Pushes given template tokens into output stream\n */\nfunction output(node, tokens, state) {\n    const attrs = {};\n    const { out } = state;\n    // Collect attributes payload\n    for (const attr of node.attributes) {\n        if (attr.name && attr.value) {\n            attrs[attr.name.toUpperCase()] = attr.value;\n        }\n    }\n    // Output parsed tokens\n    for (const token of tokens) {\n        if (typeof token === 'string') {\n            pushString(out, token);\n        }\n        else if (attrs[token.name]) {\n            pushString(out, token.before);\n            pushTokens(attrs[token.name], state);\n            pushString(out, token.after);\n        }\n    }\n}\n\nconst htmlTagRegex = /^<([\\w\\-:]+)[\\s>]/;\nfunction html(abbr, config) {\n    const state = createWalkState(config);\n    state.comment = createCommentState(config);\n    walk$1(abbr, element, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`s siblings\n * @param state Current walk state\n */\nfunction element(node, index, items, state, next) {\n    const { out, config } = state;\n    const format = shouldFormat(node, index, items, state);\n    // Pick offset level for current node\n    const level = getIndent(state);\n    out.level += level;\n    format && pushNewline(out, true);\n    if (node.name) {\n        const name = tagName(node.name, config);\n        commentNodeBefore(node, state);\n        pushString(out, `<${name}`);\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (shouldOutputAttribute(attr)) {\n                    pushAttribute(attr, state);\n                }\n            }\n        }\n        if (node.selfClosing && !node.children.length && !node.value) {\n            pushString(out, `${selfClose(config)}>`);\n        }\n        else {\n            pushString(out, '>');\n            if (!pushSnippet(node, state, next)) {\n                if (node.value) {\n                    const innerFormat = node.value.some(hasNewline) || startsWithBlockTag(node.value, config);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(node.value, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n                node.children.forEach(next);\n                if (!node.value && !node.children.length) {\n                    const innerFormat = config.options['output.formatLeafNode']\n                        || config.options['output.formatForce'].includes(node.name);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(caret, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n            }\n            pushString(out, `</${name}>`);\n            commentNodeAfter(node, state);\n        }\n    }\n    else if (!pushSnippet(node, state, next) && node.value) {\n        // A text-only node (snippet)\n        pushTokens(node.value, state);\n        node.children.forEach(next);\n    }\n    if (format && index === items.length - 1 && state.parent) {\n        const offset = isSnippet(state.parent) ? 0 : 1;\n        pushNewline(out, out.level - offset);\n    }\n    out.level -= level;\n}\n/**\n * Outputs given attributes content into output stream\n */\nfunction pushAttribute(attr, state) {\n    const { out, config } = state;\n    if (attr.name) {\n        const name = attrName(attr.name, config);\n        const lQuote = attrQuote(attr, config, true);\n        const rQuote = attrQuote(attr, config);\n        let value = attr.value;\n        if (isBooleanAttribute(attr, config) && !value) {\n            // If attribute value is omitted and its a boolean value, check for\n            // `compactBoolean` option: if its disabled, set value to attribute name\n            // (XML style)\n            if (!config.options['output.compactBoolean']) {\n                value = [name];\n            }\n        }\n        else if (!value) {\n            value = caret;\n        }\n        pushString(out, ' ' + name);\n        if (value) {\n            pushString(out, '=' + lQuote);\n            pushTokens(value, state);\n            pushString(out, rQuote);\n        }\n        else if (config.options['output.selfClosingStyle'] !== 'html') {\n            pushString(out, '=' + lQuote + rQuote);\n        }\n    }\n}\nfunction pushSnippet(node, state, next) {\n    if (node.value && node.children.length) {\n        // We have a value and child nodes. In case if value contains fields,\n        // we should output children as a content of first field\n        const fieldIx = node.value.findIndex(isField);\n        if (fieldIx !== -1) {\n            pushTokens(node.value.slice(0, fieldIx), state);\n            const line = state.out.line;\n            let pos = fieldIx + 1;\n            node.children.forEach(next);\n            // If there was a line change, trim leading whitespace for better result\n            if (state.out.line !== line && typeof node.value[pos] === 'string') {\n                pushString(state.out, node.value[pos++].trimLeft());\n            }\n            pushTokens(node.value.slice(pos), state);\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Check if given node should be formatted in its parent context\n */\nfunction shouldFormat(node, index, items, state) {\n    const { config, parent } = state;\n    if (!config.options['output.format']) {\n        return false;\n    }\n    if (index === 0 && !parent) {\n        // Do not format very first node\n        return false;\n    }\n    // Do not format single child of snippet\n    if (parent && isSnippet(parent) && items.length === 1) {\n        return false;\n    }\n    /**\n     * Adjacent text-only/snippet nodes\n     */\n    if (isSnippet(node)) {\n        // Adjacent text-only/snippet nodes\n        const format = isSnippet(items[index - 1]) || isSnippet(items[index + 1])\n            // Has newlines: looks like wrapping code fragment\n            || node.value.some(hasNewline)\n            // Format as wrapper: contains children which will be outputted as field content\n            || (node.value.some(isField) && node.children.length);\n        if (format) {\n            return true;\n        }\n    }\n    if (isInline(node, config)) {\n        // Check if inline node is the next sibling of block-level node\n        if (index === 0) {\n            // First node in parent: format if its followed by a block-level element\n            for (let i = 0; i < items.length; i++) {\n                if (!isInline(items[i], config)) {\n                    return true;\n                }\n            }\n        }\n        else if (!isInline(items[index - 1], config)) {\n            // Node is right after block-level element\n            return true;\n        }\n        if (config.options['output.inlineBreak']) {\n            // check for adjacent inline elements before and after current element\n            let adjacentInline = 1;\n            let before = index;\n            let after = index;\n            while (isInlineElement(items[--before], config)) {\n                adjacentInline++;\n            }\n            while (isInlineElement(items[++after], config)) {\n                adjacentInline++;\n            }\n            if (adjacentInline >= config.options['output.inlineBreak']) {\n                return true;\n            }\n        }\n        // Edge case: inline node contains node that should receive formatting\n        for (let i = 0, il = node.children.length; i < il; i++) {\n            if (shouldFormat(node.children[i], i, node.children, state)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    return true;\n}\n/**\n * Returns indentation offset for given node\n */\nfunction getIndent(state) {\n    const { config, parent } = state;\n    if (!parent || isSnippet(parent) || (parent.name && config.options['output.formatSkip'].includes(parent.name))) {\n        return 0;\n    }\n    return 1;\n}\n/**\n * Check if given node value contains newlines\n */\nfunction hasNewline(value) {\n    return typeof value === 'string' && /\\r|\\n/.test(value);\n}\n/**\n * Check if given node value starts with block-level tag\n */\nfunction startsWithBlockTag(value, config) {\n    if (value.length && typeof value[0] === 'string') {\n        const matches = htmlTagRegex.exec(value[0]);\n        if ((matches === null || matches === void 0 ? void 0 : matches.length) && !config.options['inlineElements'].includes(matches[1].toLowerCase())) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction indentFormat(abbr, config, options) {\n    const state = createWalkState(config);\n    state.options = options || {};\n    walk$1(abbr, element$1, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`s siblings\n * @param state Current walk state\n */\nfunction element$1(node, index, items, state, next) {\n    const { out, options } = state;\n    const { primary, secondary } = collectAttributes(node);\n    // Pick offset level for current node\n    const level = state.parent ? 1 : 0;\n    out.level += level;\n    // Do not indent top-level elements\n    if (shouldFormat$1(node, index, items, state)) {\n        pushNewline(out, true);\n    }\n    if (node.name && (node.name !== 'div' || !primary.length)) {\n        pushString(out, (options.beforeName || '') + node.name + (options.afterName || ''));\n    }\n    pushPrimaryAttributes(primary, state);\n    pushSecondaryAttributes(secondary.filter(shouldOutputAttribute), state);\n    if (node.selfClosing && !node.value && !node.children.length) {\n        if (state.options.selfClose) {\n            pushString(out, state.options.selfClose);\n        }\n    }\n    else {\n        pushValue(node, state);\n        node.children.forEach(next);\n    }\n    out.level -= level;\n}\n/**\n * From given node, collects all attributes as `primary` (id, class) and\n * `secondary` (all the rest) lists. In most indent-based syntaxes, primary attribute\n * has special syntax\n */\nfunction collectAttributes(node) {\n    const primary = [];\n    const secondary = [];\n    if (node.attributes) {\n        for (const attr of node.attributes) {\n            if (isPrimaryAttribute(attr)) {\n                primary.push(attr);\n            }\n            else {\n                secondary.push(attr);\n            }\n        }\n    }\n    return { primary, secondary };\n}\n/**\n * Outputs given attributes as primary into output stream\n */\nfunction pushPrimaryAttributes(attrs, state) {\n    for (const attr of attrs) {\n        if (attr.value) {\n            if (attr.name === 'class') {\n                pushString(state.out, '.');\n                // All whitespace characters must be replaced with dots in class names\n                const tokens = attr.value.map(t => typeof t === 'string' ? t.replace(/\\s+/g, '.') : t);\n                pushTokens(tokens, state);\n            }\n            else {\n                // ID attribute\n                pushString(state.out, '#');\n                pushTokens(attr.value, state);\n            }\n        }\n    }\n}\n/**\n * Outputs given attributes as secondary into output stream\n */\nfunction pushSecondaryAttributes(attrs, state) {\n    if (attrs.length) {\n        const { out, config, options } = state;\n        options.beforeAttribute && pushString(out, options.beforeAttribute);\n        for (let i = 0; i < attrs.length; i++) {\n            const attr = attrs[i];\n            pushString(out, attrName(attr.name || '', config));\n            if (isBooleanAttribute(attr, config) && !attr.value) {\n                if (!config.options['output.compactBoolean'] && options.booleanValue) {\n                    pushString(out, '=' + options.booleanValue);\n                }\n            }\n            else {\n                pushString(out, '=' + attrQuote(attr, config, true));\n                pushTokens(attr.value || caret, state);\n                pushString(out, attrQuote(attr, config));\n            }\n            if (i !== attrs.length - 1 && options.glueAttribute) {\n                pushString(out, options.glueAttribute);\n            }\n        }\n        options.afterAttribute && pushString(out, options.afterAttribute);\n    }\n}\n/**\n * Outputs given node value into state output stream\n */\nfunction pushValue(node, state) {\n    // We should either output value or add caret but for leaf nodes only (no children)\n    if (!node.value && node.children.length) {\n        return;\n    }\n    const value = node.value || caret;\n    const lines = splitByLines$1(value);\n    const { out, options } = state;\n    if (lines.length === 1) {\n        if (node.name || node.attributes) {\n            push(out, ' ');\n        }\n        pushTokens(value, state);\n    }\n    else {\n        // We should format multi-line value with terminating `|` character\n        // and same line length\n        const lineLengths = [];\n        let maxLength = 0;\n        // Calculate lengths of all lines and max line length\n        for (const line of lines) {\n            const len = valueLength(line);\n            lineLengths.push(len);\n            if (len > maxLength) {\n                maxLength = len;\n            }\n        }\n        // Output each line, padded to max length\n        out.level++;\n        for (let i = 0; i < lines.length; i++) {\n            pushNewline(out, true);\n            options.beforeTextLine && push(out, options.beforeTextLine);\n            pushTokens(lines[i], state);\n            if (options.afterTextLine) {\n                push(out, ' '.repeat(maxLength - lineLengths[i]));\n                push(out, options.afterTextLine);\n            }\n        }\n        out.level--;\n    }\n}\nfunction isPrimaryAttribute(attr) {\n    return attr.name === 'class' || attr.name === 'id';\n}\n/**\n * Calculates string length from given tokens\n */\nfunction valueLength(tokens) {\n    let len = 0;\n    for (const token of tokens) {\n        len += typeof token === 'string' ? token.length : token.name.length;\n    }\n    return len;\n}\nfunction shouldFormat$1(node, index, items, state) {\n    // Do not format first top-level element or snippets\n    if (!state.parent && index === 0) {\n        return false;\n    }\n    return !isSnippet(node);\n}\n\nfunction haml(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeName: '%',\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ' ',\n        afterTextLine: ' |',\n        booleanValue: 'true',\n        selfClose: '/'\n    });\n}\n\nfunction slim(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: ' ',\n        glueAttribute: ' ',\n        beforeTextLine: '| ',\n        selfClose: '/'\n    });\n}\n\nfunction pug(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ', ',\n        beforeTextLine: '| ',\n        selfClose: config.options['output.selfClosingStyle'] === 'xml' ? '/' : ''\n    });\n}\n\nconst formatters = { html, haml, slim, pug };\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse(abbr, config) {\n    let oldTextValue;\n    if (typeof abbr === 'string') {\n        let parseOpt = config;\n        if (config.options['jsx.enabled']) {\n            parseOpt = Object.assign(Object.assign({}, parseOpt), { jsx: true });\n        }\n        if (config.options['markup.href']) {\n            parseOpt = Object.assign(Object.assign({}, parseOpt), { href: true });\n        }\n        abbr = parseAbbreviation(abbr, parseOpt);\n        // remove text field before snippets(abbr, config) call\n        // as abbreviation(abbr, parseOpt) already handled it\n        oldTextValue = config.text;\n        config.text = undefined;\n    }\n    // Run abbreviation resolve in two passes:\n    // 1. Map each node to snippets, which are abbreviations as well. A single snippet\n    // may produce multiple nodes\n    // 2. Transform every resolved node\n    abbr = resolveSnippets(abbr, config);\n    walk(abbr, transform, config);\n    config.text = oldTextValue !== null && oldTextValue !== void 0 ? oldTextValue : config.text;\n    return abbr;\n}\n/**\n * Converts given abbreviation to string according to provided `config`\n */\nfunction stringify(abbr, config) {\n    const formatter = formatters[config.syntax] || html;\n    return formatter(abbr, config);\n}\n/**\n * Modifies given node and prepares it for output\n */\nfunction transform(node, ancestors, config) {\n    implicitTag(node, ancestors, config);\n    mergeAttributes(node, config);\n    lorem(node, ancestors, config);\n    if (config.syntax === 'xsl') {\n        xsl(node);\n    }\n    if (config.options['jsx.enabled']) {\n        jsx(node);\n    }\n    if (config.options['bem.enabled']) {\n        bem(node, ancestors, config);\n    }\n}\n\nconst reProperty = /^([a-z-]+)(?:\\s*:\\s*([^\\n\\r;]+?);*)?$/;\nconst opt = { value: true };\n/**\n * Creates structure for holding resolved CSS snippet\n */\nfunction createSnippet(key, value) {\n    // A snippet could be a raw text snippet (e.g. arbitrary text string) or a\n    // CSS property with possible values separated by `|`.\n    // In latter case, we have to parse snippet as CSS abbreviation\n    const m = value.match(reProperty);\n    if (m) {\n        const keywords = {};\n        const parsed = m[2] ? m[2].split('|').map(parseValue) : [];\n        for (const item of parsed) {\n            for (const cssVal of item) {\n                collectKeywords(cssVal, keywords);\n            }\n        }\n        return {\n            type: \"Property\" /* Property */,\n            key,\n            property: m[1],\n            value: parsed,\n            keywords,\n            dependencies: []\n        };\n    }\n    return { type: \"Raw\" /* Raw */, key, value };\n}\n/**\n * Nests more specific CSS properties into shorthand ones, e.g.\n * `background-position-x` -> `background-position` -> `background`\n */\nfunction nest(snippets) {\n    snippets = snippets.slice().sort(snippetsSort);\n    const stack = [];\n    let prev;\n    // For sorted list of CSS properties, create dependency graph where each\n    // shorthand property contains its more specific one, e.g.\n    // background -> background-position -> background-position-x\n    for (const cur of snippets.filter(isProperty)) {\n        // Check if current property belongs to one from parent stack.\n        // Since `snippets` array is sorted, items are perfectly aligned\n        // from shorthands to more specific variants\n        while (stack.length) {\n            prev = stack[stack.length - 1];\n            if (cur.property.startsWith(prev.property)\n                && cur.property.charCodeAt(prev.property.length) === 45 /* - */) {\n                prev.dependencies.push(cur);\n                stack.push(cur);\n                break;\n            }\n            stack.pop();\n        }\n        if (!stack.length) {\n            stack.push(cur);\n        }\n    }\n    return snippets;\n}\n/**\n * A sorting function for array of snippets\n */\nfunction snippetsSort(a, b) {\n    if (a.key === b.key) {\n        return 0;\n    }\n    return a.key < b.key ? -1 : 1;\n}\nfunction parseValue(value) {\n    return parse$2(value.trim(), opt)[0].value;\n}\nfunction isProperty(snippet) {\n    return snippet.type === \"Property\" /* Property */;\n}\nfunction collectKeywords(cssVal, dest) {\n    for (const v of cssVal.value) {\n        if (v.type === 'Literal') {\n            dest[v.value] = v;\n        }\n        else if (v.type === 'FunctionCall') {\n            dest[v.name] = v;\n        }\n        else if (v.type === 'Field') {\n            // Create literal from field, if available\n            const value = v.name.trim();\n            if (value) {\n                dest[value] = { type: 'Literal', value };\n            }\n        }\n    }\n}\n\n/**\n * Calculates how close `str1` matches `str2` using fuzzy match.\n * How matching works:\n *  first characters of both `str1` and `str2` *must* match\n *  `str1` length larger than `str2` length is allowed only when `unmatched` is true\n *  ideal match is when `str1` equals to `str2` (score: 1)\n *  next best match is `str2` starts with `str1` (score: 1  percent of matched characters)\n *  other scores depend on how close characters of `str1` to the beginning of `str2`\n * @param partialMatch Allow length `str1` to be greater than `str2` length\n */\nfunction scoreMatch(str1, str2, partialMatch = false) {\n    str1 = str1.toLowerCase();\n    str2 = str2.toLowerCase();\n    if (str1 === str2) {\n        return 1;\n    }\n    // Both strings MUST start with the same character\n    if (!str1 || !str2 || str1.charCodeAt(0) !== str2.charCodeAt(0)) {\n        return 0;\n    }\n    const str1Len = str1.length;\n    const str2Len = str2.length;\n    if (!partialMatch && str1Len > str2Len) {\n        return 0;\n    }\n    // Characters from `str1` which are closer to the beginning of a `str2` should\n    // have higher score.\n    // For example, if `str2` is `abcde`, its max score is:\n    // 5 + 4 + 3 + 2 + 1 = 15 (sum of character positions in reverse order)\n    // Matching `abd` against `abcde` should produce:\n    // 5 + 4 + 2 = 11\n    // Acronym bonus for match right after `-`. Matching `abd` against `abc-de`\n    // should produce:\n    // 6 + 5 + 4 (use `d` position in `abd`, not in abc-de`)\n    const minLength = Math.min(str1Len, str2Len);\n    const maxLength = Math.max(str1Len, str2Len);\n    let i = 1;\n    let j = 1;\n    let score = maxLength;\n    let ch1 = 0;\n    let ch2 = 0;\n    let found = false;\n    let acronym = false;\n    while (i < str1Len) {\n        ch1 = str1.charCodeAt(i);\n        found = false;\n        acronym = false;\n        while (j < str2Len) {\n            ch2 = str2.charCodeAt(j);\n            if (ch1 === ch2) {\n                found = true;\n                score += maxLength - (acronym ? i : j);\n                break;\n            }\n            // add acronym bonus for exactly next match after unmatched `-`\n            acronym = ch2 === 45 /* - */;\n            j++;\n        }\n        if (!found) {\n            if (!partialMatch) {\n                return 0;\n            }\n            break;\n        }\n        i++;\n    }\n    const matchRatio = i / maxLength;\n    const delta = maxLength - minLength;\n    const maxScore = sum(maxLength) - sum(delta);\n    return (score * matchRatio) / maxScore;\n}\n/**\n * Calculates sum of first `n` numbers, e.g. 1+2+3+...n\n */\nfunction sum(n) {\n    return n * (n + 1) / 2;\n}\n\nfunction color(token, shortHex) {\n    if (!token.r && !token.g && !token.b && !token.a) {\n        return 'transparent';\n    }\n    else if (token.a === 1) {\n        return asHex(token, shortHex);\n    }\n    return asRGB(token);\n}\n/**\n * Output given color as hex value\n * @param short Produce short value (e.g. #fff instead of #ffffff), if possible\n */\nfunction asHex(token, short) {\n    const fn = (short && isShortHex(token.r) && isShortHex(token.g) && isShortHex(token.b))\n        ? toShortHex : toHex;\n    return '#' + fn(token.r) + fn(token.g) + fn(token.b);\n}\n/**\n * Output current color as `rgba?(...)` CSS color\n */\nfunction asRGB(token) {\n    const values = [token.r, token.g, token.b];\n    if (token.a !== 1) {\n        values.push(frac(token.a, 8));\n    }\n    return `${values.length === 3 ? 'rgb' : 'rgba'}(${values.join(', ')})`;\n}\nfunction frac(num, digits = 4) {\n    return num.toFixed(digits).replace(/\\.?0+$/, '');\n}\nfunction isShortHex(hex) {\n    return !(hex % 17);\n}\nfunction toShortHex(num) {\n    return (num >> 4).toString(16);\n}\nfunction toHex(num) {\n    return pad(num.toString(16), 2);\n}\nfunction pad(value, len) {\n    while (value.length < len) {\n        value = '0' + value;\n    }\n    return value;\n}\n\nfunction css(abbr, config) {\n    var _a;\n    const out = createOutputStream(config.options);\n    const format = config.options['output.format'];\n    if (((_a = config.context) === null || _a === void 0 ? void 0 : _a.name) === \"@@section\" /* Section */) {\n        // For section context, filter out unmatched snippets\n        abbr = abbr.filter(node => node.snippet);\n    }\n    for (let i = 0; i < abbr.length; i++) {\n        if (format && i !== 0) {\n            pushNewline(out, true);\n        }\n        property(abbr[i], out, config);\n    }\n    return out.value;\n}\n/**\n * Outputs given abbreviation node into output stream\n */\nfunction property(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    if (node.name) {\n        // Its a CSS property\n        const name = isJSON ? toCamelCase(node.name) : node.name;\n        pushString(out, name + config.options['stylesheet.between']);\n        if (node.value.length) {\n            propertyValue(node, out, config);\n        }\n        else {\n            pushField(out, 0, '');\n        }\n        if (isJSON) {\n            // For CSS-in-JS, always finalize property with comma\n            // NB: seems like `important` is not available in CSS-in-JS syntaxes\n            push(out, ',');\n        }\n        else {\n            outputImportant(node, out, true);\n            push(out, config.options['stylesheet.after']);\n        }\n    }\n    else {\n        // Its a regular snippet, output plain tokens without any additional formatting\n        for (const cssVal of node.value) {\n            for (const v of cssVal.value) {\n                outputToken(v, out, config);\n            }\n        }\n        outputImportant(node, out, node.value.length > 0);\n    }\n}\nfunction propertyValue(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    const num = isJSON ? getSingleNumeric(node) : null;\n    if (num && (!num.unit || num.unit === 'px')) {\n        // For CSS-in-JS, if property contains single numeric value, output it\n        // as JS number\n        push(out, String(num.value));\n    }\n    else {\n        const quote = getQuote(config);\n        isJSON && push(out, quote);\n        for (let i = 0; i < node.value.length; i++) {\n            if (i !== 0) {\n                push(out, ', ');\n            }\n            outputValue(node.value[i], out, config);\n        }\n        isJSON && push(out, quote);\n    }\n}\nfunction outputImportant(node, out, separator) {\n    if (node.important) {\n        if (separator) {\n            push(out, ' ');\n        }\n        push(out, '!important');\n    }\n}\nfunction outputValue(value, out, config) {\n    for (let i = 0, prevEnd = -1; i < value.value.length; i++) {\n        const token = value.value[i];\n        // Handle edge case: a field is written close to previous token like this: `foo${bar}`.\n        // We should not add delimiter here\n        if (i !== 0 && (token.type !== 'Field' || token.start !== prevEnd)) {\n            push(out, ' ');\n        }\n        outputToken(token, out, config);\n        prevEnd = token['end'];\n    }\n}\nfunction outputToken(token, out, config) {\n    if (token.type === 'ColorValue') {\n        push(out, color(token, config.options['stylesheet.shortHex']));\n    }\n    else if (token.type === 'Literal') {\n        pushString(out, token.value);\n    }\n    else if (token.type === 'NumberValue') {\n        pushString(out, frac(token.value, 4) + token.unit);\n    }\n    else if (token.type === 'StringValue') {\n        const quote = token.quote === 'double' ? '\"' : '\\'';\n        pushString(out, quote + token.value + quote);\n    }\n    else if (token.type === 'Field') {\n        pushField(out, token.index, token.name);\n    }\n    else if (token.type === 'FunctionCall') {\n        push(out, token.name + '(');\n        for (let i = 0; i < token.arguments.length; i++) {\n            if (i) {\n                push(out, ', ');\n            }\n            outputValue(token.arguments[i], out, config);\n        }\n        push(out, ')');\n    }\n}\n/**\n * If value of given property is a single numeric value, returns this token\n */\nfunction getSingleNumeric(node) {\n    if (node.value.length === 1) {\n        const cssVal = node.value[0];\n        if (cssVal.value.length === 1 && cssVal.value[0].type === 'NumberValue') {\n            return cssVal.value[0];\n        }\n    }\n}\n/**\n * Converts kebab-case string to camelCase\n */\nfunction toCamelCase(str) {\n    return str.replace(/\\-(\\w)/g, (_, letter) => letter.toUpperCase());\n}\nfunction getQuote(config) {\n    return config.options['stylesheet.jsonDoubleQuotes'] ? '\"' : '\\'';\n}\n\nconst gradientName = 'lg';\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse$1(abbr, config) {\n    var _a;\n    const snippets = ((_a = config.cache) === null || _a === void 0 ? void 0 : _a.stylesheetSnippets) || convertSnippets(config.snippets);\n    if (config.cache) {\n        config.cache.stylesheetSnippets = snippets;\n    }\n    if (typeof abbr === 'string') {\n        abbr = parse$2(abbr, { value: isValueScope(config) });\n    }\n    const filteredSnippets = getSnippetsForScope(snippets, config);\n    for (const node of abbr) {\n        resolveNode(node, filteredSnippets, config);\n    }\n    return abbr;\n}\n/**\n * Converts given raw snippets into internal snippets representation\n */\nfunction convertSnippets(snippets) {\n    const result = [];\n    for (const key of Object.keys(snippets)) {\n        result.push(createSnippet(key, snippets[key]));\n    }\n    return nest(result);\n}\n/**\n * Resolves given node: finds matched CSS snippets using fuzzy match and resolves\n * keyword aliases from node value\n */\nfunction resolveNode(node, snippets, config) {\n    if (!resolveGradient(node, config)) {\n        const score = config.options['stylesheet.fuzzySearchMinScore'];\n        if (isValueScope(config)) {\n            // Resolve as value of given CSS property\n            const propName = config.context.name;\n            const snippet = snippets.find(s => s.type === \"Property\" /* Property */ && s.property === propName);\n            resolveValueKeywords(node, config, snippet, score);\n            node.snippet = snippet;\n        }\n        else if (node.name) {\n            const snippet = findBestMatch(node.name, snippets, score, true);\n            node.snippet = snippet;\n            if (snippet) {\n                if (snippet.type === \"Property\" /* Property */) {\n                    resolveAsProperty(node, snippet, config);\n                }\n                else {\n                    resolveAsSnippet(node, snippet);\n                }\n            }\n        }\n    }\n    if (node.name || config.context) {\n        // Resolve numeric values for CSS properties only\n        resolveNumericValue(node, config);\n    }\n    return node;\n}\n/**\n * Resolves CSS gradient shortcut from given property, if possible\n */\nfunction resolveGradient(node, config) {\n    let gradientFn = null;\n    const cssVal = node.value.length === 1 ? node.value[0] : null;\n    if (cssVal && cssVal.value.length === 1) {\n        const v = cssVal.value[0];\n        if (v.type === 'FunctionCall' && v.name === gradientName) {\n            gradientFn = v;\n        }\n    }\n    if (gradientFn || node.name === gradientName) {\n        if (!gradientFn) {\n            gradientFn = {\n                type: 'FunctionCall',\n                name: 'linear-gradient',\n                arguments: [cssValue(field(0, ''))]\n            };\n        }\n        else {\n            gradientFn = Object.assign(Object.assign({}, gradientFn), { name: 'linear-gradient' });\n        }\n        if (!config.context) {\n            node.name = 'background-image';\n        }\n        node.value = [cssValue(gradientFn)];\n        return true;\n    }\n    return false;\n}\n/**\n * Resolves given parsed abbreviation node as CSS property\n */\nfunction resolveAsProperty(node, snippet, config) {\n    const abbr = node.name;\n    // Check for unmatched part of abbreviation\n    // For example, in `dib` abbreviation the matched part is `d` and `ib` should\n    // be considered as inline value. If unmatched fragment exists, we should check\n    // if it matches actual value of snippet. If either explicit value is specified\n    // or unmatched fragment did not resolve to to a keyword, we should consider\n    // matched snippet as invalid\n    const inlineValue = getUnmatchedPart(abbr, snippet.key);\n    if (inlineValue) {\n        if (node.value.length) {\n            // Already have value: unmatched part indicates matched snippet is invalid\n            return node;\n        }\n        const kw = resolveKeyword(inlineValue, config, snippet);\n        if (!kw) {\n            return node;\n        }\n        node.value.push(cssValue(kw));\n    }\n    node.name = snippet.property;\n    if (node.value.length) {\n        // Replace keyword alias from current abbreviation node with matched keyword\n        resolveValueKeywords(node, config, snippet);\n    }\n    else if (snippet.value.length) {\n        const defaultValue = snippet.value[0];\n        // https://github.com/emmetio/emmet/issues/558\n        // We should auto-select inserted value only if theres multiple value\n        // choice\n        node.value = snippet.value.length === 1 || defaultValue.some(hasField)\n            ? defaultValue\n            : defaultValue.map(n => wrapWithField(n, config));\n    }\n    return node;\n}\nfunction resolveValueKeywords(node, config, snippet, minScore) {\n    for (const cssVal of node.value) {\n        const value = [];\n        for (const token of cssVal.value) {\n            if (token.type === 'Literal') {\n                value.push(resolveKeyword(token.value, config, snippet, minScore) || token);\n            }\n            else if (token.type === 'FunctionCall') {\n                // For function calls, we should find matching function call\n                // and merge arguments\n                const match = resolveKeyword(token.name, config, snippet, minScore);\n                if (match && match.type === 'FunctionCall') {\n                    value.push(Object.assign(Object.assign({}, match), { arguments: token.arguments.concat(match.arguments.slice(token.arguments.length)) }));\n                }\n                else {\n                    value.push(token);\n                }\n            }\n            else {\n                value.push(token);\n            }\n        }\n        cssVal.value = value;\n    }\n}\n/**\n * Resolves given parsed abbreviation node as a snippet: a plain code chunk\n */\nfunction resolveAsSnippet(node, snippet) {\n    // When resolving snippets, we have to do the following:\n    // 1. Replace field placeholders with actual field tokens.\n    // 2. If input values given, put them instead of fields\n    let offset = 0;\n    let m;\n    const reField = /\\$\\{(\\d+)(:[^}]+)?\\}/g;\n    const inputValue = node.value[0];\n    const outputValue = [];\n    while (m = reField.exec(snippet.value)) {\n        if (offset !== m.index) {\n            outputValue.push(literal(snippet.value.slice(offset, m.index)));\n        }\n        offset = m.index + m[0].length;\n        if (inputValue && inputValue.value.length) {\n            outputValue.push(inputValue.value.shift());\n        }\n        else {\n            outputValue.push(field(Number(m[1]), m[2] ? m[2].slice(1) : ''));\n        }\n    }\n    const tail = snippet.value.slice(offset);\n    if (tail) {\n        outputValue.push(literal(tail));\n    }\n    node.name = void 0;\n    node.value = [cssValue(...outputValue)];\n    return node;\n}\n/**\n * Finds best matching item from `items` array\n * @param abbr  Abbreviation to match\n * @param items List of items for match\n * @param minScore The minimum score the best matched item should have to be a valid match.\n */\nfunction findBestMatch(abbr, items, minScore = 0, partialMatch = false) {\n    let matchedItem = null;\n    let maxScore = 0;\n    for (const item of items) {\n        const score = scoreMatch(abbr, getScoringPart(item), partialMatch);\n        if (score === 1) {\n            // direct hit, no need to look further\n            return item;\n        }\n        if (score && score >= maxScore) {\n            maxScore = score;\n            matchedItem = item;\n        }\n    }\n    return maxScore >= minScore ? matchedItem : null;\n}\nfunction getScoringPart(item) {\n    return typeof item === 'string' ? item : item.key;\n}\n/**\n * Returns a part of `abbr` that wasnt directly matched against `str`.\n * For example, if abbreviation `poas` is matched against `position`,\n * the unmatched part will be `as` since `a` wasnt found in string stream\n */\nfunction getUnmatchedPart(abbr, str) {\n    for (let i = 0, lastPos = 0; i < abbr.length; i++) {\n        lastPos = str.indexOf(abbr[i], lastPos);\n        if (lastPos === -1) {\n            return abbr.slice(i);\n        }\n        lastPos++;\n    }\n    return '';\n}\n/**\n * Resolves given keyword shorthand into matched snippet keyword or global keyword,\n * if possible\n */\nfunction resolveKeyword(kw, config, snippet, minScore) {\n    let ref;\n    if (snippet) {\n        if (ref = findBestMatch(kw, Object.keys(snippet.keywords), minScore)) {\n            return snippet.keywords[ref];\n        }\n        for (const dep of snippet.dependencies) {\n            if (ref = findBestMatch(kw, Object.keys(dep.keywords), minScore)) {\n                return dep.keywords[ref];\n            }\n        }\n    }\n    if (ref = findBestMatch(kw, config.options['stylesheet.keywords'], minScore)) {\n        return literal(ref);\n    }\n    return null;\n}\n/**\n * Resolves numeric values in given abbreviation node\n */\nfunction resolveNumericValue(node, config) {\n    const aliases = config.options['stylesheet.unitAliases'];\n    const unitless = config.options['stylesheet.unitless'];\n    for (const v of node.value) {\n        for (const t of v.value) {\n            if (t.type === 'NumberValue') {\n                if (t.unit) {\n                    t.unit = aliases[t.unit] || t.unit;\n                }\n                else if (t.value !== 0 && !unitless.includes(node.name)) {\n                    t.unit = t.rawValue.includes('.')\n                        ? config.options['stylesheet.floatUnit']\n                        : config.options['stylesheet.intUnit'];\n                }\n            }\n        }\n    }\n}\n/**\n * Constructs CSS value token\n */\nfunction cssValue(...args) {\n    return {\n        type: 'CSSValue',\n        value: args\n    };\n}\n/**\n * Constructs literal token\n */\nfunction literal(value) {\n    return { type: 'Literal', value };\n}\n/**\n * Constructs field token\n */\nfunction field(index, name) {\n    return { type: 'Field', index, name };\n}\n/**\n * Check if given value contains fields\n */\nfunction hasField(value) {\n    for (const v of value.value) {\n        if (v.type === 'Field' || (v.type === 'FunctionCall' && v.arguments.some(hasField))) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Wraps tokens of given abbreviation with fields\n */\nfunction wrapWithField(node, config, state = { index: 1 }) {\n    let value = [];\n    for (const v of node.value) {\n        switch (v.type) {\n            case 'ColorValue':\n                value.push(field(state.index++, color(v, config.options['stylesheet.shortHex'])));\n                break;\n            case 'Literal':\n                value.push(field(state.index++, v.value));\n                break;\n            case 'NumberValue':\n                value.push(field(state.index++, `${v.value}${v.unit}`));\n                break;\n            case 'StringValue':\n                const q = v.quote === 'single' ? '\\'' : '\"';\n                value.push(field(state.index++, q + v.value + q));\n                break;\n            case 'FunctionCall':\n                value.push(field(state.index++, v.name), literal('('));\n                for (let i = 0, il = v.arguments.length; i < il; i++) {\n                    value = value.concat(wrapWithField(v.arguments[i], config, state).value);\n                    if (i !== il - 1) {\n                        value.push(literal(', '));\n                    }\n                }\n                value.push(literal(')'));\n                break;\n            default:\n                value.push(v);\n        }\n    }\n    return Object.assign(Object.assign({}, node), { value });\n}\n/**\n * Check if abbreviation should be expanded in CSS value context\n */\nfunction isValueScope(config) {\n    if (config.context) {\n        return config.context.name === \"@@value\" /* Value */ || !config.context.name.startsWith('@@');\n    }\n    return false;\n}\n/**\n * Returns snippets for given scope\n */\nfunction getSnippetsForScope(snippets, config) {\n    if (config.context) {\n        if (config.context.name === \"@@section\" /* Section */) {\n            return snippets.filter(s => s.type === \"Raw\" /* Raw */);\n        }\n        if (config.context.name === \"@@property\" /* Property */) {\n            return snippets.filter(s => s.type === \"Property\" /* Property */);\n        }\n    }\n    return snippets;\n}\n\nvar markupSnippets = {\n\t\"a\": \"a[href]\",\n\t\"a:blank\": \"a[href='http://${0}' target='_blank' rel='noopener noreferrer']\",\n\t\"a:link\": \"a[href='http://${0}']\",\n\t\"a:mail\": \"a[href='mailto:${0}']\",\n\t\"a:tel\": \"a[href='tel:+${0}']\",\n\t\"abbr\": \"abbr[title]\",\n\t\"acr|acronym\": \"acronym[title]\",\n\t\"base\": \"base[href]/\",\n\t\"basefont\": \"basefont/\",\n\t\"br\": \"br/\",\n\t\"frame\": \"frame/\",\n\t\"hr\": \"hr/\",\n\t\"bdo\": \"bdo[dir]\",\n\t\"bdo:r\": \"bdo[dir=rtl]\",\n\t\"bdo:l\": \"bdo[dir=ltr]\",\n\t\"col\": \"col/\",\n\t\"link\": \"link[rel=stylesheet href]/\",\n\t\"link:css\": \"link[href='${1:style}.css']\",\n\t\"link:print\": \"link[href='${1:print}.css' media=print]\",\n\t\"link:favicon\": \"link[rel='shortcut icon' type=image/x-icon href='${1:favicon.ico}']\",\n\t\"link:mf|link:manifest\": \"link[rel='manifest' href='${1:manifest.json}']\",\n\t\"link:touch\": \"link[rel=apple-touch-icon href='${1:favicon.png}']\",\n\t\"link:rss\": \"link[rel=alternate type=application/rss+xml title=RSS href='${1:rss.xml}']\",\n\t\"link:atom\": \"link[rel=alternate type=application/atom+xml title=Atom href='${1:atom.xml}']\",\n\t\"link:im|link:import\": \"link[rel=import href='${1:component}.html']\",\n\t\"meta\": \"meta/\",\n\t\"meta:utf\": \"meta[http-equiv=Content-Type content='text/html;charset=UTF-8']\",\n\t\"meta:vp\": \"meta[name=viewport content='width=${1:device-width}, initial-scale=${2:1.0}']\",\n\t\"meta:compat\": \"meta[http-equiv=X-UA-Compatible content='${1:IE=7}']\",\n\t\"meta:edge\": \"meta:compat[content='${1:ie=edge}']\",\n\t\"meta:redirect\": \"meta[http-equiv=refresh content='0; url=${1:http://example.com}']\",\n\t\"meta:kw\": \"meta[name=keywords content]\",\n\t\"meta:desc\": \"meta[name=description content]\",\n\t\"style\": \"style\",\n\t\"script\": \"script\",\n\t\"script:src\": \"script[src]\",\n\t\"img\": \"img[src alt]/\",\n\t\"img:s|img:srcset\": \"img[srcset src alt]\",\n\t\"img:z|img:sizes\": \"img[sizes srcset src alt]\",\n\t\"picture\": \"picture\",\n\t\"src|source\": \"source/\",\n\t\"src:sc|source:src\": \"source[src type]\",\n\t\"src:s|source:srcset\": \"source[srcset]\",\n\t\"src:t|source:type\": \"source[srcset type='${1:image/}']\",\n\t\"src:z|source:sizes\": \"source[sizes srcset]\",\n\t\"src:m|source:media\": \"source[media='(${1:min-width: })' srcset]\",\n\t\"src:mt|source:media:type\": \"source:media[type='${2:image/}']\",\n\t\"src:mz|source:media:sizes\": \"source:media[sizes srcset]\",\n\t\"src:zt|source:sizes:type\": \"source[sizes srcset type='${1:image/}']\",\n\t\"iframe\": \"iframe[src frameborder=0]\",\n\t\"embed\": \"embed[src type]/\",\n\t\"object\": \"object[data type]\",\n\t\"param\": \"param[name value]/\",\n\t\"map\": \"map[name]\",\n\t\"area\": \"area[shape coords href alt]/\",\n\t\"area:d\": \"area[shape=default]\",\n\t\"area:c\": \"area[shape=circle]\",\n\t\"area:r\": \"area[shape=rect]\",\n\t\"area:p\": \"area[shape=poly]\",\n\t\"form\": \"form[action]\",\n\t\"form:get\": \"form[method=get]\",\n\t\"form:post\": \"form[method=post]\",\n\t\"label\": \"label[for]\",\n\t\"input\": \"input[type=${1:text}]/\",\n\t\"inp\": \"input[name=${1} id=${1}]\",\n\t\"input:h|input:hidden\": \"input[type=hidden name]\",\n\t\"input:t|input:text\": \"inp[type=text]\",\n\t\"input:search\": \"inp[type=search]\",\n\t\"input:email\": \"inp[type=email]\",\n\t\"input:url\": \"inp[type=url]\",\n\t\"input:p|input:password\": \"inp[type=password]\",\n\t\"input:datetime\": \"inp[type=datetime]\",\n\t\"input:date\": \"inp[type=date]\",\n\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\"input:month\": \"inp[type=month]\",\n\t\"input:week\": \"inp[type=week]\",\n\t\"input:time\": \"inp[type=time]\",\n\t\"input:tel\": \"inp[type=tel]\",\n\t\"input:number\": \"inp[type=number]\",\n\t\"input:color\": \"inp[type=color]\",\n\t\"input:c|input:checkbox\": \"inp[type=checkbox]\",\n\t\"input:r|input:radio\": \"inp[type=radio]\",\n\t\"input:range\": \"inp[type=range]\",\n\t\"input:f|input:file\": \"inp[type=file]\",\n\t\"input:s|input:submit\": \"input[type=submit value]\",\n\t\"input:i|input:image\": \"input[type=image src alt]\",\n\t\"input:b|input:btn|input:button\": \"input[type=button value]\",\n\t\"input:reset\": \"input:button[type=reset]\",\n\t\"isindex\": \"isindex/\",\n\t\"select\": \"select[name=${1} id=${1}]\",\n\t\"select:d|select:disabled\": \"select[disabled.]\",\n\t\"opt|option\": \"option[value]\",\n\t\"textarea\": \"textarea[name=${1} id=${1} cols=${2:30} rows=${3:10}]\",\n\t\"marquee\": \"marquee[behavior direction]\",\n\t\"menu:c|menu:context\": \"menu[type=context]\",\n\t\"menu:t|menu:toolbar\": \"menu[type=toolbar]\",\n\t\"video\": \"video[src]\",\n\t\"audio\": \"audio[src]\",\n\t\"html:xml\": \"html[xmlns=http://www.w3.org/1999/xhtml]\",\n\t\"keygen\": \"keygen/\",\n\t\"command\": \"command/\",\n\t\"btn:s|button:s|button:submit\" : \"button[type=submit]\",\n\t\"btn:r|button:r|button:reset\" : \"button[type=reset]\",\n\t\"btn:d|button:d|button:disabled\" : \"button[disabled.]\",\n\t\"fst:d|fset:d|fieldset:d|fieldset:disabled\" : \"fieldset[disabled.]\",\n\n\t\"bq\": \"blockquote\",\n\t\"fig\": \"figure\",\n\t\"figc\": \"figcaption\",\n\t\"pic\": \"picture\",\n\t\"ifr\": \"iframe\",\n\t\"emb\": \"embed\",\n\t\"obj\": \"object\",\n\t\"cap\": \"caption\",\n\t\"colg\": \"colgroup\",\n\t\"fst\": \"fieldset\",\n\t\"btn\": \"button\",\n\t\"optg\": \"optgroup\",\n\t\"tarea\": \"textarea\",\n\t\"leg\": \"legend\",\n\t\"sect\": \"section\",\n\t\"art\": \"article\",\n\t\"hdr\": \"header\",\n\t\"ftr\": \"footer\",\n\t\"adr\": \"address\",\n\t\"dlg\": \"dialog\",\n\t\"str\": \"strong\",\n\t\"prog\": \"progress\",\n\t\"mn\": \"main\",\n\t\"tem\": \"template\",\n\t\"fset\": \"fieldset\",\n\t\"datag\": \"datagrid\",\n\t\"datal\": \"datalist\",\n\t\"kg\": \"keygen\",\n\t\"out\": \"output\",\n\t\"det\": \"details\",\n\t\"sum\": \"summary\",\n\t\"cmd\": \"command\",\n\n\t\"ri:d|ri:dpr\": \"img:s\",\n\t\"ri:v|ri:viewport\": \"img:z\",\n\t\"ri:a|ri:art\": \"pic>src:m+img\",\n\t\"ri:t|ri:type\": \"pic>src:t+img\",\n\n\t\"!!!\": \"{<!DOCTYPE html>}\",\n\t\"doc\": \"html[lang=${lang}]>(head>meta[charset=${charset}]+meta[http-equiv='X-UA-Compatible'][content='IE=edge']+meta:vp+title{${1:Document}})+body\",\n\t\"!|html:5\": \"!!!+doc\",\n\n\t\"c\": \"{<!-- ${0} -->}\",\n\t\"cc:ie\": \"{<!--[if IE]>${0}<![endif]-->}\",\n\t\"cc:noie\": \"{<!--[if !IE]><!-->${0}<!--<![endif]-->}\"\n};\n\nvar stylesheetSnippets = {\n\t\"@f\": \"@font-face {\\n\\tfont-family: ${1};\\n\\tsrc: url(${2});\\n}\",\n\t\"@ff\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\t\"@i|@import\": \"@import url(${0});\",\n\t\"@kf\": \"@keyframes ${1:identifier} {\\n\\t${2}\\n}\",\n\t\"@m|@media\": \"@media ${1:screen} {\\n\\t${0}\\n}\",\n\t\"ac\": \"align-content:start|end|flex-start|flex-end|center|space-between|space-around|stretch|space-evenly\",\n\t\"ai\": \"align-items:start|end|flex-start|flex-end|center|baseline|stretch\",\n\t\"anim\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode}\",\n\t\"animdel\": \"animation-delay:time\",\n\t\"animdir\": \"animation-direction:normal|reverse|alternate|alternate-reverse\",\n\t\"animdur\": \"animation-duration:${1:0}s\",\n\t\"animfm\": \"animation-fill-mode:both|forwards|backwards\",\n\t\"animic\": \"animation-iteration-count:1|infinite\",\n\t\"animn\": \"animation-name\",\n\t\"animps\": \"animation-play-state:running|paused\",\n\t\"animtf\": \"animation-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1})\",\n\t\"ap\": \"appearance:none\",\n\t\"as\": \"align-self:start|end|auto|flex-start|flex-end|center|baseline|stretch\",\n\t\"b\": \"bottom\",\n\t\"bd\": \"border:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdb\": \"border-bottom:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdbc\": \"border-bottom-color:${1:#000}\",\n\t\"bdbi\": \"border-bottom-image:url(${0})\",\n\t\"bdbk\": \"border-break:close\",\n\t\"bdbli\": \"border-bottom-left-image:url(${0})|continue\",\n\t\"bdblrs\": \"border-bottom-left-radius\",\n\t\"bdbri\": \"border-bottom-right-image:url(${0})|continue\",\n\t\"bdbrrs\": \"border-bottom-right-radius\",\n\t\"bdbs\": \"border-bottom-style\",\n\t\"bdbw\": \"border-bottom-width\",\n\t\"bdc\": \"border-color:${1:#000}\",\n\t\"bdci\": \"border-corner-image:url(${0})|continue\",\n\t\"bdcl\": \"border-collapse:collapse|separate\",\n\t\"bdf\": \"border-fit:repeat|clip|scale|stretch|overwrite|overflow|space\",\n\t\"bdi\": \"border-image:url(${0})\",\n\t\"bdl\": \"border-left:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdlc\": \"border-left-color:${1:#000}\",\n\t\"bdlen\": \"border-length\",\n\t\"bdli\": \"border-left-image:url(${0})\",\n\t\"bdls\": \"border-left-style\",\n\t\"bdlw\": \"border-left-width\",\n\t\"bdr\": \"border-right:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdrc\": \"border-right-color:${1:#000}\",\n\t\"bdri\": \"border-right-image:url(${0})\",\n\t\"bdrs\": \"border-radius\",\n\t\"bdrst\": \"border-right-style\",\n\t\"bdrw\": \"border-right-width\",\n\t\"bds\": \"border-style:none|hidden|dotted|dashed|solid|double|dot-dash|dot-dot-dash|wave|groove|ridge|inset|outset\",\n\t\"bdsp\": \"border-spacing\",\n\t\"bdt\": \"border-top:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdtc\": \"border-top-color:${1:#000}\",\n\t\"bdti\": \"border-top-image:url(${0})\",\n\t\"bdtli\": \"border-top-left-image:url(${0})|continue\",\n\t\"bdtlrs\": \"border-top-left-radius\",\n\t\"bdtri\": \"border-top-right-image:url(${0})|continue\",\n\t\"bdtrrs\": \"border-top-right-radius\",\n\t\"bdts\": \"border-top-style\",\n\t\"bdtw\": \"border-top-width\",\n\t\"bdw\": \"border-width\",\n\t\"bfv\": \"backface-visibility:hidden|visible\",\n\t\"bg\": \"background:${1:#000}\",\n\t\"bga\": \"background-attachment:fixed|scroll\",\n\t\"bgbk\": \"background-break:bounding-box|each-box|continuous\",\n\t\"bgc\": \"background-color:#${1:fff}\",\n\t\"bgcp\": \"background-clip:padding-box|border-box|content-box|no-clip\",\n\t\"bgi\": \"background-image:url(${0})\",\n\t\"bgo\": \"background-origin:padding-box|border-box|content-box\",\n\t\"bgp\": \"background-position:${1:0} ${2:0}\",\n\t\"bgpx\": \"background-position-x\",\n\t\"bgpy\": \"background-position-y\",\n\t\"bgr\": \"background-repeat:no-repeat|repeat-x|repeat-y|space|round\",\n\t\"bgsz\": \"background-size:contain|cover\",\n\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:#000}|none\",\n\t\"bxsz\": \"box-sizing:border-box|content-box|border-box\",\n\t\"c\": \"color:${1:#000}\",\n\t\"cr\": \"color:rgb(${1:0}, ${2:0}, ${3:0})\",\n\t\"cra\": \"color:rgba(${1:0}, ${2:0}, ${3:0}, ${4:.5})\",\n\t\"cl\": \"clear:both|left|right|none\",\n\t\"cm\": \"/* ${0} */\",\n\t\"cnt\": \"content:'${0}'|normal|open-quote|no-open-quote|close-quote|no-close-quote|attr(${0})|counter(${0})|counters(${0})\",\n\t\"coi\": \"counter-increment\",\n\t\"colm\": \"columns\",\n\t\"colmc\": \"column-count\",\n\t\"colmf\": \"column-fill\",\n\t\"colmg\": \"column-gap\",\n\t\"colmr\": \"column-rule\",\n\t\"colmrc\": \"column-rule-color\",\n\t\"colmrs\": \"column-rule-style\",\n\t\"colmrw\": \"column-rule-width\",\n\t\"colms\": \"column-span\",\n\t\"colmw\": \"column-width\",\n\t\"cor\": \"counter-reset\",\n\t\"cp\": \"clip:auto|rect(${1:top} ${2:right} ${3:bottom} ${4:left})\",\n\t\"cps\": \"caption-side:top|bottom\",\n\t\"cur\": \"cursor:pointer|auto|default|crosshair|hand|help|move|pointer|text\",\n\t\"d\": \"display:block|none|flex|inline-flex|inline|inline-block|grid|inline-grid|subgrid|list-item|run-in|compact|table|inline-table|table-caption|table-column|table-column-group|table-header-group|table-footer-group|table-row|table-row-group|table-cell|ruby|ruby-base|ruby-base-group|ruby-text|ruby-text-group\",\n\t\"ec\": \"empty-cells:show|hide\",\n\t\"f\": \"font:${1:1em} ${2:sans-serif}\",\n\t\"fd\": \"font-display:auto|block|swap|fallback|optional\",\n\t\"fef\": \"font-effect:none|engrave|emboss|outline\",\n\t\"fem\": \"font-emphasize\",\n\t\"femp\": \"font-emphasize-position:before|after\",\n\t\"fems\": \"font-emphasize-style:none|accent|dot|circle|disc\",\n\t\"ff\": \"font-family:serif|sans-serif|cursive|fantasy|monospace\",\n\t\"fft\": \"font-family:\\\"Times New Roman\\\", Times, Baskerville, Georgia, serif\",\n\t\"ffa\": \"font-family:Arial, \\\"Helvetica Neue\\\", Helvetica, sans-serif\",\n\t\"ffv\": \"font-family:Verdana, Geneva, sans-serif\",\n\t\"fl\": \"float:left|right|none\",\n\t\"fs\": \"font-style:italic|normal|oblique\",\n\t\"fsm\": \"font-smoothing:antialiased|subpixel-antialiased|none\",\n\t\"fst\": \"font-stretch:normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded\",\n\t\"fv\": \"font-variant:normal|small-caps\",\n\t\"fvs\": \"font-variation-settings:normal|inherit|initial|unset\",\n\t\"fw\": \"font-weight:normal|bold|bolder|lighter\",\n\t\"fx\": \"flex\",\n\t\"fxb\": \"flex-basis:fill|max-content|min-content|fit-content|content\",\n\t\"fxd\": \"flex-direction:row|row-reverse|column|column-reverse\",\n\t\"fxf\": \"flex-flow\",\n\t\"fxg\": \"flex-grow\",\n\t\"fxsh\": \"flex-shrink\",\n\t\"fxw\": \"flex-wrap:nowrap|wrap|wrap-reverse\",\n\t\"fsz\": \"font-size\",\n\t\"fsza\": \"font-size-adjust\",\n\t\"gtc\": \"grid-template-columns:repeat(${0})|minmax()\",\n\t\"gtr\": \"grid-template-rows:repeat(${0})|minmax()\",\n\t\"gta\": \"grid-template-areas\",\n\t\"gt\": \"grid-template\",\n\t\"gg\": \"grid-gap\",\n\t\"gcg\": \"grid-column-gap\",\n\t\"grg\": \"grid-row-gap\",\n\t\"gac\": \"grid-auto-columns:auto|minmax()\",\n\t\"gar\": \"grid-auto-rows:auto|minmax()\",\n\t\"gaf\": \"grid-auto-flow:row|column|dense|inherit|initial|unset\",\n\t\"gd\": \"grid\",\n\t\"gc\": \"grid-column\",\n\t\"gcs\": \"grid-column-start\",\n\t\"gce\": \"grid-column-end\",\n\t\"gr\": \"grid-row\",\n\t\"grs\": \"grid-row-start\",\n\t\"gre\": \"grid-row-end\",\n\t\"ga\": \"grid-area\",\n\t\"h\": \"height\",\n\t\"jc\": \"justify-content:start|end|stretch|flex-start|flex-end|center|space-between|space-around|space-evenly\",\n\t\"ji\": \"justify-items:start|end|center|stretch\",\n\t\"js\": \"justify-self:start|end|center|stretch\",\n\t\"l\": \"left\",\n\t\"lg\": \"background-image:linear-gradient(${1})\",\n\t\"lh\": \"line-height\",\n\t\"lis\": \"list-style\",\n\t\"lisi\": \"list-style-image\",\n\t\"lisp\": \"list-style-position:inside|outside\",\n\t\"list\": \"list-style-type:disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman\",\n\t\"lts\": \"letter-spacing:normal\",\n\t\"m\": \"margin\",\n\t\"mah\": \"max-height\",\n\t\"mar\": \"max-resolution\",\n\t\"maw\": \"max-width\",\n\t\"mb\": \"margin-bottom\",\n\t\"mih\": \"min-height\",\n\t\"mir\": \"min-resolution\",\n\t\"miw\": \"min-width\",\n\t\"ml\": \"margin-left\",\n\t\"mr\": \"margin-right\",\n\t\"mt\": \"margin-top\",\n\t\"ol\": \"outline\",\n\t\"olc\": \"outline-color:${1:#000}|invert\",\n\t\"olo\": \"outline-offset\",\n\t\"ols\": \"outline-style:none|dotted|dashed|solid|double|groove|ridge|inset|outset\",\n\t\"olw\": \"outline-width|thin|medium|thick\",\n\t\"op|opa\": \"opacity\",\n\t\"ord\": \"order\",\n\t\"ori\": \"orientation:landscape|portrait\",\n\t\"orp\": \"orphans\",\n\t\"ov\": \"overflow:hidden|visible|hidden|scroll|auto\",\n\t\"ovs\": \"overflow-style:scrollbar|auto|scrollbar|panner|move|marquee\",\n\t\"ovx\": \"overflow-x:hidden|visible|hidden|scroll|auto\",\n\t\"ovy\": \"overflow-y:hidden|visible|hidden|scroll|auto\",\n\t\"p\": \"padding\",\n\t\"pb\": \"padding-bottom\",\n\t\"pgba\": \"page-break-after:auto|always|left|right\",\n\t\"pgbb\": \"page-break-before:auto|always|left|right\",\n\t\"pgbi\": \"page-break-inside:auto|avoid\",\n\t\"pl\": \"padding-left\",\n\t\"pos\": \"position:relative|absolute|relative|fixed|static\",\n\t\"pr\": \"padding-right\",\n\t\"pt\": \"padding-top\",\n\t\"q\": \"quotes\",\n\t\"qen\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019'\",\n\t\"qru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C'\",\n\t\"r\": \"right\",\n\t\"rsz\": \"resize:none|both|horizontal|vertical\",\n\t\"t\": \"top\",\n\t\"ta\": \"text-align:left|center|right|justify\",\n\t\"tal\": \"text-align-last:left|center|right\",\n\t\"tbl\": \"table-layout:fixed\",\n\t\"td\": \"text-decoration:none|underline|overline|line-through\",\n\t\"te\": \"text-emphasis:none|accent|dot|circle|disc|before|after\",\n\t\"th\": \"text-height:auto|font-size|text-size|max-size\",\n\t\"ti\": \"text-indent\",\n\t\"tj\": \"text-justify:auto|inter-word|inter-ideograph|inter-cluster|distribute|kashida|tibetan\",\n\t\"to\": \"text-outline:${1:0} ${2:0} ${3:#000}\",\n\t\"tov\": \"text-overflow:ellipsis|clip\",\n\t\"tr\": \"text-replace\",\n\t\"trf\": \"transform:${1}|skewX(${1:angle})|skewY(${1:angle})|scale(${1:x}, ${2:y})|scaleX(${1:x})|scaleY(${1:y})|scaleZ(${1:z})|scale3d(${1:x}, ${2:y}, ${3:z})|rotate(${1:angle})|rotateX(${1:angle})|rotateY(${1:angle})|rotateZ(${1:angle})|translate(${1:x}, ${2:y})|translateX(${1:x})|translateY(${1:y})|translateZ(${1:z})|translate3d(${1:tx}, ${2:ty}, ${3:tz})\",\n\t\"trfo\": \"transform-origin\",\n\t\"trfs\": \"transform-style:preserve-3d\",\n\t\"trs\": \"transition:${1:prop} ${2:time}\",\n\t\"trsde\": \"transition-delay:${1:time}\",\n\t\"trsdu\": \"transition-duration:${1:time}\",\n\t\"trsp\": \"transition-property:${1:prop}\",\n\t\"trstf\": \"transition-timing-function:${1:fn}\",\n\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000}\",\n\t\"tt\": \"text-transform:uppercase|lowercase|capitalize|none\",\n\t\"tw\": \"text-wrap:none|normal|unrestricted|suppress\",\n\t\"us\": \"user-select:none\",\n\t\"v\": \"visibility:hidden|visible|collapse\",\n\t\"va\": \"vertical-align:top|super|text-top|middle|baseline|bottom|text-bottom|sub\",\n\t\"w\": \"width\",\n\t\"whs\": \"white-space:nowrap|pre|pre-wrap|pre-line|normal\",\n\t\"whsc\": \"white-space-collapse:normal|keep-all|loose|break-strict|break-all\",\n\t\"wid\": \"widows\",\n\t\"wm\": \"writing-mode:lr-tb|lr-tb|lr-bt|rl-tb|rl-bt|tb-rl|tb-lr|bt-lr|bt-rl\",\n\t\"wob\": \"word-break:normal|keep-all|break-all\",\n\t\"wos\": \"word-spacing\",\n\t\"wow\": \"word-wrap:none|unrestricted|suppress|break-word|normal\",\n\t\"z\": \"z-index\",\n\t\"zom\": \"zoom:1\"\n};\n\nvar xslSnippets = {\n    \"tm|tmatch\": \"xsl:template[match mode]\",\n    \"tn|tname\": \"xsl:template[name]\",\n    \"call\": \"xsl:call-template[name]\",\n    \"ap\": \"xsl:apply-templates[select mode]\",\n    \"api\": \"xsl:apply-imports\",\n    \"imp\": \"xsl:import[href]\",\n    \"inc\": \"xsl:include[href]\",\n    \"ch\": \"xsl:choose\",\n    \"wh|xsl:when\": \"xsl:when[test]\",\n    \"ot\": \"xsl:otherwise\",\n    \"if\": \"xsl:if[test]\",\n    \"par\": \"xsl:param[name]\",\n    \"pare\": \"xsl:param[name select]\",\n    \"var\": \"xsl:variable[name]\",\n    \"vare\": \"xsl:variable[name select]\",\n    \"wp\": \"xsl:with-param[name select]\",\n    \"key\": \"xsl:key[name match use]\",\n    \"elem\": \"xsl:element[name]\",\n    \"attr\": \"xsl:attribute[name]\",\n    \"attrs\": \"xsl:attribute-set[name]\",\n    \"cp\": \"xsl:copy[select]\",\n    \"co\": \"xsl:copy-of[select]\",\n    \"val\": \"xsl:value-of[select]\",\n    \"for|each\": \"xsl:for-each[select]\",\n    \"tex\": \"xsl:text\",\n    \"com\": \"xsl:comment\",\n    \"msg\": \"xsl:message[terminate=no]\",\n    \"fall\": \"xsl:fallback\",\n    \"num\": \"xsl:number[value]\",\n    \"nam\": \"namespace-alias[stylesheet-prefix result-prefix]\",\n    \"pres\": \"xsl:preserve-space[elements]\",\n    \"strip\": \"xsl:strip-space[elements]\",\n    \"proc\": \"xsl:processing-instruction[name]\",\n    \"sort\": \"xsl:sort[select order]\",\n    \"choose\": \"xsl:choose>xsl:when+xsl:otherwise\",\n    \"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\",\n    \"!!!\": \"{<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>}\"\n};\n\nvar pugSnippets = {\n\t\"!!!\": \"{doctype html}\"\n};\n\nvar variables = {\n\t\"lang\": \"en\",\n\t\"locale\": \"en-US\",\n\t\"charset\": \"UTF-8\",\n\t\"indentation\": \"\\t\",\n\t\"newline\": \"\\n\"\n};\n\n/**\n * Default syntaxes for abbreviation types\n */\nconst defaultSyntaxes = {\n    markup: 'html',\n    stylesheet: 'css'\n};\nconst defaultOptions = {\n    'inlineElements': [\n        'a', 'abbr', 'acronym', 'applet', 'b', 'basefont', 'bdo',\n        'big', 'br', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i',\n        'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'map', 'object', 'q',\n        's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup',\n        'textarea', 'tt', 'u', 'var'\n    ],\n    'output.indent': '\\t',\n    'output.baseIndent': '',\n    'output.newline': '\\n',\n    'output.tagCase': '',\n    'output.attributeCase': '',\n    'output.attributeQuotes': 'double',\n    'output.format': true,\n    'output.formatLeafNode': false,\n    'output.formatSkip': ['html'],\n    'output.formatForce': ['body'],\n    'output.inlineBreak': 3,\n    'output.compactBoolean': false,\n    'output.booleanAttributes': [\n        'contenteditable', 'seamless', 'async', 'autofocus',\n        'autoplay', 'checked', 'controls', 'defer', 'disabled', 'formnovalidate',\n        'hidden', 'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'readonly',\n        'required', 'reversed', 'selected', 'typemustmatch'\n    ],\n    'output.reverseAttributes': false,\n    'output.selfClosingStyle': 'html',\n    'output.field': (index, placeholder) => placeholder,\n    'output.text': text => text,\n    'markup.href': true,\n    'comment.enabled': false,\n    'comment.trigger': ['id', 'class'],\n    'comment.before': '',\n    'comment.after': '\\n<!-- /[#ID][.CLASS] -->',\n    'bem.enabled': false,\n    'bem.element': '__',\n    'bem.modifier': '_',\n    'jsx.enabled': false,\n    'stylesheet.keywords': ['auto', 'inherit', 'unset', 'none'],\n    'stylesheet.unitless': ['z-index', 'line-height', 'opacity', 'font-weight', 'zoom', 'flex', 'flex-grow', 'flex-shrink'],\n    'stylesheet.shortHex': true,\n    'stylesheet.between': ': ',\n    'stylesheet.after': ';',\n    'stylesheet.intUnit': 'px',\n    'stylesheet.floatUnit': 'em',\n    'stylesheet.unitAliases': { e: 'em', p: '%', x: 'ex', r: 'rem' },\n    'stylesheet.json': false,\n    'stylesheet.jsonDoubleQuotes': false,\n    'stylesheet.fuzzySearchMinScore': 0\n};\nconst defaultConfig = {\n    type: 'markup',\n    syntax: 'html',\n    variables,\n    snippets: {},\n    options: defaultOptions\n};\n/**\n * Default per-syntax config\n */\nconst syntaxConfig = {\n    markup: {\n        snippets: parseSnippets(markupSnippets),\n    },\n    xhtml: {\n        options: {\n            'output.selfClosingStyle': 'xhtml'\n        }\n    },\n    xml: {\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    xsl: {\n        snippets: parseSnippets(xslSnippets),\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    jsx: {\n        options: {\n            'jsx.enabled': true\n        }\n    },\n    pug: {\n        snippets: parseSnippets(pugSnippets)\n    },\n    stylesheet: {\n        snippets: parseSnippets(stylesheetSnippets)\n    },\n    sass: {\n        options: {\n            'stylesheet.after': ''\n        }\n    },\n    stylus: {\n        options: {\n            'stylesheet.between': ' ',\n            'stylesheet.after': '',\n        }\n    }\n};\n/**\n * Parses raw snippets definitions with possibly multiple keys into a plan\n * snippet map\n */\nfunction parseSnippets(snippets) {\n    const result = {};\n    Object.keys(snippets).forEach(k => {\n        for (const name of k.split('|')) {\n            result[name] = snippets[k];\n        }\n    });\n    return result;\n}\nfunction resolveConfig(config = {}, globals = {}) {\n    const type = config.type || 'markup';\n    const syntax = config.syntax || defaultSyntaxes[type];\n    return Object.assign(Object.assign(Object.assign({}, defaultConfig), config), { type,\n        syntax, variables: mergedData(type, syntax, 'variables', config, globals), snippets: mergedData(type, syntax, 'snippets', config, globals), options: mergedData(type, syntax, 'options', config, globals) });\n}\nfunction mergedData(type, syntax, key, config, globals = {}) {\n    const typeDefaults = syntaxConfig[type];\n    const typeOverride = globals[type];\n    const syntaxDefaults = syntaxConfig[syntax];\n    const syntaxOverride = globals[syntax];\n    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, defaultConfig[key]), (typeDefaults && typeDefaults[key])), (syntaxDefaults && syntaxDefaults[key])), (typeOverride && typeOverride[key])), (syntaxOverride && syntaxOverride[key])), config[key]);\n}\n\n/**\n * Creates structure for scanning given string in backward direction\n */\nfunction backwardScanner(text, start = 0) {\n    return { text, start, pos: text.length };\n}\n/**\n * Check if given scanner position is at start of scanned text\n */\nfunction sol(scanner) {\n    return scanner.pos === scanner.start;\n}\n/**\n * Peeks character code an current scanner location without advancing it\n */\nfunction peek$1(scanner, offset = 0) {\n    return scanner.text.charCodeAt(scanner.pos - 1 + offset);\n}\n/**\n * Returns current character code and moves character location one symbol back\n */\nfunction previous(scanner) {\n    if (!sol(scanner)) {\n        return scanner.text.charCodeAt(--scanner.pos);\n    }\n}\n/**\n * Consumes current character code if it matches given `match` code or function\n */\nfunction consume(scanner, match) {\n    if (sol(scanner)) {\n        return false;\n    }\n    const ok = typeof match === 'function'\n        ? match(peek$1(scanner))\n        : match === peek$1(scanner);\n    if (ok) {\n        scanner.pos--;\n    }\n    return !!ok;\n}\nfunction consumeWhile(scanner, match) {\n    const start = scanner.pos;\n    while (consume(scanner, match)) {\n        // empty\n    }\n    return scanner.pos < start;\n}\n\n/**\n * Check if given character code is a quote\n */\nfunction isQuote(c) {\n    return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;\n}\n/**\n * Consumes quoted value, if possible\n * @return Returns `true` is value was consumed\n */\nfunction consumeQuoted(scanner) {\n    const start = scanner.pos;\n    const quote = previous(scanner);\n    if (isQuote(quote)) {\n        while (!sol(scanner)) {\n            if (previous(scanner) === quote && peek$1(scanner) !== 92 /* Escape */) {\n                return true;\n            }\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n\nconst bracePairs = {\n    [91 /* SquareL */]: 93 /* SquareR */,\n    [40 /* RoundL */]: 41 /* RoundR */,\n    [123 /* CurlyL */]: 125 /* CurlyR */,\n};\n\n/**\n * Check if given readers current position points at the end of HTML tag\n */\nfunction isHtml(scanner) {\n    const start = scanner.pos;\n    if (!consume(scanner, 62 /* AngleRight */)) {\n        return false;\n    }\n    let ok = false;\n    consume(scanner, 47 /* Slash */); // possibly self-closed element\n    while (!sol(scanner)) {\n        consumeWhile(scanner, isWhiteSpace);\n        if (consumeIdent(scanner)) {\n            // ate identifier: could be a tag name, boolean attribute or unquoted\n            // attribute value\n            if (consume(scanner, 47 /* Slash */)) {\n                // either closing tag or invalid tag\n                ok = consume(scanner, 60 /* AngleLeft */);\n                break;\n            }\n            else if (consume(scanner, 60 /* AngleLeft */)) {\n                // opening tag\n                ok = true;\n                break;\n            }\n            else if (consume(scanner, isWhiteSpace)) {\n                // boolean attribute\n                continue;\n            }\n            else if (consume(scanner, 61 /* Equals */)) {\n                // simple unquoted value or invalid attribute\n                if (consumeIdent(scanner)) {\n                    continue;\n                }\n                break;\n            }\n            else if (consumeAttributeWithUnquotedValue(scanner)) {\n                // identifier was a part of unquoted value\n                ok = true;\n                break;\n            }\n            // invalid tag\n            break;\n        }\n        if (consumeAttribute(scanner)) {\n            continue;\n        }\n        break;\n    }\n    scanner.pos = start;\n    return ok;\n}\n/**\n * Consumes HTML attribute from given string.\n * @return `true` if attribute was consumed.\n */\nfunction consumeAttribute(scanner) {\n    return consumeAttributeWithQuotedValue(scanner) || consumeAttributeWithUnquotedValue(scanner);\n}\nfunction consumeAttributeWithQuotedValue(scanner) {\n    const start = scanner.pos;\n    if (consumeQuoted(scanner) && consume(scanner, 61 /* Equals */) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\nfunction consumeAttributeWithUnquotedValue(scanner) {\n    const start = scanner.pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        const ch = peek$1(scanner);\n        if (isCloseBracket(ch)) {\n            stack.push(ch);\n        }\n        else if (isOpenBracket(ch)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // Unexpected open bracket\n                break;\n            }\n        }\n        else if (!isUnquotedValue(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (start !== scanner.pos && consume(scanner, 61 /* Equals */) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes HTML identifier from stream\n */\nfunction consumeIdent(scanner) {\n    return consumeWhile(scanner, isIdent);\n}\n/**\n * Check if given character code belongs to HTML identifier\n */\nfunction isIdent(ch) {\n    return ch === 58 /* Colon */ || ch === 45 /* Dash */ || isAlpha(ch) || isNumber(ch);\n}\n/**\n * Check if given character code is alpha code (letter though A to Z)\n */\nfunction isAlpha(ch) {\n    ch &= ~32; // quick hack to convert any char code to uppercase char code\n    return ch >= 65 && ch <= 90; // A-Z\n}\n/**\n * Check if given code is a number\n */\nfunction isNumber(ch) {\n    return ch > 47 && ch < 58;\n}\n/**\n * Check if given code is a whitespace\n */\nfunction isWhiteSpace(ch) {\n    return ch === 32 /* Space */ || ch === 9 /* Tab */;\n}\n/**\n * Check if given code may belong to unquoted attribute value\n */\nfunction isUnquotedValue(ch) {\n    return !isNaN(ch) && ch !== 61 /* Equals */ && !isWhiteSpace(ch) && !isQuote(ch);\n}\nfunction isOpenBracket(ch) {\n    return ch === 123 /* CurlyL */ || ch === 40 /* RoundL */ || ch === 91 /* SquareL */;\n}\nfunction isCloseBracket(ch) {\n    return ch === 125 /* CurlyR */ || ch === 41 /* RoundR */ || ch === 93 /* SquareR */;\n}\n\nconst code = (ch) => ch.charCodeAt(0);\nconst specialChars = '#.*:$-_!@%^+>/'.split('').map(code);\nconst defaultOptions$1 = {\n    type: 'markup',\n    lookAhead: true,\n    prefix: ''\n};\n/**\n * Extracts Emmet abbreviation from given string.\n * The goal of this module is to extract abbreviation from current editors line,\n * e.g. like this: `<span>.foo[title=bar|]</span>` -> `.foo[title=bar]`, where\n * `|` is a current caret position.\n * @param line A text line where abbreviation should be expanded\n * @param pos Caret position in line. If not given, uses end of line\n * @param options Extracting options\n */\nfunction extractAbbreviation$1(line, pos = line.length, options = {}) {\n    // make sure `pos` is within line range\n    const opt = Object.assign(Object.assign({}, defaultOptions$1), options);\n    pos = Math.min(line.length, Math.max(0, pos == null ? line.length : pos));\n    if (opt.lookAhead) {\n        pos = offsetPastAutoClosed(line, pos, opt);\n    }\n    let ch;\n    const start = getStartOffset(line, pos, opt.prefix || '');\n    if (start === -1) {\n        return void 0;\n    }\n    const scanner = backwardScanner(line, start);\n    scanner.pos = pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        ch = peek$1(scanner);\n        if (stack.includes(125 /* CurlyR */)) {\n            if (ch === 125 /* CurlyR */) {\n                stack.push(ch);\n                scanner.pos--;\n                continue;\n            }\n            if (ch !== 123 /* CurlyL */) {\n                scanner.pos--;\n                continue;\n            }\n        }\n        if (isCloseBrace(ch, opt.type)) {\n            stack.push(ch);\n        }\n        else if (isOpenBrace(ch, opt.type)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // unexpected brace\n                break;\n            }\n        }\n        else if (stack.includes(93 /* SquareR */) || stack.includes(125 /* CurlyR */)) {\n            // respect all characters inside attribute sets or text nodes\n            scanner.pos--;\n            continue;\n        }\n        else if (isHtml(scanner) || !isAbbreviation(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (!stack.length && scanner.pos !== pos) {\n        // Found something, remove some invalid symbols from the\n        // beginning and return abbreviation\n        const abbreviation = line.slice(scanner.pos, pos).replace(/^[*+>^]+/, '');\n        return {\n            abbreviation,\n            location: pos - abbreviation.length,\n            start: options.prefix\n                ? start - options.prefix.length\n                : pos - abbreviation.length,\n            end: pos\n        };\n    }\n}\n/**\n * Returns new `line` index which is right after characters beyound `pos` that\n * editor will likely automatically close, e.g. }, ], and quotes\n */\nfunction offsetPastAutoClosed(line, pos, options) {\n    // closing quote is allowed only as a next character\n    if (isQuote(line.charCodeAt(pos))) {\n        pos++;\n    }\n    // offset pointer until non-autoclosed character is found\n    while (isCloseBrace(line.charCodeAt(pos), options.type)) {\n        pos++;\n    }\n    return pos;\n}\n/**\n * Returns start offset (left limit) in `line` where we should stop looking for\n * abbreviation: its nearest to `pos` location of `prefix` token\n */\nfunction getStartOffset(line, pos, prefix) {\n    if (!prefix) {\n        return 0;\n    }\n    const scanner = backwardScanner(line);\n    const compiledPrefix = prefix.split('').map(code);\n    scanner.pos = pos;\n    let result;\n    while (!sol(scanner)) {\n        if (consumePair(scanner, 93 /* SquareR */, 91 /* SquareL */) || consumePair(scanner, 125 /* CurlyR */, 123 /* CurlyL */)) {\n            continue;\n        }\n        result = scanner.pos;\n        if (consumeArray(scanner, compiledPrefix)) {\n            return result;\n        }\n        scanner.pos--;\n    }\n    return -1;\n}\n/**\n * Consumes full character pair, if possible\n */\nfunction consumePair(scanner, close, open) {\n    const start = scanner.pos;\n    if (consume(scanner, close)) {\n        while (!sol(scanner)) {\n            if (consume(scanner, open)) {\n                return true;\n            }\n            scanner.pos--;\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes all character codes from given array, right-to-left, if possible\n */\nfunction consumeArray(scanner, arr) {\n    const start = scanner.pos;\n    let consumed = false;\n    for (let i = arr.length - 1; i >= 0 && !sol(scanner); i--) {\n        if (!consume(scanner, arr[i])) {\n            break;\n        }\n        consumed = i === 0;\n    }\n    if (!consumed) {\n        scanner.pos = start;\n    }\n    return consumed;\n}\nfunction isAbbreviation(ch) {\n    return (ch > 64 && ch < 91) // uppercase letter\n        || (ch > 96 && ch < 123) // lowercase letter\n        || (ch > 47 && ch < 58) // number\n        || specialChars.includes(ch); // special character\n}\nfunction isOpenBrace(ch, syntax) {\n    return ch === 40 /* RoundL */ || (syntax === 'markup' && (ch === 91 /* SquareL */ || ch === 123 /* CurlyL */));\n}\nfunction isCloseBrace(ch, syntax) {\n    return ch === 41 /* RoundR */ || (syntax === 'markup' && (ch === 93 /* SquareR */ || ch === 125 /* CurlyR */));\n}\n\nfunction expandAbbreviation$1(abbr, config) {\n    const resolvedConfig = resolveConfig(config);\n    return resolvedConfig.type === 'stylesheet'\n        ? stylesheet(abbr, resolvedConfig)\n        : markup(abbr, resolvedConfig);\n}\n/**\n * Expands given *markup* abbreviation (e.g. regular Emmet abbreviation that\n * produces structured output like HTML) and outputs it according to options\n * provided in config\n */\nfunction markup(abbr, config) {\n    return stringify(parse(abbr, config), config);\n}\n/**\n * Expands given *stylesheet* abbreviation (a special Emmet abbreviation designed for\n * stylesheet languages like CSS, SASS etc.) and outputs it according to options\n * provided in config\n */\nfunction stylesheet(abbr, config) {\n    return css(parse$1(abbr, config), config);\n}\n\nvar cssData = {\n    \"properties\": [\"additive-symbols\", \"align-content\", \"align-items\", \"justify-items\", \"justify-self\", \"justify-items\", \"align-self\", \"all\", \"alt\", \"animation\", \"animation-delay\", \"animation-direction\", \"animation-duration\", \"animation-fill-mode\", \"animation-iteration-count\", \"animation-name\", \"animation-play-state\", \"animation-timing-function\", \"backface-visibility\", \"background\", \"background-attachment\", \"background-blend-mode\", \"background-clip\", \"background-color\", \"background-image\", \"background-origin\", \"background-position\", \"background-position-x\", \"background-position-y\", \"background-repeat\", \"background-size\", \"behavior\", \"block-size\", \"border\", \"border-block-end\", \"border-block-start\", \"border-block-end-color\", \"border-block-start-color\", \"border-block-end-style\", \"border-block-start-style\", \"border-block-end-width\", \"border-block-start-width\", \"border-bottom\", \"border-bottom-color\", \"border-bottom-left-radius\", \"border-bottom-right-radius\", \"border-bottom-style\", \"border-bottom-width\", \"border-collapse\", \"border-color\", \"border-image\", \"border-image-outset\", \"border-image-repeat\", \"border-image-slice\", \"border-image-source\", \"border-image-width\", \"border-inline-end\", \"border-inline-start\", \"border-inline-end-color\", \"border-inline-start-color\", \"border-inline-end-style\", \"border-inline-start-style\", \"border-inline-end-width\", \"border-inline-start-width\", \"border-left\", \"border-left-color\", \"border-left-style\", \"border-left-width\", \"border-radius\", \"border-right\", \"border-right-color\", \"border-right-style\", \"border-right-width\", \"border-spacing\", \"border-style\", \"border-top\", \"border-top-color\", \"border-top-left-radius\", \"border-top-right-radius\", \"border-top-style\", \"border-top-width\", \"border-width\", \"bottom\", \"box-decoration-break\", \"box-shadow\", \"box-sizing\", \"break-after\", \"break-before\", \"break-inside\", \"caption-side\", \"caret-color\", \"clear\", \"clip\", \"clip-path\", \"clip-rule\", \"color\", \"color-interpolation-filters\", \"column-count\", \"column-fill\", \"column-gap\", \"column-rule\", \"column-rule-color\", \"column-rule-style\", \"column-rule-width\", \"columns\", \"column-span\", \"column-width\", \"contain\", \"content\", \"counter-increment\", \"counter-reset\", \"cursor\", \"direction\", \"display\", \"empty-cells\", \"enable-background\", \"fallback\", \"fill\", \"fill-opacity\", \"fill-rule\", \"filter\", \"flex\", \"flex-basis\", \"flex-direction\", \"flex-flow\", \"flex-grow\", \"flex-shrink\", \"flex-wrap\", \"float\", \"flood-color\", \"flood-opacity\", \"font\", \"font-family\", \"font-feature-settings\", \"font-kerning\", \"font-language-override\", \"font-size\", \"font-size-adjust\", \"font-stretch\", \"font-style\", \"font-synthesis\", \"font-variant\", \"font-variant-alternates\", \"font-variant-caps\", \"font-variant-east-asian\", \"font-variant-ligatures\", \"font-variant-numeric\", \"font-variant-position\", \"font-weight\", \"glyph-orientation-horizontal\", \"glyph-orientation-vertical\", \"grid-area\", \"grid-auto-columns\", \"grid-auto-flow\", \"grid-auto-rows\", \"grid-column\", \"grid-column-end\", \"grid-column-gap\", \"grid-column-start\", \"grid-gap\", \"grid-row\", \"grid-row-end\", \"grid-row-gap\", \"grid-row-start\", \"grid-template\", \"grid-template-areas\", \"grid-template-columns\", \"grid-template-rows\", \"height\", \"hyphens\", \"image-orientation\", \"image-rendering\", \"ime-mode\", \"inline-size\", \"isolation\", \"justify-content\", \"kerning\", \"left\", \"letter-spacing\", \"lighting-color\", \"line-break\", \"line-height\", \"list-style\", \"list-style-image\", \"list-style-position\", \"list-style-type\", \"margin\", \"margin-block-end\", \"margin-block-start\", \"margin-bottom\", \"margin-inline-end\", \"margin-inline-start\", \"margin-left\", \"margin-right\", \"margin-top\", \"marker\", \"marker-end\", \"marker-mid\", \"marker-start\", \"mask-type\", \"max-block-size\", \"max-height\", \"max-inline-size\", \"max-width\", \"min-block-size\", \"min-height\", \"min-inline-size\", \"min-width\", \"mix-blend-mode\", \"motion\", \"motion-offset\", \"motion-path\", \"motion-rotation\", \"-moz-animation\", \"-moz-animation-delay\", \"-moz-animation-direction\", \"-moz-animation-duration\", \"-moz-animation-iteration-count\", \"-moz-animation-name\", \"-moz-animation-play-state\", \"-moz-animation-timing-function\", \"-moz-appearance\", \"-moz-backface-visibility\", \"-moz-background-clip\", \"-moz-background-inline-policy\", \"-moz-background-origin\", \"-moz-border-bottom-colors\", \"-moz-border-image\", \"-moz-border-left-colors\", \"-moz-border-right-colors\", \"-moz-border-top-colors\", \"-moz-box-align\", \"-moz-box-direction\", \"-moz-box-flex\", \"-moz-box-flexgroup\", \"-moz-box-ordinal-group\", \"-moz-box-orient\", \"-moz-box-pack\", \"-moz-box-sizing\", \"-moz-column-count\", \"-moz-column-gap\", \"-moz-column-rule\", \"-moz-column-rule-color\", \"-moz-column-rule-style\", \"-moz-column-rule-width\", \"-moz-columns\", \"-moz-column-width\", \"-moz-font-feature-settings\", \"-moz-hyphens\", \"-moz-perspective\", \"-moz-perspective-origin\", \"-moz-text-align-last\", \"-moz-text-decoration-color\", \"-moz-text-decoration-line\", \"-moz-text-decoration-style\", \"-moz-text-size-adjust\", \"-moz-transform\", \"-moz-transform-origin\", \"-moz-transition\", \"-moz-transition-delay\", \"-moz-transition-duration\", \"-moz-transition-property\", \"-moz-transition-timing-function\", \"-moz-user-focus\", \"-moz-user-select\", \"-ms-accelerator\", \"-ms-behavior\", \"-ms-block-progression\", \"-ms-content-zoom-chaining\", \"-ms-content-zooming\", \"-ms-content-zoom-limit\", \"-ms-content-zoom-limit-max\", \"-ms-content-zoom-limit-min\", \"-ms-content-zoom-snap\", \"-ms-content-zoom-snap-points\", \"-ms-content-zoom-snap-type\", \"-ms-filter\", \"-ms-flex\", \"-ms-flex-align\", \"-ms-flex-direction\", \"-ms-flex-flow\", \"-ms-flex-item-align\", \"-ms-flex-line-pack\", \"-ms-flex-order\", \"-ms-flex-pack\", \"-ms-flex-wrap\", \"-ms-flow-from\", \"-ms-flow-into\", \"-ms-grid-column\", \"-ms-grid-column-align\", \"-ms-grid-columns\", \"-ms-grid-column-span\", \"-ms-grid-layer\", \"-ms-grid-row\", \"-ms-grid-row-align\", \"-ms-grid-rows\", \"-ms-grid-row-span\", \"-ms-high-contrast-adjust\", \"-ms-hyphenate-limit-chars\", \"-ms-hyphenate-limit-lines\", \"-ms-hyphenate-limit-zone\", \"-ms-hyphens\", \"-ms-ime-mode\", \"-ms-interpolation-mode\", \"-ms-layout-grid\", \"-ms-layout-grid-char\", \"-ms-layout-grid-line\", \"-ms-layout-grid-mode\", \"-ms-layout-grid-type\", \"-ms-line-break\", \"-ms-overflow-style\", \"-ms-perspective\", \"-ms-perspective-origin\", \"-ms-perspective-origin-x\", \"-ms-perspective-origin-y\", \"-ms-progress-appearance\", \"-ms-scrollbar-3dlight-color\", \"-ms-scrollbar-arrow-color\", \"-ms-scrollbar-base-color\", \"-ms-scrollbar-darkshadow-color\", \"-ms-scrollbar-face-color\", \"-ms-scrollbar-highlight-color\", \"-ms-scrollbar-shadow-color\", \"-ms-scrollbar-track-color\", \"-ms-scroll-chaining\", \"-ms-scroll-limit\", \"-ms-scroll-limit-x-max\", \"-ms-scroll-limit-x-min\", \"-ms-scroll-limit-y-max\", \"-ms-scroll-limit-y-min\", \"-ms-scroll-rails\", \"-ms-scroll-snap-points-x\", \"-ms-scroll-snap-points-y\", \"-ms-scroll-snap-type\", \"-ms-scroll-snap-x\", \"-ms-scroll-snap-y\", \"-ms-scroll-translation\", \"-ms-text-align-last\", \"-ms-text-autospace\", \"-ms-text-combine-horizontal\", \"-ms-text-justify\", \"-ms-text-kashida-space\", \"-ms-text-overflow\", \"-ms-text-size-adjust\", \"-ms-text-underline-position\", \"-ms-touch-action\", \"-ms-touch-select\", \"-ms-transform\", \"-ms-transform-origin\", \"-ms-transform-origin-x\", \"-ms-transform-origin-y\", \"-ms-transform-origin-z\", \"-ms-user-select\", \"-ms-word-break\", \"-ms-word-wrap\", \"-ms-wrap-flow\", \"-ms-wrap-margin\", \"-ms-wrap-through\", \"-ms-writing-mode\", \"-ms-zoom\", \"-ms-zoom-animation\", \"nav-down\", \"nav-index\", \"nav-left\", \"nav-right\", \"nav-up\", \"negative\", \"-o-animation\", \"-o-animation-delay\", \"-o-animation-direction\", \"-o-animation-duration\", \"-o-animation-fill-mode\", \"-o-animation-iteration-count\", \"-o-animation-name\", \"-o-animation-play-state\", \"-o-animation-timing-function\", \"object-fit\", \"object-position\", \"-o-border-image\", \"-o-object-fit\", \"-o-object-position\", \"opacity\", \"order\", \"orphans\", \"-o-table-baseline\", \"-o-tab-size\", \"-o-text-overflow\", \"-o-transform\", \"-o-transform-origin\", \"-o-transition\", \"-o-transition-delay\", \"-o-transition-duration\", \"-o-transition-property\", \"-o-transition-timing-function\", \"offset-block-end\", \"offset-block-start\", \"offset-inline-end\", \"offset-inline-start\", \"outline\", \"outline-color\", \"outline-offset\", \"outline-style\", \"outline-width\", \"overflow\", \"overflow-wrap\", \"overflow-x\", \"overflow-y\", \"pad\", \"padding\", \"padding-bottom\", \"padding-block-end\", \"padding-block-start\", \"padding-inline-end\", \"padding-inline-start\", \"padding-left\", \"padding-right\", \"padding-top\", \"page-break-after\", \"page-break-before\", \"page-break-inside\", \"paint-order\", \"perspective\", \"perspective-origin\", \"pointer-events\", \"position\", \"prefix\", \"quotes\", \"range\", \"resize\", \"right\", \"ruby-align\", \"ruby-overhang\", \"ruby-position\", \"ruby-span\", \"scrollbar-3dlight-color\", \"scrollbar-arrow-color\", \"scrollbar-base-color\", \"scrollbar-darkshadow-color\", \"scrollbar-face-color\", \"scrollbar-highlight-color\", \"scrollbar-shadow-color\", \"scrollbar-track-color\", \"scroll-behavior\", \"scroll-snap-coordinate\", \"scroll-snap-destination\", \"scroll-snap-points-x\", \"scroll-snap-points-y\", \"scroll-snap-type\", \"shape-image-threshold\", \"shape-margin\", \"shape-outside\", \"shape-rendering\", \"size\", \"src\", \"stop-color\", \"stop-opacity\", \"stroke\", \"stroke-dasharray\", \"stroke-dashoffset\", \"stroke-linecap\", \"stroke-linejoin\", \"stroke-miterlimit\", \"stroke-opacity\", \"stroke-width\", \"suffix\", \"system\", \"symbols\", \"table-layout\", \"tab-size\", \"text-align\", \"text-align-last\", \"text-anchor\", \"text-decoration\", \"text-decoration-color\", \"text-decoration-line\", \"text-decoration-style\", \"text-indent\", \"text-justify\", \"text-orientation\", \"text-overflow\", \"text-rendering\", \"text-shadow\", \"text-transform\", \"text-underline-position\", \"top\", \"touch-action\", \"transform\", \"transform-origin\", \"transform-style\", \"transition\", \"transition-delay\", \"transition-duration\", \"transition-property\", \"transition-timing-function\", \"unicode-bidi\", \"unicode-range\", \"user-select\", \"vertical-align\", \"visibility\", \"-webkit-animation\", \"-webkit-animation-delay\", \"-webkit-animation-direction\", \"-webkit-animation-duration\", \"-webkit-animation-fill-mode\", \"-webkit-animation-iteration-count\", \"-webkit-animation-name\", \"-webkit-animation-play-state\", \"-webkit-animation-timing-function\", \"-webkit-appearance\", \"-webkit-backdrop-filter\", \"-webkit-backface-visibility\", \"-webkit-background-clip\", \"-webkit-background-composite\", \"-webkit-background-origin\", \"-webkit-border-image\", \"-webkit-box-align\", \"-webkit-box-direction\", \"-webkit-box-flex\", \"-webkit-box-flex-group\", \"-webkit-box-ordinal-group\", \"-webkit-box-orient\", \"-webkit-box-pack\", \"-webkit-box-reflect\", \"-webkit-box-sizing\", \"-webkit-break-after\", \"-webkit-break-before\", \"-webkit-break-inside\", \"-webkit-column-break-after\", \"-webkit-column-break-before\", \"-webkit-column-break-inside\", \"-webkit-column-count\", \"-webkit-column-gap\", \"-webkit-column-rule\", \"-webkit-column-rule-color\", \"-webkit-column-rule-style\", \"-webkit-column-rule-width\", \"-webkit-columns\", \"-webkit-column-span\", \"-webkit-column-width\", \"-webkit-filter\", \"-webkit-flow-from\", \"-webkit-flow-into\", \"-webkit-font-feature-settings\", \"-webkit-hyphens\", \"-webkit-line-break\", \"-webkit-margin-bottom-collapse\", \"-webkit-margin-collapse\", \"-webkit-margin-start\", \"-webkit-margin-top-collapse\", \"-webkit-mask-clip\", \"-webkit-mask-image\", \"-webkit-mask-origin\", \"-webkit-mask-repeat\", \"-webkit-mask-size\", \"-webkit-nbsp-mode\", \"-webkit-overflow-scrolling\", \"-webkit-padding-start\", \"-webkit-perspective\", \"-webkit-perspective-origin\", \"-webkit-region-fragment\", \"-webkit-tap-highlight-color\", \"-webkit-text-fill-color\", \"-webkit-text-size-adjust\", \"-webkit-text-stroke\", \"-webkit-text-stroke-color\", \"-webkit-text-stroke-width\", \"-webkit-touch-callout\", \"-webkit-transform\", \"-webkit-transform-origin\", \"-webkit-transform-origin-x\", \"-webkit-transform-origin-y\", \"-webkit-transform-origin-z\", \"-webkit-transform-style\", \"-webkit-transition\", \"-webkit-transition-delay\", \"-webkit-transition-duration\", \"-webkit-transition-property\", \"-webkit-transition-timing-function\", \"-webkit-user-drag\", \"-webkit-user-modify\", \"-webkit-user-select\", \"white-space\", \"widows\", \"width\", \"will-change\", \"word-break\", \"word-spacing\", \"word-wrap\", \"writing-mode\", \"z-index\", \"zoom\"]\n};\nvar htmlData = {\n    \"tags\": [\n        \"body\", \"head\", \"html\",\n        \"address\", \"blockquote\", \"dd\", \"div\", \"section\", \"article\", \"aside\", \"header\", \"footer\", \"nav\", \"menu\", \"dl\", \"dt\", \"fieldset\", \"form\", \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"iframe\", \"noframes\", \"object\", \"ol\", \"p\", \"ul\", \"applet\", \"center\", \"dir\", \"hr\", \"pre\",\n        \"a\", \"abbr\", \"acronym\", \"area\", \"b\", \"base\", \"basefont\", \"bdo\", \"big\", \"br\", \"button\", \"caption\", \"cite\", \"code\", \"col\", \"colgroup\", \"del\", \"dfn\", \"em\", \"font\", \"i\", \"img\", \"input\", \"ins\", \"isindex\", \"kbd\", \"label\", \"legend\", \"li\", \"link\", \"map\", \"meta\", \"noscript\", \"optgroup\", \"option\", \"param\", \"q\", \"s\", \"samp\", \"script\", \"select\", \"small\", \"span\", \"strike\", \"strong\", \"style\", \"sub\", \"sup\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"title\", \"tr\", \"tt\", \"u\", \"var\",\n        \"canvas\", \"main\", \"figure\", \"plaintext\", \"figcaption\", \"hgroup\", \"details\", \"summary\"\n    ]\n};\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar snippetKeyCache = new Map();\nvar markupSnippetKeys;\nvar stylesheetCustomSnippetsKeyCache = new Map();\nvar htmlAbbreviationStartRegex = /^[a-z,A-Z,!,(,[,#,\\.\\{]/;\n// take off { for jsx because it interferes with the language\nvar jsxAbbreviationStartRegex = /^[a-z,A-Z,!,(,[,#,\\.]/;\nvar cssAbbreviationRegex = /^-?[a-z,A-Z,!,@,#]/;\nvar htmlAbbreviationRegex = /[a-z,A-Z\\.]/;\nvar commonlyUsedTags = __spreadArray(__spreadArray([], htmlData.tags, true), ['lorem'], false);\nvar bemFilterSuffix = 'bem';\nvar filterDelimitor = '|';\nvar trimFilterSuffix = 't';\nvar commentFilterSuffix = 'c';\nvar maxFilters = 3;\n/**\n * Returns all applicable emmet expansions for abbreviation at given position in a CompletionList\n * @param model TextModel in which completions are requested\n * @param position Position in the document at which completions are requested\n * @param syntax Emmet supported language\n * @param emmetConfig Emmet Configurations as derived from VS Code\n */\nfunction doComplete(monaco, model, position, syntax, emmetConfig) {\n    var _a;\n    var isStyleSheetRes = isStyleSheet(syntax);\n    // Fetch markupSnippets so that we can provide possible abbreviation completions\n    // For example, when text at position is `a`, completions should return `a:blank`, `a:link`, `acr` etc.\n    if (!isStyleSheetRes) {\n        if (!snippetKeyCache.has(syntax)) {\n            var registry = getDefaultSnippets(syntax);\n            snippetKeyCache.set(syntax, Object.keys(registry));\n        }\n        markupSnippetKeys = (_a = snippetKeyCache.get(syntax)) !== null && _a !== void 0 ? _a : [];\n    }\n    var extractOptions = {\n        lookAhead: !isStyleSheetRes,\n        type: getSyntaxType(syntax),\n    };\n    var extractedValue = extractAbbreviation(monaco, model, position, extractOptions);\n    if (!extractedValue)\n        return;\n    var abbreviationRange = extractedValue.abbreviationRange, abbreviation = extractedValue.abbreviation, currentLineTillPosition = extractedValue.currentLineTillPosition, filter = extractedValue.filter;\n    var currentWord = getCurrentWord(currentLineTillPosition);\n    // Don't attempt to expand open tags\n    if (currentWord === abbreviation && currentLineTillPosition.endsWith(\"<\".concat(abbreviation)) && !isStyleSheetRes) {\n        return;\n    }\n    var expandOptions = getExpandOptions(syntax, filter);\n    var expandedText = '';\n    var expandedAbbr;\n    var completionItems = [];\n    // Create completion item after expanding given abbreviation\n    // if abbreviation is valid and expanded value is not noise\n    var createExpandedAbbr = function (syntax, abbr) {\n        if (!isAbbreviationValid(syntax, abbreviation))\n            return;\n        try {\n            expandedText = expandAbbreviation$1(abbr, expandOptions);\n            // manually patch https://github.com/microsoft/vscode/issues/120245 for now\n            if (isStyleSheetRes && '!important'.startsWith(abbr)) {\n                expandedText = '!important';\n            }\n        }\n        catch (e) { }\n        if (!expandedText || isExpandedTextNoise(syntax, abbr, expandedText, expandOptions.options)) {\n            return;\n        }\n        expandedAbbr = {\n            kind: monaco.languages.CompletionItemKind.Property,\n            label: abbreviation + (filter ? '|' + filter.replace(',', '|') : ''),\n            documentation: replaceTabStopsWithCursors(expandedText),\n            detail: 'Emmet abbreviation',\n            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,\n            range: abbreviationRange,\n            insertText: escapeNonTabStopDollar(addFinalTabStop(expandedText)),\n        };\n        completionItems = [expandedAbbr];\n    };\n    createExpandedAbbr(syntax, abbreviation);\n    if (isStyleSheetRes) {\n        // When abbr is longer than usual emmet snippets and matches better with existing css property, then no emmet\n        if (abbreviation.length > 4 && cssData.properties.some(function (x) { return x.startsWith(abbreviation); })) {\n            return { suggestions: [], incomplete: true };\n        }\n        if (expandedAbbr && expandedText.length) {\n            expandedAbbr.range = abbreviationRange;\n            expandedAbbr.insertText = escapeNonTabStopDollar(addFinalTabStop(expandedText));\n            expandedAbbr.documentation = replaceTabStopsWithCursors(expandedText);\n            expandedAbbr.label = removeTabStops(expandedText);\n            expandedAbbr.filterText = abbreviation;\n            // Custom snippets should show up in completions if abbreviation is a prefix\n            var stylesheetCustomSnippetsKeys = stylesheetCustomSnippetsKeyCache.has(syntax)\n                ? stylesheetCustomSnippetsKeyCache.get(syntax)\n                : stylesheetCustomSnippetsKeyCache.get('css');\n            completionItems = makeSnippetSuggestion(monaco, stylesheetCustomSnippetsKeys !== null && stylesheetCustomSnippetsKeys !== void 0 ? stylesheetCustomSnippetsKeys : [], abbreviation, abbreviation, abbreviationRange, expandOptions, 'Emmet Custom Snippet', false);\n            if (!completionItems.find(function (x) { return x.insertText === (expandedAbbr === null || expandedAbbr === void 0 ? void 0 : expandedAbbr.insertText); })) {\n                // Fix for https://github.com/Microsoft/vscode/issues/28933#issuecomment-309236902\n                // When user types in propertyname, emmet uses it to match with snippet names, resulting in width -> widows or font-family -> font: family\n                // Filter out those cases here.\n                var abbrRegex = new RegExp('.*' +\n                    abbreviation\n                        .split('')\n                        .map(function (x) { return (x === '$' || x === '+' ? '\\\\' + x : x); })\n                        .join('.*') +\n                    '.*', 'i');\n                if (/\\d/.test(abbreviation) || abbrRegex.test(expandedAbbr.label)) {\n                    completionItems.push(expandedAbbr);\n                }\n            }\n        }\n    }\n    else {\n        var tagToFindMoreSuggestionsFor = abbreviation;\n        var newTagMatches = abbreviation.match(/(>|\\+)([\\w:-]+)$/);\n        if (newTagMatches && newTagMatches.length === 3) {\n            tagToFindMoreSuggestionsFor = newTagMatches[2];\n        }\n        if (syntax !== 'xml') {\n            var commonlyUsedTagSuggestions = makeSnippetSuggestion(monaco, commonlyUsedTags, tagToFindMoreSuggestionsFor, abbreviation, abbreviationRange, expandOptions, 'Emmet Abbreviation');\n            completionItems = completionItems.concat(commonlyUsedTagSuggestions);\n        }\n        if (emmetConfig.showAbbreviationSuggestions === true) {\n            var abbreviationSuggestions = makeSnippetSuggestion(monaco, markupSnippetKeys.filter(function (x) { return !commonlyUsedTags.includes(x); }), tagToFindMoreSuggestionsFor, abbreviation, abbreviationRange, expandOptions, 'Emmet Abbreviation');\n            // Workaround for the main expanded abbr not appearing before the snippet suggestions\n            if (expandedAbbr && abbreviationSuggestions.length > 0 && tagToFindMoreSuggestionsFor !== abbreviation) {\n                expandedAbbr.sortText = '0' + expandedAbbr.label;\n                abbreviationSuggestions.forEach(function (item) {\n                    // Workaround for snippet suggestions items getting filtered out as the complete abbr does not start with snippetKey\n                    item.filterText = abbreviation;\n                    // Workaround for the main expanded abbr not appearing before the snippet suggestions\n                    item.sortText = '9' + abbreviation;\n                });\n            }\n            completionItems = completionItems.concat(abbreviationSuggestions);\n        }\n        // https://github.com/microsoft/vscode/issues/66680\n        if (syntax === 'html' &&\n            completionItems.length >= 2 &&\n            abbreviation.includes(':') &&\n            (expandedAbbr === null || expandedAbbr === void 0 ? void 0 : expandedAbbr.insertText) === \"<\".concat(abbreviation, \">${0}</\").concat(abbreviation, \">\")) {\n            completionItems = completionItems.filter(function (item) { return item.label !== abbreviation; });\n        }\n    }\n    if (emmetConfig.showSuggestionsAsSnippets === true) {\n        completionItems.forEach(function (x) { return (x.kind = monaco.languages.CompletionItemKind.Snippet); });\n    }\n    return completionItems.length ? { suggestions: completionItems, incomplete: true } : undefined;\n}\n/**\n * Create & return snippets for snippet keys that start with given prefix\n */\nfunction makeSnippetSuggestion(monaco, snippetKeys, prefix, abbreviation, abbreviationRange, expandOptions, snippetDetail, skipFullMatch) {\n    if (skipFullMatch === void 0) { skipFullMatch = true; }\n    if (!prefix || !snippetKeys) {\n        return [];\n    }\n    var snippetCompletions = [];\n    snippetKeys.forEach(function (snippetKey) {\n        if (!snippetKey.startsWith(prefix.toLowerCase()) || (skipFullMatch && snippetKey === prefix.toLowerCase())) {\n            return;\n        }\n        var currentAbbr = abbreviation + snippetKey.substr(prefix.length);\n        var expandedAbbr;\n        try {\n            expandedAbbr = expandAbbreviation$1(currentAbbr, expandOptions);\n        }\n        catch (e) { }\n        if (!expandedAbbr) {\n            return;\n        }\n        var item = {\n            kind: monaco.languages.CompletionItemKind.Property,\n            label: prefix + snippetKey.substr(prefix.length),\n            documentation: replaceTabStopsWithCursors(expandedAbbr),\n            detail: snippetDetail,\n            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,\n            range: abbreviationRange,\n            insertText: escapeNonTabStopDollar(addFinalTabStop(expandedAbbr)),\n        };\n        snippetCompletions.push(item);\n    });\n    return snippetCompletions;\n}\nfunction getCurrentWord(currentLineTillPosition) {\n    if (currentLineTillPosition) {\n        var matches = currentLineTillPosition.match(/[\\w,:,-,\\.]*$/);\n        if (matches) {\n            return matches[0];\n        }\n    }\n}\nfunction replaceTabStopsWithCursors(expandedWord) {\n    return expandedWord.replace(/([^\\\\])\\$\\{\\d+\\}/g, '$1|').replace(/\\$\\{\\d+:([^\\}]+)\\}/g, '$1');\n}\nfunction removeTabStops(expandedWord) {\n    return expandedWord.replace(/([^\\\\])\\$\\{\\d+\\}/g, '$1').replace(/\\$\\{\\d+:([^\\}]+)\\}/g, '$1');\n}\nfunction escapeNonTabStopDollar(text) {\n    return text ? text.replace(/([^\\\\])(\\$)([^\\{])/g, '$1\\\\$2$3') : text;\n}\nfunction addFinalTabStop(text) {\n    if (!text || !text.trim()) {\n        return text;\n    }\n    var maxTabStop = -1;\n    var maxTabStopRanges = [];\n    var foundLastStop = false;\n    var replaceWithLastStop = false;\n    var i = 0;\n    var n = text.length;\n    try {\n        while (i < n && !foundLastStop) {\n            // Look for ${\n            if (text[i++] != '$' || text[i++] != '{') {\n                continue;\n            }\n            // Find tabstop\n            var numberStart = -1;\n            var numberEnd = -1;\n            while (i < n && /\\d/.test(text[i])) {\n                numberStart = numberStart < 0 ? i : numberStart;\n                numberEnd = i + 1;\n                i++;\n            }\n            // If ${ was not followed by a number and either } or :, then its not a tabstop\n            if (numberStart === -1 || numberEnd === -1 || i >= n || (text[i] != '}' && text[i] != ':')) {\n                continue;\n            }\n            // If ${0} was found, then break\n            var currentTabStop = text.substring(numberStart, numberEnd);\n            foundLastStop = currentTabStop === '0';\n            if (foundLastStop) {\n                break;\n            }\n            var foundPlaceholder = false;\n            if (text[i++] == ':') {\n                // TODO: Nested placeholders may break here\n                while (i < n) {\n                    if (text[i] == '}') {\n                        foundPlaceholder = true;\n                        break;\n                    }\n                    i++;\n                }\n            }\n            // Decide to replace currentTabStop with ${0} only if its the max among all tabstops and is not a placeholder\n            if (Number(currentTabStop) > Number(maxTabStop)) {\n                maxTabStop = Number(currentTabStop);\n                maxTabStopRanges = [{ numberStart: numberStart, numberEnd: numberEnd }];\n                replaceWithLastStop = !foundPlaceholder;\n            }\n            else if (Number(currentTabStop) === maxTabStop) {\n                maxTabStopRanges.push({ numberStart: numberStart, numberEnd: numberEnd });\n            }\n        }\n    }\n    catch (e) { }\n    if (replaceWithLastStop && !foundLastStop) {\n        for (var i_1 = 0; i_1 < maxTabStopRanges.length; i_1++) {\n            var rangeStart = maxTabStopRanges[i_1].numberStart;\n            var rangeEnd = maxTabStopRanges[i_1].numberEnd;\n            text = text.substr(0, rangeStart) + '0' + text.substr(rangeEnd);\n        }\n    }\n    return text;\n}\nvar emmetSnippetField = function (index, placeholder) { return \"${\".concat(index).concat(placeholder ? ':' + placeholder : '', \"}\"); };\n/** Returns whether or not syntax is a supported stylesheet syntax, like CSS */\nfunction isStyleSheet(syntax) {\n    return syntax === 'css';\n}\n/** Returns the syntax type, either markup (e.g. for HTML) or stylesheet (e.g. for CSS) */\nfunction getSyntaxType(syntax) {\n    return isStyleSheet(syntax) ? 'stylesheet' : 'markup';\n}\n/** Returns the default snippets that Emmet suggests */\nfunction getDefaultSnippets(syntax) {\n    var syntaxType = getSyntaxType(syntax);\n    var emptyUserConfig = { type: syntaxType, syntax: syntax };\n    var resolvedConfig = resolveConfig(emptyUserConfig);\n    // https://github.com/microsoft/vscode/issues/97632\n    // don't return markup (HTML) snippets for XML\n    return syntax === 'xml' ? {} : resolvedConfig.snippets;\n}\nfunction getFilters(text, pos) {\n    var filter;\n    for (var i = 0; i < maxFilters; i++) {\n        if (text.endsWith(\"\".concat(filterDelimitor).concat(bemFilterSuffix), pos)) {\n            pos -= bemFilterSuffix.length + 1;\n            filter = filter ? bemFilterSuffix + ',' + filter : bemFilterSuffix;\n        }\n        else if (text.endsWith(\"\".concat(filterDelimitor).concat(commentFilterSuffix), pos)) {\n            pos -= commentFilterSuffix.length + 1;\n            filter = filter ? commentFilterSuffix + ',' + filter : commentFilterSuffix;\n        }\n        else if (text.endsWith(\"\".concat(filterDelimitor).concat(trimFilterSuffix), pos)) {\n            pos -= trimFilterSuffix.length + 1;\n            filter = filter ? trimFilterSuffix + ',' + filter : trimFilterSuffix;\n        }\n        else {\n            break;\n        }\n    }\n    return {\n        pos: pos,\n        filter: filter,\n    };\n}\n/**\n * Extracts abbreviation from the given position in the given document\n * @param model The TextModel from which abbreviation needs to be extracted\n * @param position The Position in the given document from where abbreviation needs to be extracted\n * @param options The options to pass to the @emmetio/extract-abbreviation module\n */\nfunction extractAbbreviation(monaco, model, position, options) {\n    var currentLine = model.getLineContent(position.lineNumber);\n    var currentLineTillPosition = currentLine.substr(0, position.column - 1);\n    var _a = getFilters(currentLineTillPosition, position.column - 1), pos = _a.pos, filter = _a.filter;\n    var lengthOccupiedByFilter = filter ? filter.length + 1 : 0;\n    var result = extractAbbreviation$1(currentLine, pos, options);\n    if (!result)\n        return;\n    var rangeToReplace = new monaco.Range(position.lineNumber, result.location + 1, position.lineNumber, result.location + result.abbreviation.length + lengthOccupiedByFilter + 1);\n    return {\n        abbreviationRange: rangeToReplace,\n        abbreviation: result.abbreviation,\n        currentLineTillPosition: currentLineTillPosition,\n        filter: filter,\n    };\n}\n/**\n * Returns a boolean denoting validity of given abbreviation in the context of given syntax\n * Not needed once https://github.com/emmetio/atom-plugin/issues/22 is fixed\n * @param syntax string\n * @param abbreviation string\n */\nfunction isAbbreviationValid(syntax, abbreviation) {\n    if (!abbreviation) {\n        return false;\n    }\n    if (isStyleSheet(syntax)) {\n        if (abbreviation.includes('#')) {\n            if (abbreviation.startsWith('#')) {\n                var hexColorRegex = /^#[\\d,a-f,A-F]{1,6}$/;\n                return hexColorRegex.test(abbreviation);\n            }\n            else if (commonlyUsedTags.includes(abbreviation.substring(0, abbreviation.indexOf('#')))) {\n                return false;\n            }\n        }\n        return cssAbbreviationRegex.test(abbreviation);\n    }\n    if (abbreviation.startsWith('!')) {\n        return !/[^!]/.test(abbreviation);\n    }\n    // Its common for users to type (sometextinsidebrackets), this should not be treated as an abbreviation\n    // Grouping in abbreviation is valid only if it's inside a text node or preceeded/succeeded with one of the symbols for nesting, sibling, repeater or climb up\n    // Also, cases such as `span[onclick=\"alert();\"]` are valid\n    if ((/\\(/.test(abbreviation) || /\\)/.test(abbreviation)) &&\n        !/\\{[^\\}\\{]*[\\(\\)]+[^\\}\\{]*\\}(?:[>\\+\\*\\^]|$)/.test(abbreviation) &&\n        !/\\(.*\\)[>\\+\\*\\^]/.test(abbreviation) &&\n        !/\\[[^\\[\\]\\(\\)]+=\".*\"\\]/.test(abbreviation) &&\n        !/[>\\+\\*\\^]\\(.*\\)/.test(abbreviation)) {\n        return false;\n    }\n    if (syntax === 'jsx') {\n        return jsxAbbreviationStartRegex.test(abbreviation) && htmlAbbreviationRegex.test(abbreviation);\n    }\n    return htmlAbbreviationStartRegex.test(abbreviation) && htmlAbbreviationRegex.test(abbreviation);\n}\nfunction isExpandedTextNoise(syntax, abbreviation, expandedText, options) {\n    var _a, _b;\n    // Unresolved css abbreviations get expanded to a blank property value\n    // Eg: abc -> abc: ; or abc:d -> abc: d; which is noise if it gets suggested for every word typed\n    if (isStyleSheet(syntax) && options) {\n        var between = (_a = options['stylesheet.between']) !== null && _a !== void 0 ? _a : ': ';\n        var after = (_b = options['stylesheet.after']) !== null && _b !== void 0 ? _b : ';';\n        // Remove overlapping between `abbreviation` and `between`, if any\n        var endPrefixIndex = abbreviation.indexOf(between[0], Math.max(abbreviation.length - between.length, 0));\n        endPrefixIndex = endPrefixIndex >= 0 ? endPrefixIndex : abbreviation.length;\n        var abbr = abbreviation.substring(0, endPrefixIndex);\n        return (expandedText === \"\".concat(abbr).concat(between, \"${0}\").concat(after) ||\n            expandedText.replace(/\\s/g, '') === abbreviation.replace(/\\s/g, '') + after);\n    }\n    // we don't want common html tags suggested for xml\n    if (syntax === 'xml' && commonlyUsedTags.some(function (tag) { return tag.startsWith(abbreviation.toLowerCase()); })) {\n        return true;\n    }\n    if (commonlyUsedTags.includes(abbreviation.toLowerCase()) || markupSnippetKeys.includes(abbreviation)) {\n        return false;\n    }\n    // Custom tags can have - or :\n    if (/[-,:]/.test(abbreviation) && !/--|::/.test(abbreviation) && !abbreviation.endsWith(':')) {\n        return false;\n    }\n    // Its common for users to type some text and end it with period, this should not be treated as an abbreviation\n    // Else it becomes noise.\n    // When user just types '.', return the expansion\n    // Otherwise emmet loses change to participate later\n    // For example in `.foo`. See https://github.com/Microsoft/vscode/issues/66013\n    if (abbreviation === '.') {\n        return false;\n    }\n    var dotMatches = abbreviation.match(/^([a-z,A-Z,\\d]*)\\.$/);\n    if (dotMatches) {\n        // Valid html tags such as `div.`\n        if (dotMatches[1] && htmlData.tags.includes(dotMatches[1])) {\n            return false;\n        }\n        return true;\n    }\n    // Fix for https://github.com/microsoft/vscode/issues/89746\n    // PascalCase tags are common in jsx code, which should not be treated as noise.\n    // Eg: MyAwesomComponent -> <MyAwesomComponent></MyAwesomComponent>\n    if (syntax === 'jsx' && /^([A-Z][A-Za-z0-9]*)+$/.test(abbreviation)) {\n        return false;\n    }\n    // Unresolved html abbreviations get expanded as if it were a tag\n    // Eg: abc -> <abc></abc> which is noise if it gets suggested for every word typed\n    return expandedText.toLowerCase() === \"<\".concat(abbreviation.toLowerCase(), \">${1}</\").concat(abbreviation.toLowerCase(), \">\");\n}\n/**\n * Returns options to be used by emmet\n */\nfunction getExpandOptions(syntax, filter) {\n    var type = getSyntaxType(syntax);\n    var filters = filter ? filter.split(',').map(function (x) { return x.trim(); }) : [];\n    var bemEnabled = filters.includes('bem');\n    var commentEnabled = filters.includes('c');\n    var combinedOptions = {\n        'output.formatSkip': ['html'],\n        'output.formatForce': ['body'],\n        'output.field': emmetSnippetField,\n        'output.inlineBreak': 0,\n        'output.compactBoolean': false,\n        'output.reverseAttributes': false,\n        'markup.href': true,\n        'comment.enabled': commentEnabled,\n        'comment.trigger': ['id', 'class'],\n        'comment.before': '',\n        'comment.after': '\\n<!-- /[#ID][.CLASS] -->',\n        'bem.enabled': bemEnabled,\n        'bem.element': '__',\n        'bem.modifier': '_',\n        'jsx.enabled': syntax === 'jsx',\n        'stylesheet.shortHex': true,\n        'stylesheet.between': syntax === 'stylus' ? ' ' : ': ',\n        'stylesheet.after': syntax === 'sass' || syntax === 'stylus' ? '' : ';',\n        'stylesheet.intUnit': 'px',\n        'stylesheet.floatUnit': 'em',\n        'stylesheet.unitAliases': {\n            e: 'em',\n            p: '%',\n            x: 'ex',\n            r: 'rem',\n        },\n        'stylesheet.fuzzySearchMinScore': 0.3,\n        'output.format': true,\n        'output.selfClosingStyle': 'html',\n    };\n    return {\n        type: type,\n        options: combinedOptions,\n        variables: {},\n        snippets: {},\n        syntax: syntax,\n        // context: null,\n        text: undefined,\n        maxRepeat: 1000,\n        // cache: null\n    };\n}\n/**\n * Expands given abbreviation using given options\n * @param abbreviation string or parsed abbreviation\n * @param config options used by the @emmetio/expand-abbreviation module to expand given abbreviation\n */\nfunction expandAbbreviation(abbreviation, config) {\n    var expandedText;\n    var resolvedConfig = resolveConfig(config);\n    if (config.type === 'stylesheet') {\n        if (typeof abbreviation === 'string') {\n            expandedText = expandAbbreviation$1(abbreviation, resolvedConfig);\n        }\n        else {\n            expandedText = css(abbreviation, resolvedConfig);\n        }\n    }\n    else {\n        if (typeof abbreviation === 'string') {\n            expandedText = expandAbbreviation$1(abbreviation, resolvedConfig);\n        }\n        else {\n            expandedText = stringify(abbreviation, resolvedConfig);\n        }\n    }\n    return escapeNonTabStopDollar(addFinalTabStop(expandedText));\n}\n\nfunction isValidEmmetToken(tokens, index, syntax, language) {\n    var currentTokenType = tokens[index].type;\n    if (syntax === 'html') {\n        // prevent emmet triggered within attributes\n        return ((currentTokenType === '' && (index === 0 || tokens[index - 1].type === 'delimiter.html')) ||\n            // #7 compatible with https://github.com/NeekSandhu/monaco-textmate\n            tokens[0].type === 'text.html.basic');\n    }\n    if (syntax === 'css') {\n        if (currentTokenType === '')\n            return true;\n        // less / scss allow nesting\n        return currentTokenType === 'tag.' + language;\n    }\n    if (syntax === 'jsx') {\n        // type must be `identifier` and not at start\n        return (!!index &&\n            ['identifier.js', 'type.identifier.js', 'identifier.ts', 'type.identifier.ts'].includes(currentTokenType));\n    }\n    return false;\n}\n// vscode did a complex node analysis, we just use monaco's built-in tokenizer\n// to achieve almost the same effect\nfunction isValidLocationForEmmetAbbreviation(model, position, syntax, language) {\n    var column = position.column, lineNumber = position.lineNumber;\n    // get current line's tokens\n    var _tokenization = model._tokenization;\n    var _tokenizationStateStore = _tokenization._tokenizationStateStore;\n    // monaco-editor 0.32.0 changes the api to `_tokenizationStateStore.tokenizationSupport`\n    var _tokenizationSupport = _tokenizationStateStore.tokenizationSupport || _tokenization._tokenizationSupport;\n    var state = _tokenizationStateStore.getBeginState(lineNumber - 1).clone();\n    var tokenizationResult = _tokenizationSupport.tokenize(model.getLineContent(lineNumber), true, state, 0);\n    var tokens = tokenizationResult.tokens;\n    var valid = false;\n    // get token type at current column\n    for (var i = tokens.length - 1; i >= 0; i--) {\n        if (column - 1 > tokens[i].offset) {\n            valid = isValidEmmetToken(tokens, i, syntax, language);\n            break;\n        }\n    }\n    return valid;\n}\n\n// https://github.com/microsoft/vscode/blob/main/extensions/emmet/src/util.ts#L86\nvar LANGUAGE_MODES = {\n    html: ['!', '.', '}', ':', '*', '$', ']', '/', '>', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    jade: ['!', '.', '}', ':', '*', '$', ']', '/', '>', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    slim: ['!', '.', '}', ':', '*', '$', ']', '/', '>', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    haml: ['!', '.', '}', ':', '*', '$', ']', '/', '>', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    xml: ['.', '}', '*', '$', ']', '/', '>', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    xsl: ['!', '.', '}', '*', '$', '/', ']', '>', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    css: [':', '!', '-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    scss: [':', '!', '-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    sass: [':', '!', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    less: [':', '!', '-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    stylus: [':', '!', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    javascript: ['!', '.', '}', '*', '$', ']', '/', '>', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    typescript: ['!', '.', '}', '*', '$', ']', '/', '>', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n};\n// https://github.com/microsoft/vscode/blob/main/extensions/emmet/src/util.ts#L124\nvar MAPPED_MODES = {\n    handlebars: 'html',\n    php: 'html',\n    twig: 'html',\n};\nvar DEFAULT_CONFIG = {\n    showExpandedAbbreviation: 'always',\n    showAbbreviationSuggestions: true,\n    showSuggestionsAsSnippets: false,\n};\n/**\n * add completion provider\n * @param monaco monaco self\n * @param language added language\n * @param isMarkup is markup language\n * @param isLegalToken check whether given token is legal or not\n * @param getLegalEmmetSets get legal emmet substring from a string.\n */\nfunction registerProvider(monaco, languages, syntax) {\n    if (!monaco) {\n        console.error(\"emmet-monaco-es: 'monaco' should be either declared on window or passed as first parameter\");\n        return;\n    }\n    var providers = languages.map(function (language) {\n        return monaco.languages.registerCompletionItemProvider(language, {\n            triggerCharacters: LANGUAGE_MODES[MAPPED_MODES[language] || language],\n            provideCompletionItems: function (model, position) {\n                return isValidLocationForEmmetAbbreviation(model, position, syntax, language)\n                    ? doComplete(monaco, model, position, syntax, DEFAULT_CONFIG)\n                    : undefined;\n            },\n        });\n    });\n    return function () {\n        providers.forEach(function (provider) { return provider.dispose(); });\n    };\n}\nfunction emmetHTML(monaco, languages) {\n    if (monaco === void 0) { monaco = window.monaco; }\n    if (languages === void 0) { languages = ['html']; }\n    return registerProvider(monaco, languages, 'html');\n}\nfunction emmetCSS(monaco, languages) {\n    if (monaco === void 0) { monaco = window.monaco; }\n    if (languages === void 0) { languages = ['css']; }\n    return registerProvider(monaco, languages, 'css');\n}\nfunction emmetJSX(monaco, languages) {\n    if (monaco === void 0) { monaco = window.monaco; }\n    if (languages === void 0) { languages = ['javascript']; }\n    return registerProvider(monaco, languages, 'jsx');\n}\n\nexport { emmetCSS, emmetHTML, emmetJSX, expandAbbreviation };\n","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import rng from './rng.js';\nimport stringify from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport default v4;"],"names":["module","exports","obj","__esModule","_interopRequireDefault","require","_createSvgIcon","_jsxRuntime","_default","default","jsx","d","createSvgIcon","_jsx","Object","defineProperty","value","enumerable","get","_utils","funcs","reduce","acc","func","args","apply","this","timeout","wait","debounced","later","clearTimeout","setTimeout","clear","validator","reason","element","muiNames","React","indexOf","type","muiName","ownerDocument","node","document","defaultView","window","componentNameInError","Component","setRef","ref","current","globalId","maybeReactUseId","idOverride","undefined","reactId","defaultId","setDefaultId","id","useGlobalId","props","propName","componentName","location","propFullName","controlled","defaultProp","isControlled","name","state","valueState","setValue","newValue","fn","useEnhancedEffect","hadFocusVisibleRecentlyTimeout","refA","refB","refValue","hadKeyboardEvent","hadFocusVisibleRecently","inputTypesWhitelist","text","search","url","tel","email","password","number","date","month","week","time","datetime","handleKeyDown","event","metaKey","altKey","ctrlKey","handlePointerDown","handleVisibilityChange","visibilityState","isFocusVisible","target","matches","error","tagName","readOnly","isContentEditable","focusTriggersKeyboardModality","doc","addEventListener","isFocusVisibleRef","onFocus","onBlur","unstable_ClassNameGenerator","configure","generator","console","warn","join","ClassNameGenerator","responsiveArray","responsiveMap","xs","sm","md","lg","xl","xxl","subscribers","Map","subUid","screens","responsiveObserve","matchHandlers","dispatch","pointMap","forEach","size","subscribe","register","set","unsubscribe","token","unregister","_this","keys","screen","matchMediaQuery","handler","mql","removeListener","listener","_this2","_ref","_extends","_defineProperty","matchMedia","addListener","__rest","s","e","t","p","prototype","hasOwnProperty","call","getOwnPropertySymbols","i","length","propertyIsEnumerable","Row","tuple","_classNames","customizePrefixCls","prefixCls","justify","align","className","style","children","_props$gutter","gutter","wrap","others","_React$useContext","ConfigContext","getPrefixCls","direction","_React$useState","_React$useState2","_slicedToArray","setScreens","supportFlexGap","useFlexGapSupport","gutterRef","ResponsiveObserve","currentGutter","Array","isArray","_typeof","gutters","results","g","index","breakpoint","getGutter","classes","classNames","concat","rowStyle","horizontalGutter","verticalGutter","marginLeft","marginRight","_gutters","rowGap","marginTop","marginBottom","_gutters2","gutterH","gutterV","rowContext","RowContext","displayName","__spreadArray","to","from","pack","arguments","ar","l","slice","isNumber$1","code","isAlpha$1","isAlphaNumericWord","isAlphaWord","isSpace","isWhiteSpace$3","isQuote$2","Scanner","str","start","end","string","pos","charCodeAt","match","ch","peek","ok","next","eof","eat","n","substring","message","ScannerError","Error","tokenScanner$1","tokens","peek$3","scanner","readable$1","consume$2","test","error$1","err","statements","options","result","elements","ctx","stack","element$2","group","push","isChildOperator","isSiblingOperator$1","isClimbOperator","pop","isGroupStart","isBracket$2","repeat","isRepeater","repeater","attr","elem","attributes","selfClose","isCapitalizedLiteral","isClassNameOperator","isElementName","elementName","isEmpty","getText","shortAttribute","attributeSet","isCloseOperator","isAttributeSetStart","attribute","isAttributeSetEnd","isWhiteSpace$2","isOperator$1","expression","literal$2","quoted","isEquals","quote","isQuote$1","single","allowBrackets","brackets","context","open","isTextStart","isOpen","Boolean","operator","isSingle","isLiteral$2","escaped","getToken$1","eatWhile","Number","consumePlaceholder$2","field$2","repeaterPlaceholder","reverse","base","parent","repeaterNumber","count","implicit","repeater$1","whiteSpace$1","isAllowedOperator","isElementName$1","isAllowedSpace","isAllowedRepeater","bracketType","literal$1$1","op","operatorType$1","operator$1","isOpenBracket$2","bracket$1","stream","operators","child","class","climb","equal","close","sibling","tokenVisitor","Literal","Quote","Bracket","Operator","Field","getVariable","RepeaterPlaceholder","repeaters","inserted","RepeaterNumber","lastIx","parentIx","Math","max","parentRepeater","String","WhiteSpace","stringify$1","urlRegex","emailRegex","convertStatement","items","original","assign","cleanText","isGroup","convertGroup","convertElement","last$1","deepest","deepestNode","insertText","repeatGuard","stringifyName","stringifyValue$1","selfClosing","convertAttribute","some","isField$1","item","attachRepeater","implied","isBoolean","valueType","shift","boolean","arr","insertHref","_a","href","startsWith","hrefAttribute","find","parseAbbreviation","abbr","textInserted","filter","trim","maxRepeat","POSITIVE_INFINITY","varValue","variables","convert","abbreviation","source","tokenize$1","getToken","short","consumePlaceholder$1","field$1","afterNegative","hasDecimal","prevPos","hasFloat","consumeNumber","rawValue","unit","numberValue","valueStart","color","alpha","isHex","colorAlpha","r","b","a","parseInt","parseColor","raw","createLiteral","colorValue","finished","stringValue","isBracket","bracket","whiteSpace","isIdentPrefix","isKeyword","isLiteral","literal$1","shouldConsumeDashAfter","mergeTokens","tokenScanner","peek$2","readable","consume$1","consumeProperty","valueFragment","important","valueMode","isLiteral$1","t1","t2","isFunctionStart","isValueDelimiter","isWhiteSpace$1","isImportant","consumeValue","isFragmentDelimiter","inArgument","isValue","consumeArguments","isOpenBracket$1","isCloseBracket$1","isArgumentDelimiter","isBracket$1","isOperator","isSiblingOperator","parse$2","tokenize","property","parser","mergeValue","prev","glue","append","mergeDeclarations","dest","src","config","findDeepest","isNode","walkResolve","resolve","resolved","mergeNodes","createOutputStream","level","offset","line","column","_push","processText","pushString","lines","split","splitByLines","il","pushNewline","indent","baseIndent","pushIndent","pushField","placeholder","field","attrName","strCase","attrQuote","isBooleanAttribute","includes","toLowerCase","isInline","inlineElements","toUpperCase","elementMap","ul","ol","table","tr","tbody","thead","tfoot","colgroup","select","optgroup","audio","video","object","map","resolveImplicitTag","ancestors","getParentElement","contextName","parentName","vocabularies","ru","sp","latin","reLorem","rand","floor","random","sample","len","iterations","min","sentence","words","word","val","insertCommas","hasComma","totalCommas","paragraph","dict","wordCount","startWithCommon","totalWords","common","rename","isAllowed","reElement","reModifier","blockCandidates1","blockCandidates2","bem","data","getBEMData","cl","ix","uniqueClass","block","findBlockName","updateClass","expandClassNames","path","prefix","m","originalClass","getBlockName","arrClassNames","expandShortNotation","_bem","classValue","stringifyValue","parseBEM","getBEMDataFromContext","depth","maxParentIx","walk$1","visitor","callback","createWalkState","out","caret","isSnippet","isInlineElement","isField","pushTokens","largestIndex","shouldOutputAttribute","template","consumePlaceholder","namePos","afterPos","isTokenStart","isToken","before","after","shouldComment","comment","enabled","trigger","output","attrs","htmlTagRegex","html","createCommentState","format","shouldFormat","getIndent","commentNodeBefore","pushAttribute","pushSnippet","innerFormat","hasNewline","exec","startsWithBlockTag","commentNodeAfter","lQuote","rQuote","fieldIx","findIndex","trimLeft","adjacentInline","indentFormat","element$1","primary","secondary","isPrimaryAttribute","collectAttributes","shouldFormat$1","beforeName","afterName","replace","pushPrimaryAttributes","beforeAttribute","booleanValue","glueAttribute","afterAttribute","pushSecondaryAttributes","splitByLines$1","lineLengths","maxLength","valueLength","beforeTextLine","afterTextLine","pushValue","formatters","haml","slim","pug","parse","oldTextValue","parseOpt","reversed","snippet","snippets","snippetAbbr","topNode","resolveSnippets","walk","transform","stringify","syntax","implicitTag","lookup","mergeAttributes","db","minWordCount","findRepeater","lorem","xsl","reProperty","opt","createSnippet","key","keywords","parsed","parseValue","collectKeywords","dependencies","snippetsSort","isProperty","cssVal","v","scoreMatch","str1","str2","partialMatch","str1Len","str2Len","minLength","j","score","ch1","ch2","found","acronym","matchRatio","delta","maxScore","sum","shortHex","isShortHex","toShortHex","toHex","asHex","values","frac","asRGB","num","digits","toFixed","hex","toString","pad","css","isJSON","_","letter","getSingleNumeric","getQuote","outputValue","propertyValue","outputImportant","outputToken","separator","prevEnd","gradientName","parse$1","cache","stylesheetSnippets","sort","cur","nest","convertSnippets","isValueScope","filteredSnippets","getSnippetsForScope","resolveNode","gradientFn","cssValue","resolveGradient","resolveValueKeywords","findBestMatch","inlineValue","lastPos","getUnmatchedPart","kw","resolveKeyword","defaultValue","hasField","wrapWithField","resolveAsProperty","reField","inputValue","literal","tail","resolveAsSnippet","aliases","unitless","resolveNumericValue","minScore","matchedItem","getScoringPart","dep","q","defaultSyntaxes","markup","stylesheet","defaultConfig","x","syntaxConfig","parseSnippets","xhtml","xml","sass","stylus","k","resolveConfig","globals","mergedData","typeDefaults","typeOverride","syntaxDefaults","syntaxOverride","backwardScanner","sol","peek$1","previous","consume","consumeWhile","isQuote","c","bracePairs","isHtml","isWhiteSpace","consumeIdent","consumeAttributeWithUnquotedValue","consumeAttribute","consumeQuoted","consumeAttributeWithQuotedValue","isCloseBracket","isOpenBracket","isUnquotedValue","isIdent","isAlpha","isNumber","isNaN","specialChars","defaultOptions$1","lookAhead","offsetPastAutoClosed","isCloseBrace","getStartOffset","compiledPrefix","consumePair","consumeArray","consumed","isAbbreviation","isOpenBrace","expandAbbreviation$1","resolvedConfig","markupSnippetKeys","cssData","htmlData","snippetKeyCache","stylesheetCustomSnippetsKeyCache","htmlAbbreviationStartRegex","jsxAbbreviationStartRegex","cssAbbreviationRegex","htmlAbbreviationRegex","commonlyUsedTags","tags","bemFilterSuffix","filterDelimitor","trimFilterSuffix","commentFilterSuffix","doComplete","monaco","model","position","emmetConfig","isStyleSheetRes","isStyleSheet","has","registry","getSyntaxType","getDefaultSnippets","extractOptions","extractedValue","currentLine","getLineContent","lineNumber","currentLineTillPosition","substr","endsWith","getFilters","lengthOccupiedByFilter","extractAbbreviation$1","abbreviationRange","Range","extractAbbreviation","currentWord","getCurrentWord","expandedAbbr","expandOptions","filters","bemEnabled","commentEnabled","emmetSnippetField","getExpandOptions","expandedText","completionItems","isAbbreviationValid","_b","between","endPrefixIndex","tag","dotMatches","isExpandedTextNoise","kind","languages","CompletionItemKind","Property","label","documentation","replaceTabStopsWithCursors","detail","insertTextRules","CompletionItemInsertTextRule","InsertAsSnippet","range","escapeNonTabStopDollar","addFinalTabStop","createExpandedAbbr","properties","suggestions","incomplete","filterText","stylesheetCustomSnippetsKeys","makeSnippetSuggestion","abbrRegex","RegExp","tagToFindMoreSuggestionsFor","newTagMatches","commonlyUsedTagSuggestions","showAbbreviationSuggestions","abbreviationSuggestions","sortText","showSuggestionsAsSnippets","Snippet","snippetKeys","snippetDetail","skipFullMatch","snippetCompletions","snippetKey","currentAbbr","expandedWord","maxTabStop","maxTabStopRanges","foundLastStop","replaceWithLastStop","numberStart","numberEnd","currentTabStop","foundPlaceholder","i_1","rangeStart","rangeEnd","isValidEmmetToken","language","currentTokenType","LANGUAGE_MODES","jade","scss","less","javascript","typescript","MAPPED_MODES","handlebars","php","twig","DEFAULT_CONFIG","showExpandedAbbreviation","registerProvider","providers","registerCompletionItemProvider","triggerCharacters","provideCompletionItems","_tokenization","_tokenizationStateStore","_tokenizationSupport","tokenizationSupport","getBeginState","clone","valid","isValidLocationForEmmetAbbreviation","provider","dispose","emmetHTML","emmetCSS","emmetJSX","getRandomValues","rnds8","Uint8Array","rng","crypto","bind","msCrypto","uuid","REGEX","byteToHex","validate","TypeError","buf","rnds"],"sourceRoot":""}