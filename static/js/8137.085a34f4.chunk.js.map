{"version":3,"file":"static/js/8137.085a34f4.chunk.js","mappings":"oIAAA","sources":["../node_modules/@types/lodash/common/function.d.ts"],"sourcesContent":["export default \"import _ = require(\\\"../index\\\");\\ndeclare module \\\"../index\\\" {\\n    interface LoDashStatic {\\n        /**\\n         * The opposite of _.before; this method creates a function that invokes func once it’s called n or more times.\\n         *\\n         * @param n The number of calls before func is invoked.\\n         * @param func The function to restrict.\\n         * @return Returns the new restricted function.\\n         */\\n        after<TFunc extends (...args: any[]) => any>(n: number, func: TFunc): TFunc;\\n    }\\n    interface Primitive<T> {\\n        /**\\n         * @see _.after\\n         */\\n        after<TFunc extends (...args: any[]) => any>(func: TFunc): Function<TFunc>;\\n    }\\n    interface PrimitiveChain<T> {\\n        /**\\n         * @see _.after\\n         */\\n        after<TFunc extends (...args: any[]) => any>(func: TFunc): FunctionChain<TFunc>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a function that accepts up to n arguments ignoring any additional arguments.\\n         *\\n         * @param func The function to cap arguments for.\\n         * @param n The arity cap.\\n         * @returns Returns the new function.\\n         */\\n        ary(func: (...args: any[]) => any, n?: number): (...args: any[]) => any;\\n    }\\n    interface Function<T extends (...args: any) => any> {\\n        /**\\n         * @see _.ary\\n         */\\n        ary(n?: number): Function<(...args: any[]) => any>;\\n    }\\n    interface FunctionChain<T extends (...args: any) => any> {\\n        /**\\n         * @see _.ary\\n         */\\n        ary(n?: number): FunctionChain<(...args: any[]) => any>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a function that invokes func, with the this binding and arguments of the created function, while\\n         * it’s called less than n times. Subsequent calls to the created function return the result of the last func\\n         * invocation.\\n         *\\n         * @param n The number of calls at which func is no longer invoked.\\n         * @param func The function to restrict.\\n         * @return Returns the new restricted function.\\n         */\\n        before<TFunc extends (...args: any[]) => any>(n: number, func: TFunc): TFunc;\\n    }\\n    interface Primitive<T> {\\n        /**\\n         * @see _.before\\n         */\\n        before<TFunc extends (...args: any[]) => any>(func: TFunc): Function<TFunc>;\\n    }\\n    interface PrimitiveChain<T> {\\n        /**\\n         * @see _.before\\n         */\\n        before<TFunc extends (...args: any[]) => any>(func: TFunc): FunctionChain<TFunc>;\\n    }\\n    interface FunctionBind {\\n        /**\\n         * @see _.placeholder\\n         */\\n        placeholder: __;\\n        (func: (...args: any[]) => any, thisArg: any, ...partials: any[]): (...args: any[]) => any;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a function that invokes func with the this binding of thisArg and prepends any additional _.bind\\n         * arguments to those provided to the bound function.\\n         *\\n         * The _.bind.placeholder value, which defaults to _ in monolithic builds, may be used as a placeholder for\\n         * partially applied arguments.\\n         *\\n         * Note: Unlike native Function#bind this method does not set the \\\"length\\\" property of bound functions.\\n         *\\n         * @param func The function to bind.\\n         * @param thisArg The this binding of func.\\n         * @param partials The arguments to be partially applied.\\n         * @return Returns the new bound function.\\n         */\\n        bind: FunctionBind;\\n    }\\n    interface LoDashImplicitWrapper<TValue> {\\n        /**\\n         * @see _.bind\\n         */\\n        bind(thisArg: any, ...partials: any[]): Function<(...args: any[]) => any>;\\n    }\\n    interface LoDashExplicitWrapper<TValue> {\\n        /**\\n         * @see _.bind\\n         */\\n        bind(thisArg: any, ...partials: any[]): FunctionChain<(...args: any[]) => any>;\\n    }\\n    interface FunctionBindKey {\\n        placeholder: __;\\n        (object: object, key: string, ...partials: any[]): (...args: any[]) => any;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a function that invokes the method at object[key] and prepends any additional _.bindKey arguments\\n         * to those provided to the bound function.\\n         *\\n         * This method differs from _.bind by allowing bound functions to reference methods that may be redefined\\n         * or don’t yet exist. See Peter Michaux’s article for more details.\\n         *\\n         * The _.bindKey.placeholder value, which defaults to _ in monolithic builds, may be used as a placeholder\\n         * for partially applied arguments.\\n         *\\n         * @param object The object the method belongs to.\\n         * @param key The key of the method.\\n         * @param partials The arguments to be partially applied.\\n         * @return Returns the new bound function.\\n         */\\n        bindKey: FunctionBindKey;\\n    }\\n    interface LoDashImplicitWrapper<TValue> {\\n        /**\\n         * @see _.bindKey\\n         */\\n        bindKey(key: string, ...partials: any[]): Function<(...args: any[]) => any>;\\n    }\\n    interface LoDashExplicitWrapper<TValue> {\\n        /**\\n         * @see _.bindKey\\n         */\\n        bindKey(key: string, ...partials: any[]): FunctionChain<(...args: any[]) => any>;\\n    }\\n    interface Curry {\\n        <T1, R>(func: (t1: T1) => R, arity?: number): CurriedFunction1<T1, R>;\\n        <T1, T2, R>(func: (t1: T1, t2: T2) => R, arity?: number): CurriedFunction2<T1, T2, R>;\\n        <T1, T2, T3, R>(func: (t1: T1, t2: T2, t3: T3) => R, arity?: number): CurriedFunction3<T1, T2, T3, R>;\\n        <T1, T2, T3, T4, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4) => R, arity?: number): CurriedFunction4<T1, T2, T3, T4, R>;\\n        <T1, T2, T3, T4, T5, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R, arity?: number): CurriedFunction5<T1, T2, T3, T4, T5, R>;\\n        (func: (...args: any[]) => any, arity?: number): (...args: any[]) => any;\\n        placeholder: __;\\n    }\\n    interface LoDashStatic {\\n        curry: Curry;\\n    }\\n    interface CurriedFunction1<T1, R> {\\n        (): CurriedFunction1<T1, R>;\\n        (t1: T1): R;\\n    }\\n    interface CurriedFunction2<T1, T2, R> {\\n        (): CurriedFunction2<T1, T2, R>;\\n        (t1: T1): CurriedFunction1<T2, R>;\\n        (t1: __, t2: T2): CurriedFunction1<T1, R>;\\n        (t1: T1, t2: T2): R;\\n    }\\n    interface CurriedFunction3<T1, T2, T3, R> {\\n        (): CurriedFunction3<T1, T2, T3, R>;\\n        (t1: T1): CurriedFunction2<T2, T3, R>;\\n        (t1: __, t2: T2): CurriedFunction2<T1, T3, R>;\\n        (t1: T1, t2: T2): CurriedFunction1<T3, R>;\\n        (t1: __, t2: __, t3: T3): CurriedFunction2<T1, T2, R>;\\n        (t1: T1, t2: __, t3: T3): CurriedFunction1<T2, R>;\\n        (t1: __, t2: T2, t3: T3): CurriedFunction1<T1, R>;\\n        (t1: T1, t2: T2, t3: T3): R;\\n    }\\n    interface CurriedFunction4<T1, T2, T3, T4, R> {\\n        (): CurriedFunction4<T1, T2, T3, T4, R>;\\n        (t1: T1): CurriedFunction3<T2, T3, T4, R>;\\n        (t1: __, t2: T2): CurriedFunction3<T1, T3, T4, R>;\\n        (t1: T1, t2: T2): CurriedFunction2<T3, T4, R>;\\n        (t1: __, t2: __, t3: T3): CurriedFunction3<T1, T2, T4, R>;\\n        (t1: __, t2: __, t3: T3): CurriedFunction2<T2, T4, R>;\\n        (t1: __, t2: T2, t3: T3): CurriedFunction2<T1, T4, R>;\\n        (t1: T1, t2: T2, t3: T3): CurriedFunction1<T4, R>;\\n        (t1: __, t2: __, t3: __, t4: T4): CurriedFunction3<T1, T2, T3, R>;\\n        (t1: T1, t2: __, t3: __, t4: T4): CurriedFunction2<T2, T3, R>;\\n        (t1: __, t2: T2, t3: __, t4: T4): CurriedFunction2<T1, T3, R>;\\n        (t1: __, t2: __, t3: T3, t4: T4): CurriedFunction2<T1, T2, R>;\\n        (t1: T1, t2: T2, t3: __, t4: T4): CurriedFunction1<T3, R>;\\n        (t1: T1, t2: __, t3: T3, t4: T4): CurriedFunction1<T2, R>;\\n        (t1: __, t2: T2, t3: T3, t4: T4): CurriedFunction1<T1, R>;\\n        (t1: T1, t2: T2, t3: T3, t4: T4): R;\\n    }\\n    interface CurriedFunction5<T1, T2, T3, T4, T5, R> {\\n        (): CurriedFunction5<T1, T2, T3, T4, T5, R>;\\n        (t1: T1): CurriedFunction4<T2, T3, T4, T5, R>;\\n        (t1: __, t2: T2): CurriedFunction4<T1, T3, T4, T5, R>;\\n        (t1: T1, t2: T2): CurriedFunction3<T3, T4, T5, R>;\\n        (t1: __, t2: __, t3: T3): CurriedFunction4<T1, T2, T4, T5, R>;\\n        (t1: T1, t2: __, t3: T3): CurriedFunction3<T2, T4, T5, R>;\\n        (t1: __, t2: T2, t3: T3): CurriedFunction3<T1, T4, T5, R>;\\n        (t1: T1, t2: T2, t3: T3): CurriedFunction2<T4, T5, R>;\\n        (t1: __, t2: __, t3: __, t4: T4): CurriedFunction4<T1, T2, T3, T5, R>;\\n        (t1: T1, t2: __, t3: __, t4: T4): CurriedFunction3<T2, T3, T5, R>;\\n        (t1: __, t2: T2, t3: __, t4: T4): CurriedFunction3<T1, T3, T5, R>;\\n        (t1: __, t2: __, t3: T3, t4: T4): CurriedFunction3<T1, T2, T5, R>;\\n        (t1: T1, t2: T2, t3: __, t4: T4): CurriedFunction2<T3, T5, R>;\\n        (t1: T1, t2: __, t3: T3, t4: T4): CurriedFunction2<T2, T5, R>;\\n        (t1: __, t2: T2, t3: T3, t4: T4): CurriedFunction2<T1, T5, R>;\\n        (t1: T1, t2: T2, t3: T3, t4: T4): CurriedFunction1<T5, R>;\\n        (t1: __, t2: __, t3: __, t4: __, t5: T5): CurriedFunction4<T1, T2, T3, T4, R>;\\n        (t1: T1, t2: __, t3: __, t4: __, t5: T5): CurriedFunction3<T2, T3, T4, R>;\\n        (t1: __, t2: T2, t3: __, t4: __, t5: T5): CurriedFunction3<T1, T3, T4, R>;\\n        (t1: __, t2: __, t3: T3, t4: __, t5: T5): CurriedFunction3<T1, T2, T4, R>;\\n        (t1: __, t2: __, t3: __, t4: T4, t5: T5): CurriedFunction3<T1, T2, T3, R>;\\n        (t1: T1, t2: T2, t3: __, t4: __, t5: T5): CurriedFunction2<T3, T4, R>;\\n        (t1: T1, t2: __, t3: T3, t4: __, t5: T5): CurriedFunction2<T2, T4, R>;\\n        (t1: T1, t2: __, t3: __, t4: T4, t5: T5): CurriedFunction2<T2, T3, R>;\\n        (t1: __, t2: T2, t3: T3, t4: __, t5: T5): CurriedFunction2<T1, T4, R>;\\n        (t1: __, t2: T2, t3: __, t4: T4, t5: T5): CurriedFunction2<T1, T3, R>;\\n        (t1: __, t2: __, t3: T3, t4: T4, t5: T5): CurriedFunction2<T1, T2, R>;\\n        (t1: T1, t2: T2, t3: T3, t4: __, t5: T5): CurriedFunction1<T4, R>;\\n        (t1: T1, t2: T2, t3: __, t4: T4, t5: T5): CurriedFunction1<T3, R>;\\n        (t1: T1, t2: __, t3: T3, t4: T4, t5: T5): CurriedFunction1<T2, R>;\\n        (t1: __, t2: T2, t3: T3, t4: T4, t5: T5): CurriedFunction1<T1, R>;\\n        (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): R;\\n    }\\n    interface RightCurriedFunction1<T1, R> {\\n        (): RightCurriedFunction1<T1, R>;\\n        (t1: T1): R;\\n    }\\n    interface RightCurriedFunction2<T1, T2, R> {\\n        (): RightCurriedFunction2<T1, T2, R>;\\n        (t2: T2): RightCurriedFunction1<T1, R>;\\n        (t1: T1, t2: __): RightCurriedFunction1<T2, R>;\\n        (t1: T1, t2: T2): R;\\n    }\\n    interface RightCurriedFunction3<T1, T2, T3, R> {\\n        (): RightCurriedFunction3<T1, T2, T3, R>;\\n        (t3: T3): RightCurriedFunction2<T1, T2, R>;\\n        (t2: T2, t3: __): RightCurriedFunction2<T1, T3, R>;\\n        (t2: T2, t3: T3): RightCurriedFunction1<T1, R>;\\n        (t1: T1, t2: __, t3: __): RightCurriedFunction2<T2, T3, R>;\\n        (t1: T1, t2: T2, t3: __): RightCurriedFunction1<T3, R>;\\n        (t1: T1, t2: __, t3: T3): RightCurriedFunction1<T2, R>;\\n        (t1: T1, t2: T2, t3: T3): R;\\n    }\\n    interface RightCurriedFunction4<T1, T2, T3, T4, R> {\\n        (): RightCurriedFunction4<T1, T2, T3, T4, R>;\\n        (t4: T4): RightCurriedFunction3<T1, T2, T3, R>;\\n        (t3: T3, t4: __): RightCurriedFunction3<T1, T2, T4, R>;\\n        (t3: T3, t4: T4): RightCurriedFunction2<T1, T2, R>;\\n        (t2: T2, t3: __, t4: __): RightCurriedFunction3<T1, T3, T4, R>;\\n        (t2: T2, t3: T3, t4: __): RightCurriedFunction2<T1, T4, R>;\\n        (t2: T2, t3: __, t4: T4): RightCurriedFunction2<T1, T3, R>;\\n        (t2: T2, t3: T3, t4: T4): RightCurriedFunction1<T1, R>;\\n        (t1: T1, t2: __, t3: __, t4: __): RightCurriedFunction3<T2, T3, T4, R>;\\n        (t1: T1, t2: T2, t3: __, t4: __): RightCurriedFunction2<T3, T4, R>;\\n        (t1: T1, t2: __, t3: T3, t4: __): RightCurriedFunction2<T2, T4, R>;\\n        (t1: T1, t2: __, t3: __, t4: T4): RightCurriedFunction2<T2, T3, R>;\\n        (t1: T1, t2: T2, t3: T3, t4: __): RightCurriedFunction1<T4, R>;\\n        (t1: T1, t2: T2, t3: __, t4: T4): RightCurriedFunction1<T3, R>;\\n        (t1: T1, t2: __, t3: T3, t4: T4): RightCurriedFunction1<T2, R>;\\n        (t1: T1, t2: T2, t3: T3, t4: T4): R;\\n    }\\n    interface RightCurriedFunction5<T1, T2, T3, T4, T5, R> {\\n        (): RightCurriedFunction5<T1, T2, T3, T4, T5, R>;\\n        (t5: T5): RightCurriedFunction4<T1, T2, T3, T4, R>;\\n        (t4: T4, t5: __): RightCurriedFunction4<T1, T2, T3, T5, R>;\\n        (t4: T4, t5: T5): RightCurriedFunction3<T1, T2, T3, R>;\\n        (t3: T3, t4: __, t5: __): RightCurriedFunction4<T1, T2, T4, T5, R>;\\n        (t3: T3, t4: T4, t5: __): RightCurriedFunction3<T1, T2, T5, R>;\\n        (t3: T3, t4: __, t5: T5): RightCurriedFunction3<T1, T2, T4, R>;\\n        (t3: T3, t4: T4, t5: T5): RightCurriedFunction2<T1, T2, R>;\\n        (t2: T2, t3: __, t4: __, t5: __): RightCurriedFunction4<T1, T3, T4, T5, R>;\\n        (t2: T2, t3: T3, t4: __, t5: __): RightCurriedFunction3<T1, T4, T5, R>;\\n        (t2: T2, t3: __, t4: T4, t5: __): RightCurriedFunction3<T1, T3, T5, R>;\\n        (t2: T2, t3: __, t4: __, t5: T5): RightCurriedFunction3<T1, T3, T4, R>;\\n        (t2: T2, t3: T3, t4: T4, t5: __): RightCurriedFunction2<T1, T5, R>;\\n        (t2: T2, t3: T3, t4: __, t5: T5): RightCurriedFunction2<T1, T4, R>;\\n        (t2: T2, t3: __, t4: T4, t5: T5): RightCurriedFunction2<T1, T3, R>;\\n        (t2: T2, t3: T3, t4: T4, t5: T5): RightCurriedFunction1<T1, R>;\\n        (t1: T1, t2: __, t3: __, t4: __, t5: __): RightCurriedFunction4<T2, T3, T4, T5, R>;\\n        (t1: T1, t2: T2, t3: __, t4: __, t5: __): RightCurriedFunction3<T3, T4, T5, R>;\\n        (t1: T1, t2: __, t3: T3, t4: __, t5: __): RightCurriedFunction3<T2, T4, T5, R>;\\n        (t1: T1, t2: __, t3: __, t4: T4, t5: __): RightCurriedFunction3<T2, T3, T5, R>;\\n        (t1: T1, t2: __, t3: __, t4: __, t5: T5): RightCurriedFunction3<T2, T3, T4, R>;\\n        (t1: T1, t2: T2, t3: T3, t4: __, t5: __): RightCurriedFunction2<T4, T5, R>;\\n        (t1: T1, t2: T2, t3: __, t4: T4, t5: __): RightCurriedFunction2<T3, T5, R>;\\n        (t1: T1, t2: T2, t3: __, t4: __, t5: T5): RightCurriedFunction2<T3, T4, R>;\\n        (t1: T1, t2: __, t3: T3, t4: T4, t5: __): RightCurriedFunction2<T2, T5, R>;\\n        (t1: T1, t2: __, t3: T3, t4: __, t5: T5): RightCurriedFunction2<T2, T4, R>;\\n        (t1: T1, t2: __, t3: __, t4: T4, t5: T5): RightCurriedFunction2<T2, T3, R>;\\n        (t1: T1, t2: T2, t3: T3, t4: T4, t5: __): RightCurriedFunction1<T5, R>;\\n        (t1: T1, t2: T2, t3: T3, t4: __, t5: T5): RightCurriedFunction1<T4, R>;\\n        (t1: T1, t2: T2, t3: __, t4: T4, t5: T5): RightCurriedFunction1<T3, R>;\\n        (t1: T1, t2: __, t3: T3, t4: T4, t5: T5): RightCurriedFunction1<T2, R>;\\n        (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5): R;\\n    }\\n    interface Function<T extends (...args: any) => any> {\\n        /**\\n         * @see _.curry\\n         */\\n        curry(arity?: number):\\n            T extends (arg1: infer T1) => infer R ? Function<CurriedFunction1<T1, R>> :\\n            T extends (arg1: infer T1, arg2: infer T2) => infer R ? Function<CurriedFunction2<T1, T2, R>> :\\n            T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3) => infer R ? Function<CurriedFunction3<T1, T2, T3, R>> :\\n            T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3, arg4: infer T4) => infer R ? Function<CurriedFunction4<T1, T2, T3, T4, R>> :\\n            T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3, arg4: infer T4, arg5: infer T5) => infer R ? Function<CurriedFunction5<T1, T2, T3, T4, T5, R>> :\\n            Function<(...args: any[]) => any>;\\n    }\\n    interface FunctionChain<T extends (...args: any) => any> {\\n        /**\\n         * @see _.curry\\n         */\\n        curry(arity?: number):\\n            T extends (arg1: infer T1) => infer R ? FunctionChain<CurriedFunction1<T1, R>> :\\n            T extends (arg1: infer T1, arg2: infer T2) => infer R ? FunctionChain<CurriedFunction2<T1, T2, R>> :\\n            T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3) => infer R ? FunctionChain<CurriedFunction3<T1, T2, T3, R>> :\\n            T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3, arg4: infer T4) => infer R ? FunctionChain<CurriedFunction4<T1, T2, T3, T4, R>> :\\n            T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3, arg4: infer T4, arg5: infer T5) => infer R ? FunctionChain<CurriedFunction5<T1, T2, T3, T4, T5, R>> :\\n            FunctionChain<(...args: any[]) => any>;\\n    }\\n    interface CurryRight {\\n        <T1, R>(func: (t1: T1) => R, arity?: number): RightCurriedFunction1<T1, R>;\\n        <T1, T2, R>(func: (t1: T1, t2: T2) => R, arity?: number): RightCurriedFunction2<T1, T2, R>;\\n        <T1, T2, T3, R>(func: (t1: T1, t2: T2, t3: T3) => R, arity?: number): RightCurriedFunction3<T1, T2, T3, R>;\\n        <T1, T2, T3, T4, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4) => R, arity?: number): RightCurriedFunction4<T1, T2, T3, T4, R>;\\n        <T1, T2, T3, T4, T5, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => R, arity?: number): RightCurriedFunction5<T1, T2, T3, T4, T5, R>;\\n        (func: (...args: any[]) => any, arity?: number): (...args: any[]) => any;\\n        placeholder: __;\\n    }\\n    interface LoDashStatic {\\n        curryRight: CurryRight;\\n    }\\n    interface Function<T extends (...args: any) => any> {\\n        /**\\n         * @see _.curryRight\\n         */\\n        curryRight(arity?: number):\\n            T extends (arg1: infer T1) => infer R ? Function<RightCurriedFunction1<T1, R>> :\\n            T extends (arg1: infer T1, arg2: infer T2) => infer R ? Function<RightCurriedFunction2<T1, T2, R>> :\\n            T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3) => infer R ? Function<RightCurriedFunction3<T1, T2, T3, R>> :\\n            T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3, arg4: infer T4) => infer R ? Function<RightCurriedFunction4<T1, T2, T3, T4, R>> :\\n            T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3, arg4: infer T4, arg5: infer T5) => infer R ? Function<RightCurriedFunction5<T1, T2, T3, T4, T5, R>> :\\n            Function<(...args: any[]) => any>;\\n    }\\n    interface FunctionChain<T extends (...args: any) => any> {\\n        /**\\n         * @see _.curryRight\\n         */\\n        curryRight(arity?: number):\\n            T extends (arg1: infer T1) => infer R ? FunctionChain<RightCurriedFunction1<T1, R>> :\\n            T extends (arg1: infer T1, arg2: infer T2) => infer R ? FunctionChain<RightCurriedFunction2<T1, T2, R>> :\\n            T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3) => infer R ? FunctionChain<RightCurriedFunction3<T1, T2, T3, R>> :\\n            T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3, arg4: infer T4) => infer R ? FunctionChain<RightCurriedFunction4<T1, T2, T3, T4, R>> :\\n            T extends (arg1: infer T1, arg2: infer T2, arg3: infer T3, arg4: infer T4, arg5: infer T5) => infer R ? FunctionChain<RightCurriedFunction5<T1, T2, T3, T4, T5, R>> :\\n            FunctionChain<(...args: any[]) => any>;\\n    }\\n    interface DebounceSettings {\\n        /**\\n         * @see _.leading\\n         */\\n        leading?: boolean | undefined;\\n        /**\\n         * @see _.maxWait\\n         */\\n        maxWait?: number | undefined;\\n        /**\\n         * @see _.trailing\\n         */\\n        trailing?: boolean | undefined;\\n    }\\n    interface DebouncedFunc<T extends (...args: any[]) => any> {\\n        /**\\n         * Call the original function, but applying the debounce rules.\\n         *\\n         * If the debounced function can be run immediately, this calls it and returns its return\\n         * value.\\n         *\\n         * Otherwise, it returns the return value of the last invocation, or undefined if the debounced\\n         * function was not invoked yet.\\n         */\\n        (...args: Parameters<T>): ReturnType<T> | undefined;\\n\\n        /**\\n         * Throw away any pending invocation of the debounced function.\\n         */\\n        cancel(): void;\\n\\n        /**\\n         * If there is a pending invocation of the debounced function, invoke it immediately and return\\n         * its return value.\\n         *\\n         * Otherwise, return the value from the last invocation, or undefined if the debounced function\\n         * was never invoked.\\n         */\\n        flush(): ReturnType<T> | undefined;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a debounced function that delays invoking func until after wait milliseconds have elapsed since\\n         * the last time the debounced function was invoked. The debounced function comes with a cancel method to\\n         * cancel delayed invocations and a flush method to immediately invoke them. Provide an options object to\\n         * indicate that func should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent\\n         * calls to the debounced function return the result of the last func invocation.\\n         *\\n         * Note: If leading and trailing options are true, func is invoked on the trailing edge of the timeout only\\n         * if the the debounced function is invoked more than once during the wait timeout.\\n         *\\n         * See David Corbacho’s article for details over the differences between _.debounce and _.throttle.\\n         *\\n         * @param func The function to debounce.\\n         * @param wait The number of milliseconds to delay.\\n         * @param options The options object.\\n         * @param options.leading Specify invoking on the leading edge of the timeout.\\n         * @param options.maxWait The maximum time func is allowed to be delayed before it’s invoked.\\n         * @param options.trailing Specify invoking on the trailing edge of the timeout.\\n         * @return Returns the new debounced function.\\n         */\\n        debounce<T extends (...args: any) => any>(func: T, wait?: number, options?: DebounceSettings): DebouncedFunc<T>;\\n    }\\n    interface Function<T extends (...args: any) => any> {\\n        /**\\n         * @see _.debounce\\n         */\\n        debounce(\\n            wait?: number,\\n            options?: DebounceSettings\\n        ): T extends (...args: any[]) => any ? Function<DebouncedFunc<T>> : never;\\n    }\\n    interface FunctionChain<T extends (...args: any) => any> {\\n        /**\\n         * @see _.debounce\\n         */\\n        debounce(\\n            wait?: number,\\n            options?: DebounceSettings\\n        ): T extends (...args: any[]) => any ? FunctionChain<DebouncedFunc<T>> : never;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Defers invoking the func until the current call stack has cleared. Any additional arguments are provided to\\n         * func when it’s invoked.\\n         *\\n         * @param func The function to defer.\\n         * @param args The arguments to invoke the function with.\\n         * @return Returns the timer id.\\n         */\\n        defer(func: (...args: any[]) => any, ...args: any[]): number;\\n    }\\n    interface LoDashImplicitWrapper<TValue> {\\n        /**\\n         * @see _.defer\\n         */\\n        defer(...args: any[]): Primitive<number>;\\n    }\\n    interface LoDashExplicitWrapper<TValue> {\\n        /**\\n         * @see _.defer\\n         */\\n        defer(...args: any[]): PrimitiveChain<number>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Invokes func after wait milliseconds. Any additional arguments are provided to func when it’s invoked.\\n         *\\n         * @param func The function to delay.\\n         * @param wait The number of milliseconds to delay invocation.\\n         * @param args The arguments to invoke the function with.\\n         * @return Returns the timer id.\\n         */\\n        delay(func: (...args: any[]) => any, wait: number, ...args: any[]): number;\\n    }\\n    interface LoDashImplicitWrapper<TValue> {\\n        /**\\n         * @see _.delay\\n         */\\n        delay(wait: number, ...args: any[]): Primitive<number>;\\n    }\\n    interface LoDashExplicitWrapper<TValue> {\\n        /**\\n         * @see _.delay\\n         */\\n        delay(wait: number, ...args: any[]): PrimitiveChain<number>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a function that invokes `func` with arguments reversed.\\n         *\\n         * @category Function\\n         * @param func The function to flip arguments for.\\n         * @returns Returns the new function.\\n         * @example\\n         *\\n         * var flipped = _.flip(function() {\\n         *   return _.toArray(arguments);\\n         * });\\n         *\\n         * flipped('a', 'b', 'c', 'd');\\n         * // => ['d', 'c', 'b', 'a']\\n         */\\n        flip<T extends (...args: any) => any>(func: T): T;\\n    }\\n    interface Function<T extends (...args: any) => any> {\\n        /**\\n         * @see _.flip\\n         */\\n        flip(): this;\\n    }\\n    interface FunctionChain<T extends (...args: any) => any> {\\n        /**\\n         * @see _.flip\\n         */\\n        flip(): this;\\n    }\\n    interface MemoizedFunction {\\n        /**\\n         * @see _.cache\\n         */\\n        cache: MapCache;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a function that memoizes the result of func. If resolver is provided it determines the cache key for\\n         * storing the result based on the arguments provided to the memoized function. By default, the first argument\\n         * provided to the memoized function is coerced to a string and used as the cache key. The func is invoked with\\n         * the this binding of the memoized function.\\n         *\\n         * @param func The function to have its output memoized.\\n         * @param resolver The function to resolve the cache key.\\n         * @return Returns the new memoizing function.\\n         */\\n        memoize: {\\n            <T extends (...args: any) => any>(func: T, resolver?: (...args: Parameters<T>) => any): T & MemoizedFunction;\\n            Cache: MapCacheConstructor;\\n        };\\n    }\\n    interface Function<T extends (...args: any) => any> {\\n        /**\\n         * @see _.memoize\\n         */\\n        memoize(resolver?: (...args: any[]) => any): Function<T & MemoizedFunction>;\\n    }\\n    interface FunctionChain<T extends (...args: any) => any> {\\n        /**\\n         * @see _.memoize\\n         */\\n        memoize(resolver?: (...args: any[]) => any): FunctionChain<T & MemoizedFunction>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a function that negates the result of the predicate func. The func predicate is invoked with\\n         * the this binding and arguments of the created function.\\n         *\\n         * @param predicate The predicate to negate.\\n         * @return Returns the new function.\\n         */\\n        negate<T extends any[]>(predicate: (...args: T) => boolean): (...args: T) => boolean;\\n    }\\n    interface Function<T extends (...args: any) => any> {\\n        /**\\n         * @see _.negate\\n         */\\n        negate(): Function<(...args: Parameters<T>) => boolean>;\\n    }\\n    interface FunctionChain<T extends (...args: any) => any> {\\n        /**\\n         * @see _.negate\\n         */\\n        negate(): FunctionChain<(...args: Parameters<T>) => boolean>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a function that is restricted to invoking func once. Repeat calls to the function return the value\\n         * of the first call. The func is invoked with the this binding and arguments of the created function.\\n         *\\n         * @param func The function to restrict.\\n         * @return Returns the new restricted function.\\n         */\\n        once<T extends (...args: any) => any>(func: T): T;\\n    }\\n    interface Function<T extends (...args: any) => any> {\\n        /**\\n         * @see _.once\\n         */\\n        once(): Function<T>;\\n    }\\n    interface FunctionChain<T extends (...args: any) => any> {\\n        /**\\n         * @see _.once\\n         */\\n        once(): FunctionChain<T>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a function that runs each argument through a corresponding transform function.\\n         *\\n         * @param func The function to wrap.\\n         * @param transforms The functions to transform arguments, specified as individual functions or arrays\\n         * of functions.\\n         * @return Returns the new function.\\n         */\\n        overArgs(func: (...args: any[]) => any, ...transforms: Array<Many<(...args: any[]) => any>>): (...args: any[]) => any;\\n    }\\n    interface Function<T extends (...args: any) => any> {\\n        /**\\n         * @see _.overArgs\\n         */\\n        overArgs(...transforms: Array<Many<(...args: any[]) => any>>): Function<(...args: any[]) => any>;\\n    }\\n    interface FunctionChain<T extends (...args: any) => any> {\\n        /**\\n         * @see _.overArgs\\n         */\\n        overArgs(...transforms: Array<Many<(...args: any[]) => any>>): FunctionChain<(...args: any[]) => any>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n        * Creates a function that, when called, invokes func with any additional partial arguments\\n        * prepended to those provided to the new function. This method is similar to _.bind except\\n        * it does not alter the this binding.\\n        * @param func The function to partially apply arguments to.\\n        * @param args Arguments to be partially applied.\\n        * @return The new partially applied function.\\n         */\\n        partial: Partial;\\n    }\\n    type __ = LoDashStatic;\\n    type Function0<R> = () => R;\\n    type Function1<T1, R> = (t1: T1) => R;\\n    type Function2<T1, T2, R> = (t1: T1, t2: T2) => R;\\n    type Function3<T1, T2, T3, R> = (t1: T1, t2: T2, t3: T3) => R;\\n    type Function4<T1, T2, T3, T4, R> = (t1: T1, t2: T2, t3: T3, t4: T4) => R;\\n    interface Partial {\\n        <T1, T2, R>(func: Function2<T1, T2, R>, plc1: __, arg2: T2): Function1<T1, R>;\\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, plc1: __, arg2: T2): Function2<T1, T3, R>;\\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, plc1: __, plc2: __, arg3: T3): Function2<T1, T2, R>;\\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, plc2: __, arg3: T3): Function1<T2, R>;\\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, plc1: __, arg2: T2, arg3: T3): Function1<T1, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: __, arg2: T2): Function3<T1, T3, T4, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: __, plc2: __, arg3: T3): Function3<T1, T2, T4, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: __, arg3: T3): Function2<T2, T4, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: __, arg2: T2, arg3: T3): Function2<T1, T4, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3): Function1<T4, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: __, plc2: __, plc3: __, arg4: T4): Function3<T1, T2, T3, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: __, plc3: __, arg4: T4): Function2<T2, T3, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: __, arg2: T2, plc3: __, arg4: T4): Function2<T1, T3, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, plc3: __, arg4: T4): Function1<T3, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: __, plc2: __, arg3: T3, arg4: T4): Function2<T1, T2, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: __, arg3: T3, arg4: T4): Function1<T2, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, plc1: __, arg2: T2, arg3: T3, arg4: T4): Function1<T1, R>;\\n        <TS extends any[], R>(func: (...ts: TS) => R): (...ts: TS) => R;\\n        <TS extends any[], T1, R>(func: (t1: T1, ...ts: TS) => R, arg1: T1): (...ts: TS) => R;\\n        <TS extends any[], T1, T2, R>(func: (t1: T1, t2: T2, ...ts: TS) => R, t1: T1, t2: T2): (...ts: TS) => R;\\n        <TS extends any[], T1, T2, T3, R>(func: (t1: T1, t2: T2, t3: T3, ...ts: TS) => R, t1: T1, t2: T2, t3: T3): (...ts: TS) => R;\\n        <TS extends any[], T1, T2, T3, T4, R>(func: (t1: T1, t2: T2, t3: T3, t4: T4, ...ts: TS) => R, t1: T1, t2: T2, t3: T3, t4: T4): (...ts: TS) => R;\\n        placeholder: __;\\n    }\\n    interface Function<T extends (...args: any) => any> {\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T2>(plc1: __, arg2: T2): Function<\\n            T extends Function2<infer T1, T2, infer R> ? Function1<T1, R> :\\n            T extends Function3<infer T1, T2, infer T3, infer R> ? Function2<T1, T3, R> :\\n            T extends Function4<infer T1, T2, infer T3, infer T4, infer R> ? Function3<T1, T3, T4, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T3>(plc1: __, plc2: __, arg3: T3): Function<\\n            T extends Function3<infer T1, infer T2, T3, infer R> ? Function2<T1, T2, R> :\\n            T extends Function4<infer T1, infer T2, T3, infer T4, infer R> ? Function3<T1, T2, T4, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T1, T3>(arg1: T1, plc2: __, arg3: T3): Function<\\n            T extends Function3<T1, infer T2, T3, infer R> ? Function1<T2, R> :\\n            T extends Function4<T1, infer T2, T3, infer T4, infer R> ? Function2<T2, T4, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T2, T3>(plc1: __, arg2: T2, arg3: T3): Function<\\n            T extends Function3<infer T1, T2, T3, infer R> ? Function1<T1, R> :\\n            T extends Function4<infer T1, T2, T3, infer T4, infer R> ? Function2<T1, T4, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T3>(plc1: __, plc2: __, arg3: T3): Function<\\n            T extends Function4<infer T1, infer T2, T3, infer T4, infer R> ? Function3<T1, T2, T4, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T1, T4>(arg1: T1, plc2: __, plc3: __, arg4: T4): Function<\\n            T extends Function4<T1, infer T2, infer T3, T4, infer R> ? Function2<T2, T3, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T2, T4>(plc1: __, arg2: T2, plc3: __, arg4: T4): Function<\\n            T extends Function4<infer T1, T2, infer T3, T4, infer R> ? Function2<T1, T3, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T1, T2, T4>(arg1: T1, arg2: T2, plc3: __, arg4: T4): Function<\\n            T extends Function4<T1, T2, infer T3, T4, infer R> ? Function1<T3, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T3, T4>(plc1: __, plc2: __, arg3: T3, arg4: T4): Function<\\n            T extends Function4<infer T1, infer T2, T3, T4, infer R> ? Function2<T1, T2, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T1, T3, T4>(arg1: T1, plc2: __, arg3: T3, arg4: T4): Function<\\n            T extends Function4<T1, infer T2, T3, T4, infer R> ? Function1<T2, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T2, T3, T4>(plc1: __, arg2: T2, arg3: T3, arg4: T4): Function<\\n            T extends Function4<infer T1, T2, T3, T4, infer R> ? Function1<T1, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T1, T2, T3, T4>(arg1: T1, arg2: T2, arg3: T3, arg4: T4): Function<\\n            T extends (t1: T1, t2: T2, t3: T3, t4: T4, ...ts: infer TS) => infer R ? (...ts: TS) => R :\\n            any\\n            >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T1, T2, T3>(arg1: T1, arg2: T2, arg3: T3): Function<\\n            T extends (t1: T1, t2: T2, t3: T3, ...ts: infer TS) => infer R ? (...ts: TS) => R :\\n            any\\n            >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T1, T2>(arg1: T1, arg2: T2): Function<\\n            T extends (t1: T1, t2: T2, ...ts: infer TS) => infer R ? (...ts: TS) => R :\\n            any\\n            >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T1>(arg1: T1): Function<\\n            T extends (t1: T1, ...ts: infer TS) => infer R ? (...ts: TS) => R :\\n            any\\n            >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial(): Function<T extends (...ts: any[]) => any ? T : any>;\\n    }\\n    interface FunctionChain<T extends (...args: any) => any> {\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T2>(plc1: __, arg2: T2): FunctionChain<\\n            T extends Function2<infer T1, T2, infer R> ? Function1<T1, R> :\\n            T extends Function3<infer T1, T2, infer T3, infer R> ? Function2<T1, T3, R> :\\n            T extends Function4<infer T1, T2, infer T3, infer T4, infer R> ? Function3<T1, T3, T4, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T3>(plc1: __, plc2: __, arg3: T3): FunctionChain<\\n            T extends Function3<infer T1, infer T2, T3, infer R> ? Function2<T1, T2, R> :\\n            T extends Function4<infer T1, infer T2, T3, infer T4, infer R> ? Function3<T1, T2, T4, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T1, T3>(arg1: T1, plc2: __, arg3: T3): FunctionChain<\\n            T extends Function3<T1, infer T2, T3, infer R> ? Function1<T2, R> :\\n            T extends Function4<T1, infer T2, T3, infer T4, infer R> ? Function2<T2, T4, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T2, T3>(plc1: __, arg2: T2, arg3: T3): FunctionChain<\\n            T extends Function3<infer T1, T2, T3, infer R> ? Function1<T1, R> :\\n            T extends Function4<infer T1, T2, T3, infer T4, infer R> ? Function2<T1, T4, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T3>(plc1: __, plc2: __, arg3: T3): FunctionChain<\\n            T extends Function4<infer T1, infer T2, T3, infer T4, infer R> ? Function3<T1, T2, T4, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T1, T4>(arg1: T1, plc2: __, plc3: __, arg4: T4): FunctionChain<\\n            T extends Function4<T1, infer T2, infer T3, T4, infer R> ? Function2<T2, T3, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T2, T4>(plc1: __, arg2: T2, plc3: __, arg4: T4): FunctionChain<\\n            T extends Function4<infer T1, T2, infer T3, T4, infer R> ? Function2<T1, T3, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T1, T2, T4>(arg1: T1, arg2: T2, plc3: __, arg4: T4): FunctionChain<\\n            T extends Function4<T1, T2, infer T3, T4, infer R> ? Function1<T3, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T3, T4>(plc1: __, plc2: __, arg3: T3, arg4: T4): FunctionChain<\\n            T extends Function4<infer T1, infer T2, T3, T4, infer R> ? Function2<T1, T2, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T1, T3, T4>(arg1: T1, plc2: __, arg3: T3, arg4: T4): FunctionChain<\\n            T extends Function4<T1, infer T2, T3, T4, infer R> ? Function1<T2, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T2, T3, T4>(plc1: __, arg2: T2, arg3: T3, arg4: T4): FunctionChain<\\n            T extends Function4<infer T1, T2, T3, T4, infer R> ? Function1<T1, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T1, T2, T3, T4>(arg1: T1, arg2: T2, arg3: T3, arg4: T4): FunctionChain<\\n            T extends (t1: T1, t2: T2, t3: T3, t4: T4, ...ts: infer TS) => infer R ? (...ts: TS) => R :\\n            any\\n            >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T1, T2, T3>(arg1: T1, arg2: T2, arg3: T3): FunctionChain<\\n            T extends (t1: T1, t2: T2, t3: T3, ...ts: infer TS) => infer R ? (...ts: TS) => R :\\n            any\\n            >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T1, T2>(arg1: T1, arg2: T2): FunctionChain<\\n            T extends (t1: T1, t2: T2, ...ts: infer TS) => infer R ? (...ts: TS) => R :\\n            any\\n            >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial<T1>(arg1: T1): FunctionChain<\\n            T extends (t1: T1, ...ts: infer TS) => infer R ? (...ts: TS) => R :\\n            any\\n            >;\\n        /**\\n         * @see _.partial\\n         */\\n        partial(): FunctionChain<T extends (...ts: any[]) => any ? T : any>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n        * This method is like _.partial except that partial arguments are appended to those provided\\n        * to the new function.\\n        * @param func The function to partially apply arguments to.\\n        * @param args Arguments to be partially applied.\\n        * @return The new partially applied function.\\n         */\\n        partialRight: PartialRight;\\n    }\\n    interface PartialRight {\\n        <R>(func: Function0<R>): Function0<R>;\\n        <T1, R>(func: Function1<T1, R>): Function1<T1, R>;\\n        <T1, R>(func: Function1<T1, R>, arg1: T1): Function0<R>;\\n        <T1, T2, R>(func: Function2<T1, T2, R>): Function2<T1, T2, R>;\\n        <T1, T2, R>(func: Function2<T1, T2, R>, arg1: T1, plc2: __): Function1<T2, R>;\\n        <T1, T2, R>(func: Function2<T1, T2, R>, arg2: T2): Function1<T1, R>;\\n        <T1, T2, R>(func: Function2<T1, T2, R>, arg1: T1, arg2: T2): Function0<R>;\\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>): Function3<T1, T2, T3, R>;\\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, plc2: __, plc3: __): Function2<T2, T3, R>;\\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg2: T2, plc3: __): Function2<T1, T3, R>;\\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, arg2: T2, plc3: __): Function1<T3, R>;\\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg3: T3): Function2<T1, T2, R>;\\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, plc2: __, arg3: T3): Function1<T2, R>;\\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg2: T2, arg3: T3): Function1<T1, R>;\\n        <T1, T2, T3, R>(func: Function3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): Function0<R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>): Function4<T1, T2, T3, T4, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: __, plc3: __, plc4: __): Function3<T2, T3, T4, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg2: T2, plc3: __, plc4: __): Function3<T1, T3, T4, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, plc3: __, plc4: __): Function2<T3, T4, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg3: T3, plc4: __): Function3<T1, T2, T4, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: __, arg3: T3, plc4: __): Function2<T2, T4, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg2: T2, arg3: T3, plc4: __): Function2<T1, T4, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, plc4: __): Function1<T4, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg4: T4): Function3<T1, T2, T3, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: __, plc3: __, arg4: T4): Function2<T2, T3, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg2: T2, plc3: __, arg4: T4): Function2<T1, T3, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, plc3: __, arg4: T4): Function1<T3, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg3: T3, arg4: T4): Function2<T1, T2, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, plc2: __, arg3: T3, arg4: T4): Function1<T2, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg2: T2, arg3: T3, arg4: T4): Function1<T1, R>;\\n        <T1, T2, T3, T4, R>(func: Function4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): Function0<R>;\\n        (func: (...args: any[]) => any, ...args: any[]): (...args: any[]) => any;\\n        placeholder: __;\\n    }\\n    interface Function<T extends (...args: any) => any> {\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T1>(arg1: T1, plc2: __): Function<\\n            T extends Function2<T1, infer T2, infer R> ? Function1<T2, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T2>(arg2: T2): Function<\\n            T extends Function2<infer T1, T2, infer R> ? Function1<T1, R> : any\\n            >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T1>(arg1: T1, plc2: __, plc3: __): Function<\\n            T extends Function3<T1, infer T2, infer T3, infer R> ? Function2<T2, T3, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T2>(arg2: T2, plc3: __): Function<\\n            T extends Function3<infer T1, T2, infer T3, infer R> ? Function2<T1, T3, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T1, T2>(arg1: T1, arg2: T2, plc3: __): Function<\\n            T extends Function3<T1, T2, infer T3, infer R> ? Function1<T3, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T3>(arg3: T3): Function<\\n            T extends Function3<infer T1, infer T2, T3, infer R> ? Function2<T1, T2, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T1, T3>(arg1: T1, plc2: __, arg3: T3): Function<\\n            T extends Function3<T1, infer T2, T3, infer R> ? Function1<T2, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T2, T3>(arg2: T2, arg3: T3): Function<\\n            T extends Function3<infer T1, T2, T3, infer R> ? Function1<T1, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T1>(arg1: T1, plc2: __, plc3: __, plc4: __): Function<\\n            T extends Function4<T1, infer T2, infer T3, infer T4, infer R> ? Function3<T2, T3, T4, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T2>(arg2: T2, plc3: __, plc4: __): Function<\\n            T extends Function4<infer T1, T2, infer T3, infer T4, infer R> ? Function3<T1, T3, T4, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T1, T2>(arg1: T1, arg2: T2, plc3: __, plc4: __): Function<\\n            T extends Function4<T1, T2, infer T3, infer T4, infer R> ? Function2<T3, T4, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T3>(arg3: T3, plc4: __): Function<\\n            T extends Function4<infer T1, infer T2, T3, infer T4, infer R> ? Function3<T1, T2, T4, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T1, T3>(arg1: T1, plc2: __, arg3: T3, plc4: __): Function<\\n            T extends Function4<T1, infer T2, infer T3, infer T4, infer R> ? Function2<T2, T4, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T2, T3>(arg2: T2, arg3: T3, plc4: __): Function<\\n            T extends Function4<infer T1, T2, T3, infer T4, infer R> ? Function2<T1, T4, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T1, T2, T3>(arg1: T1, arg2: T2, arg3: T3, plc4: __): Function<\\n            T extends Function4<T1, T2, T3, infer T4, infer R> ? Function1<T4, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T4>(arg4: T4): Function<\\n            T extends Function4<infer T1, infer T2, infer T3, T4, infer R> ? Function3<T1, T2, T3, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T1, T4>(arg1: T1, plc2: __, plc3: __, arg4: T4): Function<\\n            T extends Function4<T1, infer T2, infer T3, T4, infer R> ? Function2<T2, T3, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T2, T4>(arg2: T2, plc3: __, arg4: T4): Function<\\n            T extends Function4<infer T1, T2, infer T3, T4, infer R> ? Function2<T1, T3, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T1, T2, T4>(arg1: T1, arg2: T2, plc3: __, arg4: T4): Function<\\n            T extends Function4<T1, T2, infer T3, T4, infer R> ? Function1<T3, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T3, T4>(arg3: T3, arg4: T4): Function<\\n            T extends Function4<infer T1, infer T2, T3, T4, infer R> ? Function2<T1, T2, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T1, T3, T4>(arg1: T1, plc2: __, arg3: T3, arg4: T4): Function<\\n            T extends Function4<T1, infer T2, T3, T4, infer R> ? Function1<T2, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T2, T3, T4>(arg2: T2, arg3: T3, arg4: T4): Function<\\n            T extends Function4<infer T1, T2, T3, T4, infer R> ? Function1<T1, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<TS extends any[]>(...ts: TS): Function<T extends (...args: TS) => infer R ? () => R : any>;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight(): Function<T extends (...ts: any[]) => any ? T : any>;\\n    }\\n    interface FunctionChain<T extends (...args: any) => any> {\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T1>(arg1: T1, plc2: __): FunctionChain<\\n            T extends Function2<T1, infer T2, infer R> ? Function1<T2, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T2>(arg2: T2): FunctionChain<\\n            T extends Function2<infer T1, T2, infer R> ? Function1<T1, R> : any\\n            >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T1>(arg1: T1, plc2: __, plc3: __): FunctionChain<\\n            T extends Function3<T1, infer T2, infer T3, infer R> ? Function2<T2, T3, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T2>(arg2: T2, plc3: __): FunctionChain<\\n            T extends Function3<infer T1, T2, infer T3, infer R> ? Function2<T1, T3, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T1, T2>(arg1: T1, arg2: T2, plc3: __): FunctionChain<\\n            T extends Function3<T1, T2, infer T3, infer R> ? Function1<T3, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T3>(arg3: T3): FunctionChain<\\n            T extends Function3<infer T1, infer T2, T3, infer R> ? Function2<T1, T2, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T1, T3>(arg1: T1, plc2: __, arg3: T3): FunctionChain<\\n            T extends Function3<T1, infer T2, T3, infer R> ? Function1<T2, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T2, T3>(arg2: T2, arg3: T3): FunctionChain<\\n            T extends Function3<infer T1, T2, T3, infer R> ? Function1<T1, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T1>(arg1: T1, plc2: __, plc3: __, plc4: __): FunctionChain<\\n            T extends Function4<T1, infer T2, infer T3, infer T4, infer R> ? Function3<T2, T3, T4, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T2>(arg2: T2, plc3: __, plc4: __): FunctionChain<\\n            T extends Function4<infer T1, T2, infer T3, infer T4, infer R> ? Function3<T1, T3, T4, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T1, T2>(arg1: T1, arg2: T2, plc3: __, plc4: __): FunctionChain<\\n            T extends Function4<T1, T2, infer T3, infer T4, infer R> ? Function2<T3, T4, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T3>(arg3: T3, plc4: __): FunctionChain<\\n            T extends Function4<infer T1, infer T2, T3, infer T4, infer R> ? Function3<T1, T2, T4, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T1, T3>(arg1: T1, plc2: __, arg3: T3, plc4: __): FunctionChain<\\n            T extends Function4<T1, infer T2, infer T3, infer T4, infer R> ? Function2<T2, T4, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T2, T3>(arg2: T2, arg3: T3, plc4: __): FunctionChain<\\n            T extends Function4<infer T1, T2, T3, infer T4, infer R> ? Function2<T1, T4, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T1, T2, T3>(arg1: T1, arg2: T2, arg3: T3, plc4: __): FunctionChain<\\n            T extends Function4<T1, T2, T3, infer T4, infer R> ? Function1<T4, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T4>(arg4: T4): FunctionChain<\\n            T extends Function4<infer T1, infer T2, infer T3, T4, infer R> ? Function3<T1, T2, T3, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T1, T4>(arg1: T1, plc2: __, plc3: __, arg4: T4): FunctionChain<\\n            T extends Function4<T1, infer T2, infer T3, T4, infer R> ? Function2<T2, T3, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T2, T4>(arg2: T2, plc3: __, arg4: T4): FunctionChain<\\n            T extends Function4<infer T1, T2, infer T3, T4, infer R> ? Function2<T1, T3, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T1, T2, T4>(arg1: T1, arg2: T2, plc3: __, arg4: T4): FunctionChain<\\n            T extends Function4<T1, T2, infer T3, T4, infer R> ? Function1<T3, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T3, T4>(arg3: T3, arg4: T4): FunctionChain<\\n            T extends Function4<infer T1, infer T2, T3, T4, infer R> ? Function2<T1, T2, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T1, T3, T4>(arg1: T1, plc2: __, arg3: T3, arg4: T4): FunctionChain<\\n            T extends Function4<T1, infer T2, T3, T4, infer R> ? Function1<T2, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<T2, T3, T4>(arg2: T2, arg3: T3, arg4: T4): FunctionChain<\\n            T extends Function4<infer T1, T2, T3, T4, infer R> ? Function1<T1, R> :\\n            any\\n        >;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight<TS extends any[]>(...ts: TS): FunctionChain<T extends (...args: TS) => infer R ? () => R : any>;\\n        /**\\n         * @see _.partialRight\\n         */\\n        partialRight(): FunctionChain<T extends (...ts: any[]) => any ? T : any>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a function that invokes func with arguments arranged according to the specified indexes where the\\n         * argument value at the first index is provided as the first argument, the argument value at the second index\\n         * is provided as the second argument, and so on.\\n         * @param func The function to rearrange arguments for.\\n         * @param indexes The arranged argument indexes, specified as individual indexes or arrays of indexes.\\n         * @return Returns the new function.\\n         */\\n        rearg(func: (...args: any[]) => any, ...indexes: Array<Many<number>>): (...args: any[]) => any;\\n    }\\n    interface Function<T extends (...args: any) => any> {\\n        /**\\n         * @see _.rearg\\n         */\\n        rearg(...indexes: Array<Many<number>>): Function<(...args: any[]) => any>;\\n    }\\n    interface FunctionChain<T extends (...args: any) => any> {\\n        /**\\n         * @see _.rearg\\n         */\\n        rearg(...indexes: Array<Many<number>>): FunctionChain<(...args: any[]) => any>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a function that invokes func with the this binding of the created function and arguments from start\\n         * and beyond provided as an array.\\n         *\\n         * Note: This method is based on the rest parameter.\\n         *\\n         * @param func The function to apply a rest parameter to.\\n         * @param start The start position of the rest parameter.\\n         * @return Returns the new function.\\n         */\\n        rest(func: (...args: any[]) => any, start?: number): (...args: any[]) => any;\\n    }\\n    interface Function<T extends (...args: any) => any> {\\n        /**\\n         * @see _.rest\\n         */\\n        rest(start?: number): Function<(...args: any[]) => any>;\\n    }\\n    interface FunctionChain<T extends (...args: any) => any> {\\n        /**\\n         * @see _.rest\\n         */\\n        rest(start?: number): FunctionChain<(...args: any[]) => any>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a function that invokes func with the this binding of the created function and an array of arguments\\n         * much like Function#apply.\\n         *\\n         * Note: This method is based on the spread operator.\\n         *\\n         * @param func The function to spread arguments over.\\n         * @return Returns the new function.\\n         */\\n        spread<TResult>(func: (...args: any[]) => TResult, start?: number): (...args: any[]) => TResult;\\n    }\\n    interface Function<T extends (...args: any) => any> {\\n        /**\\n         * @see _.spread\\n         */\\n        spread(start?: number): Function<(...args: any[]) => ReturnType<T>>;\\n    }\\n    interface FunctionChain<T extends (...args: any) => any> {\\n        /**\\n         * @see _.spread\\n         */\\n        spread(start?: number): FunctionChain<(...args: any[]) => ReturnType<T>>;\\n    }\\n    interface ThrottleSettings {\\n        /**\\n         * @see _.leading\\n         */\\n        leading?: boolean | undefined;\\n        /**\\n         * @see _.trailing\\n         */\\n        trailing?: boolean | undefined;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a throttled function that only invokes func at most once per every wait milliseconds. The throttled\\n         * function comes with a cancel method to cancel delayed invocations and a flush method to immediately invoke\\n         * them. Provide an options object to indicate that func should be invoked on the leading and/or trailing edge\\n         * of the wait timeout. Subsequent calls to the throttled function return the result of the last func call.\\n         *\\n         * Note: If leading and trailing options are true, func is invoked on the trailing edge of the timeout only if\\n         * the the throttled function is invoked more than once during the wait timeout.\\n         *\\n         * @param func The function to throttle.\\n         * @param wait The number of milliseconds to throttle invocations to.\\n         * @param options The options object.\\n         * @param options.leading Specify invoking on the leading edge of the timeout.\\n         * @param options.trailing Specify invoking on the trailing edge of the timeout.\\n         * @return Returns the new throttled function.\\n         */\\n        throttle<T extends (...args: any) => any>(func: T, wait?: number, options?: ThrottleSettings): DebouncedFunc<T>;\\n    }\\n    interface Function<T extends (...args: any) => any> {\\n        /**\\n         * @see _.throttle\\n         */\\n        throttle(\\n            wait?: number,\\n            options?: ThrottleSettings\\n        ): T extends (...args: any[]) => any ? Function<DebouncedFunc<T>> : never;\\n    }\\n    interface FunctionChain<T extends (...args: any) => any> {\\n        /**\\n         * @see _.throttle\\n         */\\n        throttle(\\n            wait?: number,\\n            options?: ThrottleSettings\\n        ): T extends (...args: any[]) => any ? FunctionChain<DebouncedFunc<T>> : never;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a function that accepts up to one argument, ignoring any\\n         * additional arguments.\\n         *\\n         * @category Function\\n         * @param func The function to cap arguments for.\\n         * @returns Returns the new function.\\n         * @example\\n         *\\n         * _.map(['6', '8', '10'], _.unary(parseInt));\\n         * // => [6, 8, 10]\\n         */\\n        unary<T, TResult>(func: (arg1: T, ...args: any[]) => TResult): (arg1: T) => TResult;\\n    }\\n    interface Function<T extends (...args: any) => any> {\\n        /**\\n         * @see _.unary\\n         */\\n        unary(): Function<(arg1: Parameters<T>['0']) => ReturnType<T>>;\\n    }\\n    interface FunctionChain<T extends (...args: any) => any> {\\n        /**\\n         * @see _.unary\\n         */\\n        unary(): FunctionChain<(arg1: Parameters<T>['0']) => ReturnType<T>>;\\n    }\\n    interface LoDashStatic {\\n        /**\\n         * Creates a function that provides value to the wrapper function as its first argument. Any additional\\n         * arguments provided to the function are appended to those provided to the wrapper function. The wrapper is\\n         * invoked with the this binding of the created function.\\n         *\\n         * @param value The value to wrap.\\n         * @param wrapper The wrapper function.\\n         * @return Returns the new function.\\n         */\\n        wrap<T, TArgs, TResult>(value: T, wrapper: (value: T, ...args: TArgs[]) => TResult): (...args: TArgs[]) => TResult;\\n    }\\n    interface LoDashImplicitWrapper<TValue> {\\n        /**\\n         * @see _.wrap\\n         */\\n        wrap<TArgs, TResult>(wrapper: (value: TValue, ...args: TArgs[]) => TResult): Function<(...args: TArgs[]) => TResult>;\\n    }\\n    interface LoDashExplicitWrapper<TValue> {\\n        /**\\n         * @see _.wrap\\n         */\\n        wrap<TArgs, TResult>(wrapper: (value: TValue, ...args: TArgs[]) => TResult): FunctionChain<(...args: TArgs[]) => TResult>;\\n    }\\n}\\n\";"],"names":[],"sourceRoot":""}