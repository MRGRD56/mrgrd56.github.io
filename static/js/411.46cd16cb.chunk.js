"use strict";(self.webpackChunkmrgrd56_github_io=self.webpackChunkmrgrd56_github_io||[]).push([[411],{60411:function(e,n,t){t.r(n),n.default="import _ = require(\"../index\");\ndeclare module \"../index\" {\n    interface LoDashStatic {\n        /**\n         * Assigns own enumerable properties of source objects to the destination\n         * object. Source objects are applied from left to right. Subsequent sources\n         * overwrite property assignments of previous sources.\n         *\n         * **Note:** This method mutates `object` and is loosely based on\n         * [`Object.assign`](https://mdn.io/Object/assign).\n         *\n         * @category Object\n         * @param object The destination object.\n         * @param [sources] The source objects.\n         * @returns Returns `object`.\n         * @example\n         *\n         * function Foo() {\n         *   this.c = 3;\n         * }\n         *\n         * function Bar() {\n         *   this.e = 5;\n         * }\n         *\n         * Foo.prototype.d = 4;\n         * Bar.prototype.f = 6;\n         *\n         * _.assign({ 'a': 1 }, new Foo, new Bar);\n         * // => { 'a': 1, 'c': 3, 'e': 5 }\n         */\n        assign<TObject, TSource>(object: TObject, source: TSource): TObject & TSource;\n        /**\n         * @see _.assign\n         */\n        assign<TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & TSource1 & TSource2;\n        /**\n         * @see _.assign\n         */\n        assign<TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObject & TSource1 & TSource2 & TSource3;\n        /**\n         * @see _.assign\n         */\n        assign<TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): TObject & TSource1 & TSource2 & TSource3 & TSource4;\n        /**\n         * @see _.assign\n         */\n        assign<TObject>(object: TObject): TObject;\n        /**\n         * @see _.assign\n         */\n        assign(object: any, ...otherArgs: any[]): any;\n    }\n    interface Object<T> {\n        /**\n         * @see _.assign\n         */\n        assign<TSource>(source: TSource): Object<T & TSource>;\n        /**\n         * @see _.assign\n         */\n        assign<TSource1, TSource2>(source1: TSource1, source2: TSource2): Object<T & TSource1 & TSource2>;\n        /**\n         * @see _.assign\n         */\n        assign<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): Object<T & TSource1 & TSource2 & TSource3>;\n        /**\n         * @see _.assign\n         */\n        assign<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): Object<T & TSource1 & TSource2 & TSource3 & TSource4>;\n        /**\n         * @see _.assign\n         */\n        assign(): Object<T>;\n        /**\n         * @see _.assign\n         */\n        assign(...otherArgs: any[]): Object<any>;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.assign\n         */\n        assign<TSource>(source: TSource): ObjectChain<T & TSource>;\n        /**\n         * @see _.assign\n         */\n        assign<TSource1, TSource2>(source1: TSource1, source2: TSource2): ObjectChain<T & TSource1 & TSource2>;\n        /**\n         * @see _.assign\n         */\n        assign<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): ObjectChain<T & TSource1 & TSource2 & TSource3>;\n        /**\n         * @see _.assign\n         */\n        assign<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): ObjectChain<T & TSource1 & TSource2 & TSource3 & TSource4>;\n        /**\n         * @see _.assign\n         */\n        assign(): ObjectChain<T>;\n        /**\n         * @see _.assign\n         */\n        assign(...otherArgs: any[]): ObjectChain<any>;\n    }\n    interface LoDashStatic {\n        /**\n         * This method is like `_.assign` except that it iterates over own and\n         * inherited source properties.\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @alias extend\n         * @category Object\n         * @param object The destination object.\n         * @param [sources] The source objects.\n         * @returns Returns `object`.\n         * @example\n         *\n         * function Foo() {\n         *   this.b = 2;\n         * }\n         *\n         * function Bar() {\n         *   this.d = 4;\n         * }\n         *\n         * Foo.prototype.c = 3;\n         * Bar.prototype.e = 5;\n         *\n         * _.assignIn({ 'a': 1 }, new Foo, new Bar);\n         * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5 }\n         */\n        assignIn<TObject, TSource>(object: TObject, source: TSource): TObject & TSource;\n        /**\n         * @see _.assignIn\n         */\n        assignIn<TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & TSource1 & TSource2;\n        /**\n         * @see _.assignIn\n         */\n        assignIn<TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObject & TSource1 & TSource2 & TSource3;\n        /**\n         * @see _.assignIn\n         */\n        assignIn<TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): TObject & TSource1 & TSource2 & TSource3 & TSource4;\n        /**\n         * @see _.assignIn\n         */\n        assignIn<TObject>(object: TObject): TObject;\n        /**\n         * @see _.assignIn\n         */\n        assignIn<TResult>(object: any, ...otherArgs: any[]): TResult;\n    }\n    interface Object<T> {\n        /**\n         * @see _.assignIn\n         */\n        assignIn<TSource>(source: TSource): Object<T & TSource>;\n        /**\n         * @see _.assignIn\n         */\n        assignIn<TSource1, TSource2>(source1: TSource1, source2: TSource2): Object<T & TSource1 & TSource2>;\n        /**\n         * @see _.assignIn\n         */\n        assignIn<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): Object<T & TSource1 & TSource2 & TSource3>;\n        /**\n         * @see _.assignIn\n         */\n        assignIn<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): Object<T & TSource1 & TSource2 & TSource3 & TSource4>;\n        /**\n         * @see _.assignIn\n         */\n        assignIn(): Object<T>;\n        /**\n         * @see _.assignIn\n         */\n        assignIn<TResult>(...otherArgs: any[]): Object<TResult>;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.assignIn\n         */\n        assignIn<TSource>(source: TSource): ObjectChain<T & TSource>;\n        /**\n         * @see _.assignIn\n         */\n        assignIn<TSource1, TSource2>(source1: TSource1, source2: TSource2): ObjectChain<T & TSource1 & TSource2>;\n        /**\n         * @see _.assignIn\n         */\n        assignIn<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): ObjectChain<T & TSource1 & TSource2 & TSource3>;\n        /**\n         * @see _.assignIn\n         */\n        assignIn<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): ObjectChain<T & TSource1 & TSource2 & TSource3 & TSource4>;\n        /**\n         * @see _.assignIn\n         */\n        assignIn(): ObjectChain<T>;\n        /**\n         * @see _.assignIn\n         */\n        assignIn(...otherArgs: any[]): ObjectChain<any>;\n    }\n    type AssignCustomizer = (objectValue: any, sourceValue: any, key?: string, object?: {}, source?: {}) => any;\n    interface LoDashStatic {\n        /**\n         * This method is like `_.assignIn` except that it accepts `customizer` which\n         * is invoked to produce the assigned values. If `customizer` returns `undefined`\n         * assignment is handled by the method instead. The `customizer` is invoked\n         * with five arguments: (objValue, srcValue, key, object, source).\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @alias extendWith\n         * @category Object\n         * @param object The destination object.\n         * @param sources The source objects.\n         * @param [customizer] The function to customize assigned values.\n         * @returns Returns `object`.\n         * @example\n         *\n         * function customizer(objValue, srcValue) {\n         *   return _.isUndefined(objValue) ? srcValue : objValue;\n         * }\n         *\n         * var defaults = _.partialRight(_.assignInWith, customizer);\n         *\n         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n         * // => { 'a': 1, 'b': 2 }\n         */\n        assignInWith<TObject, TSource>(object: TObject, source: TSource, customizer: AssignCustomizer): TObject & TSource;\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith<TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: AssignCustomizer): TObject & TSource1 & TSource2;\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith<TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): TObject & TSource1 & TSource2 & TSource3;\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith<TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: AssignCustomizer): TObject & TSource1 & TSource2 & TSource3 & TSource4;\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith<TObject>(object: TObject): TObject;\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith<TResult>(object: any, ...otherArgs: any[]): TResult;\n    }\n    interface Object<T> {\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith<TSource>(source: TSource, customizer: AssignCustomizer): Object<T & TSource>;\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith<TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: AssignCustomizer): Object<T & TSource1 & TSource2>;\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): Object<T & TSource1 & TSource2 & TSource3>;\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: AssignCustomizer): Object<T & TSource1 & TSource2 & TSource3 & TSource4>;\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith(): Object<T>;\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith<TResult>(...otherArgs: any[]): Object<TResult>;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith<TSource>(source: TSource, customizer: AssignCustomizer): ObjectChain<T & TSource>;\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith<TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: AssignCustomizer): ObjectChain<T & TSource1 & TSource2>;\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): ObjectChain<T & TSource1 & TSource2 & TSource3>;\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: AssignCustomizer): ObjectChain<T & TSource1 & TSource2 & TSource3 & TSource4>;\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith(): ObjectChain<T>;\n        /**\n         * @see _.assignInWith\n         */\n        assignInWith(...otherArgs: any[]): ObjectChain<any>;\n    }\n    interface LoDashStatic {\n        /**\n         * This method is like `_.assign` except that it accepts `customizer` which\n         * is invoked to produce the assigned values. If `customizer` returns `undefined`\n         * assignment is handled by the method instead. The `customizer` is invoked\n         * with five arguments: (objValue, srcValue, key, object, source).\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @category Object\n         * @param object The destination object.\n         * @param sources The source objects.\n         * @param [customizer] The function to customize assigned values.\n         * @returns Returns `object`.\n         * @example\n         *\n         * function customizer(objValue, srcValue) {\n         *   return _.isUndefined(objValue) ? srcValue : objValue;\n         * }\n         *\n         * var defaults = _.partialRight(_.assignWith, customizer);\n         *\n         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n         * // => { 'a': 1, 'b': 2 }\n         */\n        assignWith<TObject, TSource>(object: TObject, source: TSource, customizer: AssignCustomizer): TObject & TSource;\n        /**\n         * @see _.assignWith\n         */\n        assignWith<TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: AssignCustomizer): TObject & TSource1 & TSource2;\n        /**\n         * @see _.assignWith\n         */\n        assignWith<TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): TObject & TSource1 & TSource2 & TSource3;\n        /**\n         * @see _.assignWith\n         */\n        assignWith<TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: AssignCustomizer): TObject & TSource1 & TSource2 & TSource3 & TSource4;\n        /**\n         * @see _.assignWith\n         */\n        assignWith<TObject>(object: TObject): TObject;\n        /**\n         * @see _.assignWith\n         */\n        assignWith<TResult>(object: any, ...otherArgs: any[]): TResult;\n    }\n    interface Object<T> {\n        /**\n         * @see _.assignWith\n         */\n        assignWith<TSource>(source: TSource, customizer: AssignCustomizer): Object<T & TSource>;\n        /**\n         * @see _.assignWith\n         */\n        assignWith<TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: AssignCustomizer): Object<T & TSource1 & TSource2>;\n        /**\n         * @see _.assignWith\n         */\n        assignWith<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): Object<T & TSource1 & TSource2 & TSource3>;\n        /**\n         * @see _.assignWith\n         */\n        assignWith<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: AssignCustomizer): Object<T & TSource1 & TSource2 & TSource3 & TSource4>;\n        /**\n         * @see _.assignWith\n         */\n        assignWith(): Object<T>;\n        /**\n         * @see _.assignWith\n         */\n        assignWith<TResult>(...otherArgs: any[]): Object<TResult>;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.assignWith\n         */\n        assignWith<TSource>(source: TSource, customizer: AssignCustomizer): ObjectChain<T & TSource>;\n        /**\n         * @see _.assignWith\n         */\n        assignWith<TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: AssignCustomizer): ObjectChain<T & TSource1 & TSource2>;\n        /**\n         * @see _.assignWith\n         */\n        assignWith<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): ObjectChain<T & TSource1 & TSource2 & TSource3>;\n        /**\n         * @see _.assignWith\n         */\n        assignWith<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: AssignCustomizer): ObjectChain<T & TSource1 & TSource2 & TSource3 & TSource4>;\n        /**\n         * @see _.assignWith\n         */\n        assignWith(): ObjectChain<T>;\n        /**\n         * @see _.assignWith\n         */\n        assignWith(...otherArgs: any[]): ObjectChain<any>;\n    }\n    interface LoDashStatic {\n        /**\n         * Creates an array of elements corresponding to the given keys, or indexes, of collection. Keys may be\n         * specified as individual arguments or as arrays of keys.\n         *\n         * @param object The object to iterate over.\n         * @param props The property names or indexes of elements to pick, specified individually or in arrays.\n         * @return Returns the new array of picked elements.\n         */\n        at<T>(object:  Dictionary<T> | NumericDictionary<T> | null | undefined, ...props: PropertyPath[]): T[];\n        /**\n         * @see _.at\n         */\n        at<T extends object>(object: T | null | undefined, ...props: Array<Many<keyof T>>): Array<T[keyof T]>;\n    }\n    interface Object<T> {\n        /**\n         * @see _.at\n         */\n        at(...props: Array<Many<keyof T>>): Collection<T[keyof T]>;\n    }\n    interface Collection<T> {\n        /**\n         * @see _.at\n         */\n        at(...props: PropertyPath[]): Collection<T>;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.at\n         */\n        at(...props: Array<Many<keyof T>>): CollectionChain<T[keyof T]>;\n    }\n    interface CollectionChain<T> {\n        /**\n         * @see _.at\n         */\n        at(...props: PropertyPath[]): CollectionChain<T>;\n    }\n    interface LoDashStatic {\n        /**\n         * Creates an object that inherits from the given prototype object. If a properties object is provided its own\n         * enumerable properties are assigned to the created object.\n         *\n         * @param prototype The object to inherit from.\n         * @param properties The properties to assign to the object.\n         * @return Returns the new object.\n         */\n        create<T extends object, U extends object>(prototype: T, properties?: U): T & U;\n    }\n    interface Object<T> {\n        /**\n         * @see _.create\n         */\n        create<U extends object>(properties?: U): Object<T & U>;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.create\n         */\n        create<U extends object>(properties?: U): ObjectChain<T & U>;\n    }\n    interface LoDashStatic {\n        /**\n         * Assigns own enumerable properties of source object(s) to the destination object for all destination\n         * properties that resolve to undefined. Once a property is set, additional values of the same property are\n         * ignored.\n         *\n         * Note: This method mutates object.\n         *\n         * @param object The destination object.\n         * @param sources The source objects.\n         * @return The destination object.\n         */\n        defaults<TObject, TSource>(object: TObject, source: TSource): NonNullable<TSource & TObject>;\n        /**\n         * @see _.defaults\n         */\n        defaults<TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): NonNullable<TSource2 & TSource1 & TObject>;\n        /**\n         * @see _.defaults\n         */\n        defaults<TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): NonNullable<TSource3 & TSource2 & TSource1 & TObject>;\n        /**\n         * @see _.defaults\n         */\n        defaults<TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): NonNullable<TSource4 & TSource3 & TSource2 & TSource1 & TObject>;\n        /**\n         * @see _.defaults\n         */\n        defaults<TObject>(object: TObject): NonNullable<TObject>;\n        /**\n         * @see _.defaults\n         */\n        defaults(object: any, ...sources: any[]): any;\n    }\n    interface Object<T> {\n        /**\n         * @see _.defaults\n         */\n        defaults<TSource>(source: TSource): Object<NonNullable<TSource & T>>;\n        /**\n         * @see _.defaults\n         */\n        defaults<TSource1, TSource2>(source1: TSource1, source2: TSource2): Object<NonNullable<TSource2 & TSource1 & T>>;\n        /**\n         * @see _.defaults\n         */\n        defaults<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): Object<NonNullable<TSource3 & TSource2 & TSource1 & T>>;\n        /**\n         * @see _.defaults\n         */\n        defaults<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): Object<NonNullable<TSource4 & TSource3 & TSource2 & TSource1 & T>>;\n        /**\n         * @see _.defaults\n         */\n        defaults(): Object<NonNullable<T>>;\n        /**\n         * @see _.defaults\n         */\n        defaults(...sources: any[]): Object<any>;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.defaults\n         */\n        defaults<TSource>(source: TSource): ObjectChain<NonNullable<TSource & T>>;\n        /**\n         * @see _.defaults\n         */\n        defaults<TSource1, TSource2>(source1: TSource1, source2: TSource2): ObjectChain<NonNullable<TSource2 & TSource1 & T>>;\n        /**\n         * @see _.defaults\n         */\n        defaults<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): ObjectChain<NonNullable<TSource3 & TSource2 & TSource1 & T>>;\n        /**\n         * @see _.defaults\n         */\n        defaults<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): ObjectChain<NonNullable<TSource4 & TSource3 & TSource2 & TSource1 & T>>;\n        /**\n         * @see _.defaults\n         */\n        defaults(): ObjectChain<NonNullable<T>>;\n        /**\n         * @see _.defaults\n         */\n        defaults(...sources: any[]): ObjectChain<any>;\n    }\n    interface LoDashStatic {\n        /**\n         * This method is like _.defaults except that it recursively assigns default properties.\n         * @param object The destination object.\n         * @param sources The source objects.\n         * @return Returns object.\n         */\n        defaultsDeep(object: any, ...sources: any[]): any;\n    }\n    interface Object<T> {\n        /**\n         * @see _.defaultsDeep\n         */\n        defaultsDeep(...sources: any[]): Object<any>;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.defaultsDeep\n         */\n        defaultsDeep(...sources: any[]): ObjectChain<any>;\n    }\n    interface LoDashStatic {\n        /**\n         * @see _.toPairs\n         */\n        entries<T>(object?: Dictionary<T> | NumericDictionary<T>): Array<[string, T]>;\n        /**\n         * @see _.entries\n         */\n        entries(object?: object): Array<[string, any]>;\n    }\n    interface Object<T> {\n        /**\n         * @see _.entries\n         */\n        entries(): Collection<[string, T[keyof T]]>;\n    }\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.entries\n         */\n        entries(): Collection<[string, any]>;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.entries\n         */\n        entries(): CollectionChain<[string, T[keyof T]]>;\n    }\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.entries\n         */\n        entries(): CollectionChain<[string, any]>;\n    }\n    interface LoDashStatic {\n        /**\n         * @see _.entriesIn\n         */\n        entriesIn<T>(object?: Dictionary<T> | NumericDictionary<T>): Array<[string, T]>;\n        /**\n         * @see _.entriesIn\n         */\n        entriesIn(object?: object): Array<[string, any]>;\n    }\n    interface Object<T> {\n        /**\n         * @see _.entriesIn\n         */\n        entriesIn(): Collection<[string, T[keyof T]]>;\n    }\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.entriesIn\n         */\n        entriesIn(): Collection<[string, any]>;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.entriesIn\n         */\n        entriesIn(): CollectionChain<[string, T[keyof T]]>;\n    }\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.entriesIn\n         */\n        entriesIn(): CollectionChain<[string, any]>;\n    }\n    interface LoDashStatic {\n        /**\n         * @see _.extend\n         */\n        extend<TObject, TSource>(object: TObject, source: TSource): TObject & TSource;\n        /**\n         * @see _.extend\n         */\n        extend<TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & TSource1 & TSource2;\n        /**\n         * @see _.extend\n         */\n        extend<TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObject & TSource1 & TSource2 & TSource3;\n        /**\n         * @see _.extend\n         */\n        extend<TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): TObject & TSource1 & TSource2 & TSource3 & TSource4;\n        /**\n         * @see _.extend\n         */\n        extend<TObject>(object: TObject): TObject;\n        /**\n         * @see _.extend\n         */\n        extend<TResult>(object: any, ...otherArgs: any[]): TResult;\n    }\n    interface Object<T> {\n        /**\n         * @see _.extend\n         */\n        extend<TSource>(source: TSource): Object<T & TSource>;\n        /**\n         * @see _.extend\n         */\n        extend<TSource1, TSource2>(source1: TSource1, source2: TSource2): Object<T & TSource1 & TSource2>;\n        /**\n         * @see _.extend\n         */\n        extend<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): Object<T & TSource1 & TSource2 & TSource3>;\n        /**\n         * @see _.extend\n         */\n        extend<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): Object<T & TSource1 & TSource2 & TSource3 & TSource4>;\n        /**\n         * @see _.extend\n         */\n        extend(): Object<T>;\n        /**\n         * @see _.extend\n         */\n        extend(...otherArgs: any[]): Object<any>;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.extend\n         */\n        extend<TSource>(source: TSource): ObjectChain<T & TSource>;\n        /**\n         * @see _.extend\n         */\n        extend<TSource1, TSource2>(source1: TSource1, source2: TSource2): ObjectChain<T & TSource1 & TSource2>;\n        /**\n         * @see _.extend\n         */\n        extend<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): ObjectChain<T & TSource1 & TSource2 & TSource3>;\n        /**\n         * @see _.extend\n         */\n        extend<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): ObjectChain<T & TSource1 & TSource2 & TSource3 & TSource4>;\n        /**\n         * @see _.extend\n         */\n        extend(): ObjectChain<T>;\n        /**\n         * @see _.extend\n         */\n        extend(...otherArgs: any[]): ObjectChain<any>;\n    }\n    interface LoDashStatic {\n        /**\n         * @see _.extendWith\n         */\n        extendWith<TObject, TSource>(object: TObject, source: TSource, customizer: AssignCustomizer): TObject & TSource;\n        /**\n         * @see _.extendWith\n         */\n        extendWith<TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: AssignCustomizer): TObject & TSource1 & TSource2;\n        /**\n         * @see _.extendWith\n         */\n        extendWith<TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): TObject & TSource1 & TSource2 & TSource3;\n        /**\n         * @see _.extendWith\n         */\n        extendWith<TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: AssignCustomizer): TObject & TSource1 & TSource2 & TSource3 & TSource4;\n        /**\n         * @see _.extendWith\n         */\n        extendWith<TObject>(object: TObject): TObject;\n        /**\n         * @see _.extendWith\n         */\n        extendWith<TResult>(object: any, ...otherArgs: any[]): TResult;\n    }\n    interface Object<T> {\n        /**\n         * @see _.extendWith\n         */\n        extendWith<TSource>(source: TSource, customizer: AssignCustomizer): Object<T & TSource>;\n        /**\n         * @see _.extendWith\n         */\n        extendWith<TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: AssignCustomizer): Object<T & TSource1 & TSource2>;\n        /**\n         * @see _.extendWith\n         */\n        extendWith<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): Object<T & TSource1 & TSource2 & TSource3>;\n        /**\n         * @see _.extendWith\n         */\n        extendWith<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: AssignCustomizer): Object<T & TSource1 & TSource2 & TSource3 & TSource4>;\n        /**\n         * @see _.extendWith\n         */\n        extendWith(): Object<T>;\n        /**\n         * @see _.extendWith\n         */\n        extendWith(...otherArgs: any[]): Object<any>;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.extendWith\n         */\n        extendWith<TSource>(source: TSource, customizer: AssignCustomizer): ObjectChain<T & TSource>;\n        /**\n         * @see _.extendWith\n         */\n        extendWith<TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: AssignCustomizer): ObjectChain<T & TSource1 & TSource2>;\n        /**\n         * @see _.extendWith\n         */\n        extendWith<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: AssignCustomizer): ObjectChain<T & TSource1 & TSource2 & TSource3>;\n        /**\n         * @see _.extendWith\n         */\n        extendWith<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: AssignCustomizer): ObjectChain<T & TSource1 & TSource2 & TSource3 & TSource4>;\n        /**\n         * @see _.extendWith\n         */\n        extendWith(): ObjectChain<T>;\n        /**\n         * @see _.extendWith\n         */\n        extendWith(...otherArgs: any[]): ObjectChain<any>;\n    }\n    interface LoDashStatic {\n        /**\n         * This method is like _.find except that it returns the key of the first element predicate returns truthy for\n         * instead of the element itself.\n         *\n         * @param object The object to search.\n         * @param predicate The function invoked per iteration.\n         * @return Returns the key of the matched element, else undefined.\n         */\n        findKey<T>(object: T | null | undefined, predicate?: ObjectIteratee<T>): string | undefined;\n    }\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.findKey\n         */\n        findKey(predicate?: ObjectIteratee<TValue>): string | undefined;\n    }\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.findKey\n         */\n        findKey(predicate?: ObjectIteratee<TValue>): StringNullableChain;\n    }\n    interface LoDashStatic {\n        /**\n         * This method is like _.findKey except that it iterates over elements of a collection in the opposite order.\n         *\n         * @param object The object to search.\n         * @param predicate The function invoked per iteration.\n         * @return Returns the key of the matched element, else undefined.\n         */\n        findLastKey<T>(object: T | null | undefined, predicate?: ObjectIteratee<T>): string | undefined;\n    }\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.findLastKey\n         */\n        findLastKey(predicate?: ObjectIteratee<TValue>): string | undefined;\n    }\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.findLastKey\n         */\n        findLastKey(predicate?: ObjectIteratee<TValue>): StringNullableChain;\n    }\n    interface LoDashStatic {\n        /**\n         * Iterates over own and inherited enumerable properties of an object invoking iteratee for each property. The\n         * iteratee is invoked with three arguments: (value, key, object). Iteratee functions may\n         * exit iteration early by explicitly returning false.\n         *\n         * @param object The object to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @return Returns object.\n         */\n        forIn<T>(object: T, iteratee?: ObjectIterator<T, any>): T;\n        /**\n         * @see _.forIn\n         */\n        forIn<T>(object: T | null | undefined, iteratee?: ObjectIterator<T, any>): T | null | undefined;\n    }\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.forIn\n         */\n        forIn(iteratee?: ObjectIterator<TValue, any>): this;\n    }\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.forIn\n         */\n        forIn(iteratee?: ObjectIterator<TValue, any>): this;\n    }\n    interface LoDashStatic {\n        /**\n         * This method is like _.forIn except that it iterates over properties of object in the opposite order.\n         *\n         * @param object The object to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @return Returns object.\n         */\n        forInRight<T>(object: T, iteratee?: ObjectIterator<T, any>): T;\n        /**\n         * @see _.forInRight\n         */\n        forInRight<T>(object: T | null | undefined, iteratee?: ObjectIterator<T, any>): T | null | undefined;\n    }\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.forInRight\n         */\n        forInRight(iteratee?: ObjectIterator<TValue, any>): this;\n    }\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.forInRight\n         */\n        forInRight(iteratee?: ObjectIterator<TValue, any>): this;\n    }\n    interface LoDashStatic {\n        /**\n         * Iterates over own enumerable properties of an object invoking iteratee for each property. The iteratee is\n         * invoked with three arguments: (value, key, object). Iteratee functions may exit\n         * iteration early by explicitly returning false.\n         *\n         * @param object The object to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @return Returns object.\n         */\n        forOwn<T>(object: T, iteratee?: ObjectIterator<T, any>): T;\n        /**\n         * @see _.forOwn\n         */\n        forOwn<T>(object: T | null | undefined, iteratee?: ObjectIterator<T, any>): T | null | undefined;\n    }\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.forOwn\n         */\n        forOwn(iteratee?: ObjectIterator<TValue, any>): this;\n    }\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.forOwn\n         */\n        forOwn(iteratee?: ObjectIterator<TValue, any>): this;\n    }\n    interface LoDashStatic {\n        /**\n         * This method is like _.forOwn except that it iterates over properties of object in the opposite order.\n         *\n         * @param object The object to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @return Returns object.\n         */\n        forOwnRight<T>(object: T, iteratee?: ObjectIterator<T, any>): T;\n        /**\n         * @see _.forOwnRight\n         */\n        forOwnRight<T>(object: T | null | undefined, iteratee?: ObjectIterator<T, any>): T | null | undefined;\n    }\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.forOwnRight\n         */\n        forOwnRight(iteratee?: ObjectIterator<TValue, any>): this;\n    }\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.forOwnRight\n         */\n        forOwnRight(iteratee?: ObjectIterator<TValue, any>): this;\n    }\n    interface LoDashStatic {\n        /**\n         * Creates an array of function property names from own enumerable properties\n         * of `object`.\n         *\n         * @category Object\n         * @param object The object to inspect.\n         * @returns Returns the new array of property names.\n         * @example\n         *\n         * function Foo() {\n         *   this.a = _.constant('a');\n         *   this.b = _.constant('b');\n         * }\n         *\n         * Foo.prototype.c = _.constant('c');\n         *\n         * _.functions(new Foo);\n         * // => ['a', 'b']\n         */\n        functions(object: any): string[];\n    }\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.functions\n         */\n        functions(): Collection<string>;\n    }\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.functions\n         */\n        functions(): CollectionChain<string>;\n    }\n    interface LoDashStatic {\n        /**\n         * Creates an array of function property names from own and inherited\n         * enumerable properties of `object`.\n         *\n         * @category Object\n         * @param object The object to inspect.\n         * @returns Returns the new array of property names.\n         * @example\n         *\n         * function Foo() {\n         *   this.a = _.constant('a');\n         *   this.b = _.constant('b');\n         * }\n         *\n         * Foo.prototype.c = _.constant('c');\n         *\n         * _.functionsIn(new Foo);\n         * // => ['a', 'b', 'c']\n         */\n        functionsIn<T extends {}>(object: any): string[];\n    }\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.functionsIn\n         */\n        functionsIn(): Collection<string>;\n    }\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.functionsIn\n         */\n        functionsIn(): CollectionChain<string>;\n    }\n    interface LoDashStatic {\n        /**\n         * Gets the property value at path of object. If the resolved value is undefined the defaultValue is used\n         * in its place.\n         *\n         * @param object The object to query.\n         * @param path The path of the property to get.\n         * @param defaultValue The value returned if the resolved value is undefined.\n         * @return Returns the resolved value.\n         */\n        get<TObject extends object, TKey extends keyof TObject>(object: TObject, path: TKey | [TKey]): TObject[TKey];\n        /**\n         * @see _.get\n         */\n        get<TObject extends object, TKey extends keyof TObject>(object: TObject | null | undefined, path: TKey | [TKey]): TObject[TKey] | undefined;\n        /**\n         * @see _.get\n         */\n        get<TObject extends object, TKey extends keyof TObject, TDefault>(object: TObject | null | undefined, path: TKey | [TKey], defaultValue: TDefault): Exclude<TObject[TKey], undefined> | TDefault;\n        /**\n         * @see _.get\n         */\n        get<TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(object: TObject, path: [TKey1, TKey2]): TObject[TKey1][TKey2];\n        /**\n         * @see _.get\n         */\n        get<TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1]>(object: TObject | null | undefined, path: [TKey1, TKey2]): TObject[TKey1][TKey2] | undefined;\n        /**\n         * @see _.get\n         */\n        get<TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TDefault>(object: TObject | null | undefined, path: [TKey1, TKey2], defaultValue: TDefault): Exclude<TObject[TKey1][TKey2], undefined> | TDefault;\n        /**\n         * @see _.get\n         */\n        get<TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(object: TObject, path: [TKey1, TKey2, TKey3]): TObject[TKey1][TKey2][TKey3];\n        /**\n         * @see _.get\n         */\n        get<TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2]>(object: TObject | null | undefined, path: [TKey1, TKey2, TKey3]): TObject[TKey1][TKey2][TKey3] | undefined;\n        /**\n         * @see _.get\n         */\n        get<TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TDefault>(object: TObject | null | undefined, path: [TKey1, TKey2, TKey3], defaultValue: TDefault): Exclude<TObject[TKey1][TKey2][TKey3], undefined> | TDefault;\n        /**\n         * @see _.get\n         */\n        get<TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(object: TObject, path: [TKey1, TKey2, TKey3, TKey4]): TObject[TKey1][TKey2][TKey3][TKey4];\n        /**\n         * @see _.get\n         */\n        get<TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3]>(object: TObject | null | undefined, path: [TKey1, TKey2, TKey3, TKey4]): TObject[TKey1][TKey2][TKey3][TKey4] | undefined;\n        /**\n         * @see _.get\n         */\n        get<TObject extends object, TKey1 extends keyof TObject, TKey2 extends keyof TObject[TKey1], TKey3 extends keyof TObject[TKey1][TKey2], TKey4 extends keyof TObject[TKey1][TKey2][TKey3], TDefault>(object: TObject | null | undefined, path: [TKey1, TKey2, TKey3, TKey4], defaultValue: TDefault): Exclude<TObject[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault;\n        /**\n         * @see _.get\n         */\n        get<T>(object: NumericDictionary<T>, path: number): T;\n        /**\n         * @see _.get\n         */\n        get<T>(object: NumericDictionary<T> | null | undefined, path: number): T | undefined;\n        /**\n         * @see _.get\n         */\n        get<T, TDefault>(object: NumericDictionary<T> | null | undefined, path: number, defaultValue: TDefault): T | TDefault;\n        /**\n         * @see _.get\n         */\n        get<TDefault>(object: null | undefined, path: PropertyPath, defaultValue: TDefault): TDefault;\n        /**\n         * @see _.get\n         */\n        get(object: null | undefined, path: PropertyPath): undefined;\n        /**\n         * @see _.get\n         */\n        get(object: any, path: PropertyPath, defaultValue?: any): any;\n    }\n    interface String {\n        /**\n         * @see _.get\n         */\n        get(path: number | number[]): string;\n        /**\n         * @see _.get\n         */\n        get(path: number | number[], defaultValue: string): string;\n    }\n    interface Object<T> {\n        /**\n         * @see _.get\n         */\n        get<TKey extends keyof T>(path: TKey | [TKey]): T[TKey];\n        /**\n         * @see _.get\n         */\n        get<TKey extends keyof T, TDefault>(path: TKey | [TKey], defaultValue: TDefault): Exclude<T[TKey], undefined> | TDefault;\n        /**\n         * @see _.get\n         */\n        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1]>(path: [TKey1, TKey2]): T[TKey1][TKey2];\n        /**\n         * @see _.get\n         */\n        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TDefault>(path: [TKey1, TKey2], defaultValue: TDefault): Exclude<T[TKey1][TKey2], undefined> | TDefault;\n        /**\n         * @see _.get\n         */\n        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TKey3 extends keyof T[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3]): T[TKey1][TKey2][TKey3];\n        /**\n         * @see _.get\n         */\n        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TKey3 extends keyof T[TKey1][TKey2], TDefault>(path: [TKey1, TKey2, TKey3], defaultValue: TDefault): Exclude<T[TKey1][TKey2][TKey3], undefined> | TDefault;\n        /**\n         * @see _.get\n         */\n        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TKey3 extends keyof T[TKey1][TKey2], TKey4 extends keyof T[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4]): T[TKey1][TKey2][TKey3][TKey4];\n        /**\n         * @see _.get\n         */\n        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TKey3 extends keyof T[TKey1][TKey2], TKey4 extends keyof T[TKey1][TKey2][TKey3], TDefault>(path: [TKey1, TKey2, TKey3, TKey4], defaultValue: TDefault): Exclude<T[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault;\n        /**\n         * @see _.get\n         */\n        get(path: PropertyPath, defaultValue?: any): any;\n    }\n    interface Collection<T> {\n        /**\n         * @see _.get\n         */\n        get(path: number): T;\n        /**\n         * @see _.get\n         */\n        get<TDefault>(path: number, defaultValue: TDefault): T | TDefault;\n    }\n    interface StringChain {\n        /**\n         * @see _.get\n         */\n        get(path: number | number[]): StringChain;\n        /**\n         * @see _.get\n         */\n        get(path: number | number[], defaultValue: string): StringChain;\n    }\n    interface StringNullableChain {\n        /**\n         * @see _.get\n         */\n        get(path: number | number[]): StringNullableChain;\n        /**\n         * @see _.get\n         */\n        get(path: number | number[], defaultValue: string): StringChain;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.get\n         */\n        get<TKey extends keyof T>(path: TKey | [TKey]): ExpChain<T[TKey]>;\n        /**\n         * @see _.get\n         */\n        get<TKey extends keyof T>(path: TKey | [TKey], defaultValue: never[]): T[TKey] extends any[] ? ExpChain<Exclude<T[TKey], undefined>> : ExpChain<Exclude<T[TKey], undefined> | never[]>;\n        /**\n         * @see _.get\n         */\n        get<TKey extends keyof T, TDefault>(path: TKey | [TKey], defaultValue: TDefault): ExpChain<Exclude<T[TKey], undefined> | TDefault>;\n        /**\n         * @see _.get\n         */\n        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1]>(path: [TKey1, TKey2]): ExpChain<T[TKey1][TKey2]>;\n        /**\n         * @see _.get\n         */\n        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1]>(path: [TKey1, TKey2], defaultValue: never[]): T[TKey1][TKey2] extends any[] ? ExpChain<Exclude<T[TKey1][TKey2], undefined>> : ExpChain<Exclude<T[TKey1][TKey2], undefined> | never[]>;\n        /**\n         * @see _.get\n         */\n        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TDefault>(path: [TKey1, TKey2], defaultValue: TDefault): ExpChain<Exclude<T[TKey1][TKey2], undefined> | TDefault>;\n        /**\n         * @see _.get\n         */\n        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TKey3 extends keyof T[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3]): ExpChain<T[TKey1][TKey2][TKey3]>;\n        /**\n         * @see _.get\n         */\n        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TKey3 extends keyof T[TKey1][TKey2]>(path: [TKey1, TKey2, TKey3], defaultValue: never[]): T[TKey1][TKey2][TKey3] extends any[] ? ExpChain<Exclude<T[TKey1][TKey2][TKey3], undefined>> : ExpChain<Exclude<T[TKey1][TKey2][TKey3], undefined> | never[]>;\n        /**\n         * @see _.get\n         */\n        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TKey3 extends keyof T[TKey1][TKey2], TDefault>(path: [TKey1, TKey2, TKey3], defaultValue: TDefault): ExpChain<Exclude<T[TKey1][TKey2][TKey3], undefined> | TDefault>;\n        /**\n         * @see _.get\n         */\n        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TKey3 extends keyof T[TKey1][TKey2], TKey4 extends keyof T[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4]): ExpChain<T[TKey1][TKey2][TKey3][TKey4]>;\n        /**\n         * @see _.get\n         */\n        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TKey3 extends keyof T[TKey1][TKey2], TKey4 extends keyof T[TKey1][TKey2][TKey3]>(path: [TKey1, TKey2, TKey3, TKey4], defaultValue: never[]): T[TKey1][TKey2][TKey3][TKey4] extends any[] ? ExpChain<Exclude<T[TKey1][TKey2][TKey3][TKey4], undefined>> : ExpChain<Exclude<T[TKey1][TKey2][TKey3][TKey4], undefined> | never[]>;\n        /**\n         * @see _.get\n         */\n        get<TKey1 extends keyof T, TKey2 extends keyof T[TKey1], TKey3 extends keyof T[TKey1][TKey2], TKey4 extends keyof T[TKey1][TKey2][TKey3], TDefault>(path: [TKey1, TKey2, TKey3, TKey4], defaultValue: TDefault): ExpChain<Exclude<T[TKey1][TKey2][TKey3][TKey4], undefined> | TDefault>;\n        /**\n         * @see _.get\n         */\n        get(path: PropertyPath, defaultValue?: any): LoDashExplicitWrapper<any>;\n    }\n    interface CollectionChain<T> {\n        /**\n         * @see _.get\n         */\n        get(path: number): ExpChain<T>;\n        /**\n         * @see _.get\n         */\n        get<TDefault>(path: number, defaultValue: TDefault): ExpChain<T | TDefault>;\n    }\n    interface LoDashStatic {\n        /**\n         * Checks if `path` is a direct property of `object`.\n         *\n         * @category Object\n         * @param object The object to query.\n         * @param path The path to check.\n         * @returns Returns `true` if `path` exists, else `false`.\n         * @example\n         *\n         * var object = { 'a': { 'b': { 'c': 3 } } };\n         * var other = _.create({ 'a': _.create({ 'b': _.create({ 'c': 3 }) }) });\n         *\n         * _.has(object, 'a');\n         * // => true\n         *\n         * _.has(object, 'a.b.c');\n         * // => true\n         *\n         * _.has(object, ['a', 'b', 'c']);\n         * // => true\n         *\n         * _.has(other, 'a');\n         * // => false\n         */\n        has<T>(object: T, path: PropertyPath): boolean;\n    }\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.has\n         */\n        has(path: PropertyPath): boolean;\n    }\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.has\n         */\n        has(path: PropertyPath): PrimitiveChain<boolean>;\n    }\n    interface LoDashStatic {\n        /**\n         * Checks if `path` is a direct or inherited property of `object`.\n         *\n         * @category Object\n         * @param object The object to query.\n         * @param path The path to check.\n         * @returns Returns `true` if `path` exists, else `false`.\n         * @example\n         *\n         * var object = _.create({ 'a': _.create({ 'b': _.create({ 'c': 3 }) }) });\n         *\n         * _.hasIn(object, 'a');\n         * // => true\n         *\n         * _.hasIn(object, 'a.b.c');\n         * // => true\n         *\n         * _.hasIn(object, ['a', 'b', 'c']);\n         * // => true\n         *\n         * _.hasIn(object, 'b');\n         * // => false\n         */\n        hasIn<T>(object: T, path: PropertyPath): boolean;\n    }\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.hasIn\n         */\n        hasIn(path: PropertyPath): boolean;\n    }\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.hasIn\n         */\n        hasIn(path: PropertyPath): PrimitiveChain<boolean>;\n    }\n    interface LoDashStatic {\n        /**\n         * Creates an object composed of the inverted keys and values of object. If object contains duplicate values,\n         * subsequent values overwrite property assignments of previous values unless multiValue is true.\n         *\n         * @param object The object to invert.\n         * @param multiValue Allow multiple values per key.\n         * @return Returns the new inverted object.\n         */\n        invert(object: object): Dictionary<string>;\n    }\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.invert\n         */\n        invert(): Object<Dictionary<string>>;\n    }\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.invert\n         */\n        invert(): ObjectChain<Dictionary<string>>;\n    }\n    interface LoDashStatic {\n        /**\n         * This method is like _.invert except that the inverted object is generated from the results of running each\n         * element of object through iteratee. The corresponding inverted value of each inverted key is an array of\n         * keys responsible for generating the inverted value. The iteratee is invoked with one argument: (value).\n         *\n         * @param object The object to invert.\n         * @param interatee The iteratee invoked per element.\n         * @return Returns the new inverted object.\n         */\n        invertBy<T>(object:  Dictionary<T> | NumericDictionary<T> | null | undefined, interatee?: ValueIteratee<T>): Dictionary<string[]>;\n        /**\n         * @see _.invertBy\n         */\n        invertBy<T extends object>(object: T | null | undefined, interatee?: ValueIteratee<T[keyof T]>): Dictionary<string[]>;\n    }\n    interface String {\n        /**\n         * @see _.invertBy\n         */\n        invertBy(iteratee?: ValueIteratee<string>): Object<Dictionary<string[]>>;\n    }\n    interface Collection<T> {\n        /**\n         * @see _.invertBy\n         */\n        invertBy(iteratee?: ValueIteratee<T>): Object<Dictionary<string[]>>;\n    }\n    interface Object<T> {\n        /**\n         * @see _.invertBy\n         */\n        invertBy(iteratee?: ValueIteratee<T[keyof T]>): Object<Dictionary<string[]>>;\n    }\n    interface StringChain {\n        /**\n         * @see _.invertBy\n         */\n        invertBy(iteratee?: ValueIteratee<string>): ObjectChain<Dictionary<string[]>>;\n    }\n    interface StringNullableChain {\n        /**\n         * @see _.invertBy\n         */\n        invertBy(iteratee?: ValueIteratee<string>): ObjectChain<Dictionary<string[]>>;\n    }\n    interface CollectionChain<T> {\n        /**\n         * @see _.invertBy\n         */\n        invertBy(iteratee?: ValueIteratee<T>): ObjectChain<Dictionary<string[]>>;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.invertBy\n         */\n        invertBy(iteratee?: ValueIteratee<T[keyof T]>): ObjectChain<Dictionary<string[]>>;\n    }\n    interface LoDashStatic {\n        /**\n        * Invokes the method at path of object.\n        * @param object The object to query.\n        * @param path The path of the method to invoke.\n        * @param args The arguments to invoke the method with.\n         */\n        invoke(object: any, path: PropertyPath, ...args: any[]): any;\n    }\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.invoke\n         */\n        invoke(path: PropertyPath, ...args: any[]): any;\n    }\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.invoke\n         */\n        invoke(path: PropertyPath, ...args: any[]): LoDashExplicitWrapper<any>;\n    }\n    interface LoDashStatic {\n        /**\n         * Creates an array of the own enumerable property names of object.\n         *\n         * Note: Non-object values are coerced to objects. See the ES spec for more details.\n         *\n         * @param object The object to query.\n         * @return Returns the array of property names.\n         */\n        keys(object?: any): string[];\n    }\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.keys\n         */\n        keys(): Collection<string>;\n    }\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.keys\n         */\n        keys(): CollectionChain<string>;\n    }\n    interface LoDashStatic {\n        /**\n         * Creates an array of the own and inherited enumerable property names of object.\n         *\n         * Note: Non-object values are coerced to objects.\n         *\n         * @param object The object to query.\n         * @return An array of property names.\n         */\n        keysIn(object?: any): string[];\n    }\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.keysIn\n         */\n        keysIn(): Collection<string>;\n    }\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.keysIn\n         */\n        keysIn(): CollectionChain<string>;\n    }\n    interface LoDashStatic {\n        /**\n         * The opposite of _.mapValues; this method creates an object with the same values as object and keys generated\n         * by running each own enumerable property of object through iteratee.\n         *\n         * @param object The object to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @return Returns the new mapped object.\n         */\n        mapKeys<T>(object: List<T> | null | undefined, iteratee?: ListIteratee<T>): Dictionary<T>;\n        /**\n         * @see _.mapKeys\n         */\n        mapKeys<T extends object>(object: T | null | undefined, iteratee?: ObjectIteratee<T>): Dictionary<T[keyof T]>;\n    }\n    interface Collection<T> {\n        /**\n         * @see _.mapKeys\n         */\n        mapKeys(iteratee?: ListIteratee<T>): Object<Dictionary<T>>;\n    }\n    interface Object<T> {\n        /**\n         * @see _.mapKeys\n         */\n        mapKeys(iteratee?: ObjectIteratee<T>): Object<Dictionary<T[keyof T]>>;\n    }\n    interface CollectionChain<T> {\n        /**\n         * @see _.mapKeys\n         */\n        mapKeys(iteratee?: ListIteratee<T>): ObjectChain<Dictionary<T>>;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.mapKeys\n         */\n        mapKeys(iteratee?: ObjectIteratee<T>): ObjectChain<Dictionary<T[keyof T]>>;\n    }\n    interface LoDashStatic {\n        /**\n        * Creates an object with the same keys as object and values generated by running each own\n        * enumerable property of object through iteratee. The iteratee function is\n        * invoked with three arguments: (value, key, object).\n        *\n        * @param object The object to iterate over.\n        * @param iteratee  The function invoked per iteration.\n        * @return Returns the new mapped object.\n         */\n        mapValues<TResult>(obj: string | null | undefined, callback: StringIterator<TResult>): NumericDictionary<TResult>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object, TResult>(obj: T | null | undefined, callback: ObjectIterator<T, TResult>): { [P in keyof T]: TResult };\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T>(obj: Dictionary<T> | NumericDictionary<T> | null | undefined, iteratee: object): Dictionary<boolean>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object>(obj: T | null | undefined, iteratee: object): { [P in keyof T]: boolean };\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T, TKey extends keyof T>(obj: Dictionary<T> | NumericDictionary<T> | null | undefined, iteratee: TKey): Dictionary<T[TKey]>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T>(obj: Dictionary<T> | NumericDictionary<T> | null | undefined, iteratee: string): Dictionary<any>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object>(obj: T | null | undefined, iteratee: string): { [P in keyof T]: any };\n        /**\n         * @see _.mapValues\n         */\n        mapValues(obj: string | null | undefined): NumericDictionary<string>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T>(obj: Dictionary<T> | NumericDictionary<T> | null | undefined): Dictionary<T>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object>(obj: T): T;\n        /**\n         * @see _.mapValues\n         */\n        mapValues<T extends object>(obj: T | null | undefined): PartialObject<T>;\n    }\n    interface String {\n        /**\n         * @see _.mapValues\n         */\n        mapValues<TResult>(callback: StringIterator<TResult>): Object<NumericDictionary<TResult>>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues(): Object<NumericDictionary<string>>;\n    }\n    interface Collection<T> {\n        /**\n         * @see _.mapValues\n         */\n        mapValues<TResult>(callback: DictionaryIterator<T, TResult>): Object<Dictionary<TResult>>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues<TKey extends keyof T>(iteratee: TKey): Object<Dictionary<T[TKey]>>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues(iteratee: object): Object<Dictionary<boolean>>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues(iteratee: string): Object<Dictionary<any>>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues(): Object<Dictionary<T>>;\n    }\n    interface Object<T> {\n        /**\n         * @see _.mapValues\n         */\n        mapValues<TResult>(callback: ObjectIterator<T, TResult>): Object<{ [P in keyof T]: TResult }>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues<TResult>(callback: DictionaryIterator<T[keyof T], TResult>): Object<Dictionary<TResult>>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues(iteratee: object): Object<{ [P in keyof T]: boolean }>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues<TKey extends keyof T[keyof T]>(iteratee: TKey): Object<Dictionary<T[keyof T][TKey]>>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues(iteratee: string): Object<{ [P in keyof T]: any }>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues(): Object<T>;\n    }\n    interface StringChain {\n        /**\n         * @see _.mapValues\n         */\n        mapValues<TResult>(callback: StringIterator<TResult>): ObjectChain<NumericDictionary<TResult>>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues(): ObjectChain<NumericDictionary<string>>;\n    }\n    interface StringNullableChain {\n        /**\n         * @see _.mapValues\n         */\n        mapValues<TResult>(callback: StringIterator<TResult>): ObjectChain<NumericDictionary<TResult>>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues(): ObjectChain<NumericDictionary<string>>;\n    }\n    interface CollectionChain<T> {\n        /**\n         * @see _.mapValues\n         */\n        mapValues<TResult>(callback: DictionaryIterator<T, TResult>): ObjectChain<Dictionary<TResult>>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues<TKey extends keyof T>(iteratee: TKey): ObjectChain<Dictionary<T[TKey]>>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues(iteratee: object): ObjectChain<Dictionary<boolean>>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues(iteratee: string): ObjectChain<Dictionary<any>>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues(): ObjectChain<Dictionary<T>>;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.mapValues\n         */\n        mapValues<TResult>(callback: ObjectIterator<T, TResult>): ObjectChain<{ [P in keyof T]: TResult }>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues<TResult>(callback: DictionaryIterator<T[keyof T], TResult>): ObjectChain<Dictionary<TResult>>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues(iteratee: object): ObjectChain<{ [P in keyof T]: boolean }>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues<TKey extends keyof T[keyof T]>(iteratee: TKey): ObjectChain<Dictionary<T[keyof T][TKey]>>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues(iteratee: string): ObjectChain<{ [P in keyof T]: any }>;\n        /**\n         * @see _.mapValues\n         */\n        mapValues(): ObjectChain<T>;\n    }\n    interface LoDashStatic {\n        /**\n         * Recursively merges own and inherited enumerable properties of source\n         * objects into the destination object, skipping source properties that resolve\n         * to `undefined`. Array and plain object properties are merged recursively.\n         * Other objects and value types are overridden by assignment. Source objects\n         * are applied from left to right. Subsequent sources overwrite property\n         * assignments of previous sources.\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @category Object\n         * @param object The destination object.\n         * @param [sources] The source objects.\n         * @returns Returns `object`.\n         * @example\n         *\n         * var users = {\n         *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]\n         * };\n         *\n         * var ages = {\n         *   'data': [{ 'age': 36 }, { 'age': 40 }]\n         * };\n         *\n         * _.merge(users, ages);\n         * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }\n         */\n        merge<TObject, TSource>(object: TObject, source: TSource): TObject & TSource;\n        /**\n         * @see _.merge\n         */\n        merge<TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2): TObject & TSource1 & TSource2;\n        /**\n         * @see _.merge\n         */\n        merge<TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3): TObject & TSource1 & TSource2 & TSource3;\n        /**\n         * @see _.merge\n         */\n        merge<TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): TObject & TSource1 & TSource2 & TSource3 & TSource4;\n        /**\n         * @see _.merge\n         */\n        merge(object: any, ...otherArgs: any[]): any;\n    }\n    interface Object<T> {\n        /**\n         * @see _.merge\n         */\n        merge<TSource>(source: TSource): Object<T & TSource>;\n        /**\n         * @see _.merge\n         */\n        merge<TSource1, TSource2>(source1: TSource1, source2: TSource2): Object<T & TSource1 & TSource2>;\n        /**\n         * @see _.merge\n         */\n        merge<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): Object<T & TSource1 & TSource2 & TSource3>;\n        /**\n         * @see _.merge\n         */\n        merge<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): Object<T & TSource1 & TSource2 & TSource3 & TSource4>;\n        /**\n         * @see _.merge\n         */\n        merge(...otherArgs: any[]): Object<any>;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.merge\n         */\n        merge<TSource>(source: TSource): ObjectChain<T & TSource>;\n        /**\n         * @see _.merge\n         */\n        merge<TSource1, TSource2>(source1: TSource1, source2: TSource2): ObjectChain<T & TSource1 & TSource2>;\n        /**\n         * @see _.merge\n         */\n        merge<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3): ObjectChain<T & TSource1 & TSource2 & TSource3>;\n        /**\n         * @see _.merge\n         */\n        merge<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4): ObjectChain<T & TSource1 & TSource2 & TSource3 & TSource4>;\n        /**\n         * @see _.merge\n         */\n        merge(...otherArgs: any[]): ObjectChain<any>;\n    }\n    type MergeWithCustomizer = { bivariantHack(value: any, srcValue: any, key: string, object: any, source: any): any; }[\"bivariantHack\"];\n    // TODO: Probably should just put all these methods on Object and forget about it.\n    // oh, except for Collection<any> I GUESS\n    interface LoDashStatic {\n        /**\n         * This method is like `_.merge` except that it accepts `customizer` which\n         * is invoked to produce the merged values of the destination and source\n         * properties. If `customizer` returns `undefined` merging is handled by the\n         * method instead. The `customizer` is invoked with seven arguments:\n         * (objValue, srcValue, key, object, source, stack).\n         *\n         * @category Object\n         * @param object The destination object.\n         * @param sources The source objects.\n         * @param customizer The function to customize assigned values.\n         * @returns Returns `object`.\n         * @example\n         *\n         * function customizer(objValue, srcValue) {\n         *   if (_.isArray(objValue)) {\n         *     return objValue.concat(srcValue);\n         *   }\n         * }\n         *\n         * var object = {\n         *   'fruits': ['apple'],\n         *   'vegetables': ['beet']\n         * };\n         *\n         * var other = {\n         *   'fruits': ['banana'],\n         *   'vegetables': ['carrot']\n         * };\n         *\n         * _.mergeWith(object, other, customizer);\n         * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }\n         */\n        mergeWith<TObject, TSource>(object: TObject, source: TSource, customizer: MergeWithCustomizer): TObject & TSource;\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith<TObject, TSource1, TSource2>(object: TObject, source1: TSource1, source2: TSource2, customizer: MergeWithCustomizer): TObject & TSource1 & TSource2;\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith<TObject, TSource1, TSource2, TSource3>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, customizer: MergeWithCustomizer): TObject & TSource1 & TSource2 & TSource3;\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith<TObject, TSource1, TSource2, TSource3, TSource4>(object: TObject, source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: MergeWithCustomizer): TObject & TSource1 & TSource2 & TSource3 & TSource4;\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith(object: any, ...otherArgs: any[]): any;\n    }\n    interface Object<T> {\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith<TSource>(source: TSource, customizer: MergeWithCustomizer): Object<T & TSource>;\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith<TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: MergeWithCustomizer): Object<T & TSource1 & TSource2>;\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: MergeWithCustomizer): Object<T & TSource1 & TSource2 & TSource3>;\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: MergeWithCustomizer): Object<T & TSource1 & TSource2 & TSource3 & TSource4>;\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith(...otherArgs: any[]): Object<any>;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith<TSource>(source: TSource, customizer: MergeWithCustomizer): ObjectChain<T & TSource>;\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith<TSource1, TSource2>(source1: TSource1, source2: TSource2, customizer: MergeWithCustomizer): ObjectChain<T & TSource1 & TSource2>;\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith<TSource1, TSource2, TSource3>(source1: TSource1, source2: TSource2, source3: TSource3, customizer: MergeWithCustomizer): ObjectChain<T & TSource1 & TSource2 & TSource3>;\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith<TSource1, TSource2, TSource3, TSource4>(source1: TSource1, source2: TSource2, source3: TSource3, source4: TSource4, customizer: MergeWithCustomizer): ObjectChain<T & TSource1 & TSource2 & TSource3 & TSource4>;\n        /**\n         * @see _.mergeWith\n         */\n        mergeWith(...otherArgs: any[]): ObjectChain<any>;\n    }\n    interface LoDashStatic {\n        /**\n         * The opposite of `_.pick`; this method creates an object composed of the\n         * own and inherited enumerable properties of `object` that are not omitted.\n         *\n         * @category Object\n         * @param object The source object.\n         * @param [paths] The property names to omit, specified\n         *  individually or in arrays..\n         * @returns Returns the new object.\n         * @example\n         *\n         * var object = { 'a': 1, 'b': '2', 'c': 3 };\n         *\n         * _.omit(object, ['a', 'c']);\n         * // => { 'b': '2' }\n         */\n        omit<T extends object, K extends PropertyName[]>(\n            object: T | null | undefined,\n            ...paths: K\n        ): Pick<T, Exclude<keyof T, K[number]>>;\n        /**\n         * @see _.omit\n         */\n        omit<T extends object, K extends keyof T>(object: T | null | undefined, ...paths: Array<Many<K>>): Omit<T, K>;\n        /**\n         * @see _.omit\n         */\n        omit<T extends object>(object: T | null | undefined, ...paths: Array<Many<PropertyName>>): PartialObject<T>;\n    }\n    interface Collection<T> {\n        /**\n         * @see _.omit\n         */\n        omit(...paths: Array<Many<PropertyName>>): Collection<T>;\n    }\n    interface Object<T> {\n        /**\n         * @see _.omit\n         */\n        omit<K extends keyof T>(...paths: Array<Many<K>>): Object<Omit<T, K>>;\n        /**\n         * @see _.omit\n         */\n        omit(...paths: Array<Many<PropertyName | IterateeShorthand<T>>>): Object<PartialObject<T>>;\n    }\n    interface CollectionChain<T> {\n        /**\n         * @see _.omit\n         */\n        omit(...paths: Array<Many<PropertyName>>): CollectionChain<T>;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.omit\n         */\n        omit<K extends keyof T>(...paths: Array<Many<K>>): ObjectChain<Omit<T, K>>;\n        /**\n         * @see _.omit\n         */\n        omit(...paths: Array<Many<PropertyName>>): ObjectChain<PartialObject<T>>;\n    }\n    interface LoDashStatic {\n        /**\n         * The opposite of `_.pickBy`; this method creates an object composed of the\n         * own and inherited enumerable properties of `object` that `predicate`\n         * doesn't return truthy for.\n         *\n         * @category Object\n         * @param object The source object.\n         * @param [predicate=_.identity] The function invoked per property.\n         * @returns Returns the new object.\n         * @example\n         *\n         * var object = { 'a': 1, 'b': '2', 'c': 3 };\n         *\n         * _.omitBy(object, _.isNumber);\n         * // => { 'b': '2' }\n         */\n        omitBy<T>(object: Dictionary<T> | null | undefined, predicate?: ValueKeyIteratee<T>): Dictionary<T>;\n        /**\n         * @see _.omitBy\n         */\n        omitBy<T>(object: NumericDictionary<T> | null | undefined, predicate?: ValueKeyIteratee<T>): NumericDictionary<T>;\n        /**\n         * @see _.omitBy\n         */\n        omitBy<T extends object>(object: T | null | undefined, predicate: ValueKeyIteratee<T[keyof T]>): PartialObject<T>;\n    }\n    interface Collection<T> {\n        /**\n         * @see _.omitBy\n         */\n        omitBy(predicate?: ValueKeyIteratee<T>): Object<Dictionary<T>>;\n    }\n    interface Object<T> {\n        /**\n         * @see _.omitBy\n         */\n        omitBy(predicate: ValueKeyIteratee<T[keyof T]>): Object<PartialObject<T>>;\n    }\n    interface CollectionChain<T> {\n        /**\n         * @see _.omitBy\n         */\n        omitBy(predicate?: ValueKeyIteratee<T>): ObjectChain<Dictionary<T>>;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.omitBy\n         */\n        omitBy(predicate: ValueKeyIteratee<T[keyof T]>): ObjectChain<PartialObject<T>>;\n    }\n    interface LoDashStatic {\n        /**\n         * Creates an object composed of the picked `object` properties.\n         *\n         * @category Object\n         * @param object The source object.\n         * @param [props] The property names to pick, specified\n         *  individually or in arrays.\n         * @returns Returns the new object.\n         * @example\n         *\n         * var object = { 'a': 1, 'b': '2', 'c': 3 };\n         *\n         * _.pick(object, ['a', 'c']);\n         * // => { 'a': 1, 'c': 3 }\n         */\n        pick<T extends object, U extends keyof T>(object: T, ...props: Array<Many<U>>): Pick<T, U>;\n        /**\n         * @see _.pick\n         */\n        pick<T>(object: T | null | undefined, ...props: PropertyPath[]): PartialObject<T>;\n    }\n    interface Object<T> {\n        /**\n         * @see _.pick\n         */\n        pick<U extends keyof T>(...props: Array<Many<U>>): Object<Pick<T, U>>;\n        /**\n         * @see _.pick\n         */\n        pick(...props: PropertyPath[]): Object<PartialObject<T>>;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.pick\n         */\n        pick<U extends keyof T>(...props: Array<Many<U>>): ObjectChain<Pick<T, U>>;\n        /**\n         * @see _.pick\n         */\n        pick(...props: PropertyPath[]): ObjectChain<PartialObject<T>>;\n    }\n    interface LoDashStatic {\n        /**\n         * Creates an object composed of the `object` properties `predicate` returns\n         * truthy for. The predicate is invoked with two arguments: (value, key).\n         *\n         * @category Object\n         * @param object The source object.\n         * @param [predicate=_.identity] The function invoked per property.\n         * @returns Returns the new object.\n         * @example\n         *\n         * var object = { 'a': 1, 'b': '2', 'c': 3 };\n         *\n         * _.pickBy(object, _.isNumber);\n         * // => { 'a': 1, 'c': 3 }\n         */\n        pickBy<T, S extends T>(object: Dictionary<T> | null | undefined, predicate: ValueKeyIterateeTypeGuard<T, S>): Dictionary<S>;\n        /**\n         * @see _.pickBy\n         */\n        pickBy<T, S extends T>(object: NumericDictionary<T> | null | undefined, predicate: ValueKeyIterateeTypeGuard<T, S>): NumericDictionary<S>;\n        /**\n         * @see _.pickBy\n         */\n        pickBy<T>(object: Dictionary<T> | null | undefined, predicate?: ValueKeyIteratee<T>): Dictionary<T>;\n        /**\n         * @see _.pickBy\n         */\n        pickBy<T>(object: NumericDictionary<T> | null | undefined, predicate?: ValueKeyIteratee<T>): NumericDictionary<T>;\n        /**\n         * @see _.pickBy\n         */\n        pickBy<T extends object>(object: T | null | undefined, predicate?: ValueKeyIteratee<T[keyof T]>): PartialObject<T>;\n    }\n    interface Collection<T> {\n        /**\n         * @see _.pickBy\n         */\n        pickBy<S extends T>(predicate: ValueKeyIterateeTypeGuard<T, S>): Object<Dictionary<S>>;\n        /**\n         * @see _.pickBy\n         */\n        pickBy(predicate?: ValueKeyIteratee<T>): Object<Dictionary<T>>;\n    }\n    interface Object<T> {\n        /**\n         * @see _.pickBy\n         */\n        pickBy<S extends T[keyof T]>(predicate: ValueKeyIterateeTypeGuard<T[keyof T], S>): Object<NumericDictionary<unknown> extends T ? NumericDictionary<S> : Dictionary<S>>;\n        /**\n         * @see _.pickBy\n         */\n        pickBy(predicate?: ValueKeyIteratee<T[keyof T]>): Object<T extends Dictionary<unknown> ? Dictionary<T[keyof T]> : T extends NumericDictionary<unknown> ? NumericDictionary<T[keyof T]> : PartialObject<T>>;\n    }\n    interface CollectionChain<T> {\n        /**\n         * @see _.pickBy\n         */\n        pickBy<S extends T>(predicate: ValueKeyIterateeTypeGuard<T, S>): ObjectChain<Dictionary<S>>;\n        /**\n         * @see _.pickBy\n         */\n        pickBy(predicate?: ValueKeyIteratee<T>): ObjectChain<Dictionary<T>>;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.pickBy\n         */\n        pickBy<S extends T[keyof T]>(predicate: ValueKeyIterateeTypeGuard<T[keyof T], S>): ObjectChain<NumericDictionary<unknown> extends T ? NumericDictionary<S> : Dictionary<S>>;\n        /**\n         * @see _.pickBy\n         */\n        pickBy(predicate?: ValueKeyIteratee<T[keyof T]>): ObjectChain<T extends Dictionary<unknown> ? Dictionary<T[keyof T]> : T extends NumericDictionary<unknown> ? NumericDictionary<T[keyof T]> : PartialObject<T>>;\n    }\n    interface LoDashStatic {\n        /**\n         * This method is like _.get except that if the resolved value is a function it\u2019s invoked with the this binding\n         * of its parent object and its result is returned.\n         *\n         * @param object The object to query.\n         * @param path The path of the property to resolve.\n         * @param defaultValue The value returned if the resolved value is undefined.\n         * @return Returns the resolved value.\n         */\n        result<TResult>(object: any, path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)): TResult;\n    }\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.result\n         */\n        result<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)): TResult;\n    }\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.result\n         */\n        result<TResult>(path: PropertyPath, defaultValue?: TResult | ((...args: any[]) => TResult)): ExpChain<TResult>;\n    }\n    interface LoDashStatic {\n        /**\n         * Sets the value at path of object. If a portion of path doesn\u2019t exist it\u2019s created. Arrays are created for\n         * missing index properties while objects are created for all other missing properties. Use _.setWith to\n         * customize path creation.\n         *\n         * @param object The object to modify.\n         * @param path The path of the property to set.\n         * @param value The value to set.\n         * @return Returns object.\n         */\n        set<T extends object>(object: T, path: PropertyPath, value: any): T;\n        /**\n         * @see _.set\n         */\n        set<TResult>(object: object, path: PropertyPath, value: any): TResult;\n    }\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.set\n         */\n        set(path: PropertyPath, value: any): this;\n        /**\n         * @see _.set\n         */\n        set<TResult>(path: PropertyPath, value: any): ImpChain<TResult>;\n    }\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.set\n         */\n        set(path: PropertyPath, value: any): this;\n        /**\n         * @see _.set\n         */\n        set<TResult>(path: PropertyPath, value: any): ExpChain<TResult>;\n    }\n    type SetWithCustomizer<T> = (nsValue: any, key: string, nsObject: T) => any;\n    interface LoDashStatic {\n        /**\n         * This method is like _.set except that it accepts customizer which is invoked to produce the objects of\n         * path. If customizer returns undefined path creation is handled by the method instead. The customizer is\n         * invoked with three arguments: (nsValue, key, nsObject).\n         *\n         * @param object The object to modify.\n         * @param path The path of the property to set.\n         * @param value The value to set.\n         * @param customizer The function to customize assigned values.\n         * @return Returns object.\n         */\n        setWith<T extends object>(object: T, path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): T;\n        /**\n         * @see _.setWith\n         */\n        setWith<T extends object, TResult>(object: T, path: PropertyPath, value: any, customizer?: SetWithCustomizer<T>): TResult;\n    }\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.setWith\n         */\n        setWith(path: PropertyPath, value: any, customizer?: SetWithCustomizer<TValue>): this;\n        /**\n         * @see _.setWith\n         */\n        setWith<TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<TValue>): ImpChain<TResult>;\n    }\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.setWith\n         */\n        setWith(path: PropertyPath, value: any, customizer?: SetWithCustomizer<TValue>): this;\n        /**\n         * @see _.setWith\n         */\n        setWith<TResult>(path: PropertyPath, value: any, customizer?: SetWithCustomizer<TValue>): ExpChain<TResult>;\n    }\n    interface LoDashStatic {\n        /**\n         * Creates an array of own enumerable key-value pairs for object.\n         *\n         * @param object The object to query.\n         * @return Returns the new array of key-value pairs.\n         */\n        toPairs<T>(object?: Dictionary<T> | NumericDictionary<T>): Array<[string, T]>;\n        /**\n         * @see _.toPairs\n         */\n        toPairs(object?: object): Array<[string, any]>;\n    }\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toPairs\n         */\n        toPairs(): Collection<[string, TValue extends Dictionary<infer U> ? U : TValue extends NumericDictionary<infer V> ? V : any]>;\n    }\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toPairs\n         */\n        toPairs(): CollectionChain<[string, TValue extends Dictionary<infer U> ? U : TValue extends NumericDictionary<infer V> ? V : any]>;\n    }\n    interface LoDashStatic {\n        /**\n         * Creates an array of own and inherited enumerable key-value pairs for object.\n         *\n         * @param object The object to query.\n         * @return Returns the new array of key-value pairs.\n         */\n        toPairsIn<T>(object?: Dictionary<T> | NumericDictionary<T>): Array<[string, T]>;\n        /**\n         * @see _.toPairsIn\n         */\n        toPairsIn(object?: object): Array<[string, any]>;\n    }\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.toPairsIn\n         */\n        toPairsIn(): Collection<[string, TValue extends Dictionary<infer U> ? U : TValue extends NumericDictionary<infer V> ? V : any]>;\n    }\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.toPairsIn\n         */\n        toPairsIn(): CollectionChain<[string, TValue extends Dictionary<infer U> ? U : TValue extends NumericDictionary<infer V> ? V : any]>;\n    }\n    interface LoDashStatic {\n        /**\n         * An alternative to _.reduce; this method transforms object to a new accumulator object which is the result of\n         * running each of its own enumerable properties through iteratee, with each invocation potentially mutating\n         * the accumulator object. The iteratee is invoked with four arguments: (accumulator,\n         * value, key, object). Iteratee functions may exit iteration early by explicitly returning false.\n         *\n         * @param object The object to iterate over.\n         * @param iteratee The function invoked per iteration.\n         * @param accumulator The custom accumulator value.\n         * @return Returns the accumulated value.\n         */\n        transform<T, TResult>(object: ReadonlyArray<T>, iteratee: MemoVoidArrayIterator<T, TResult>, accumulator?: TResult): TResult;\n        /**\n         * @see _.transform\n         */\n        transform<T, TResult>(object: Dictionary<T>, iteratee: MemoVoidDictionaryIterator<T, string, TResult>, accumulator?: TResult): TResult;\n        /**\n         * @see _.transform\n         */\n        transform<T extends object, TResult>(object: T, iteratee: MemoVoidDictionaryIterator<T[keyof T], keyof T, TResult>, accumulator?: TResult): TResult;\n        /**\n         * @see _.transform\n         */\n        transform(object: any[]): any[];\n        /**\n         * @see _.transform\n         */\n        transform(object: object): Dictionary<any>;\n    }\n    interface Collection<T> {\n        /**\n         * @see _.transform\n         */\n        transform<TResult>(iteratee: MemoVoidArrayIterator<T, TResult>, accumulator?: TResult): ImpChain<TResult>;\n        /**\n         * @see _.transform\n         */\n        transform(): Collection<any>;\n    }\n    interface Object<T> {\n        /**\n         * @see _.transform\n         */\n        transform<TResult>(iteratee: MemoVoidDictionaryIterator<T[keyof T], string, TResult>, accumulator?: TResult): ImpChain<TResult>;\n        /**\n         * @see _.transform\n         */\n        transform<TResult>(iteratee: MemoVoidDictionaryIterator<T[keyof T], keyof T, TResult>, accumulator?: TResult): ImpChain<TResult>;\n        /**\n         * @see _.transform\n         */\n        transform(): ImpChain<T extends Dictionary<unknown> ? Dictionary<any> : T>;\n    }\n    interface CollectionChain<T> {\n        /**\n         * @see _.transform\n         */\n        transform<TResult>(iteratee: MemoVoidArrayIterator<T, TResult>, accumulator?: TResult): ExpChain<TResult>;\n        /**\n         * @see _.transform\n         */\n        transform(): CollectionChain<any>;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.transform\n         */\n        transform<TResult>(iteratee: MemoVoidDictionaryIterator<T[keyof T], string, TResult>, accumulator?: TResult): ExpChain<TResult>;\n        /**\n         * @see _.transform\n         */\n        transform<TResult>(iteratee: MemoVoidDictionaryIterator<T[keyof T], keyof T, TResult>, accumulator?: TResult): ExpChain<TResult>;\n        /**\n         * @see _.transform\n         */\n        transform(): ExpChain<T extends Dictionary<unknown> ? Dictionary<any> : T>;\n    }\n    interface LoDashStatic {\n        /**\n         * Removes the property at path of object.\n         *\n         * Note: This method mutates object.\n         *\n         * @param object The object to modify.\n         * @param path The path of the property to unset.\n         * @return Returns true if the property is deleted, else false.\n         */\n        unset(object: any, path: PropertyPath): boolean;\n    }\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.unset\n         */\n        unset(path: PropertyPath): Primitive<boolean>;\n    }\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.unset\n         */\n        unset(path: PropertyPath): PrimitiveChain<boolean>;\n    }\n    interface LoDashStatic {\n        /**\n         * This method is like _.set except that accepts updater to produce the value to set. Use _.updateWith to\n         * customize path creation. The updater is invoked with one argument: (value).\n         *\n         * @param object The object to modify.\n         * @param path The path of the property to set.\n         * @param updater The function to produce the updated value.\n         * @return Returns object.\n         */\n        update(object: object, path: PropertyPath, updater: (value: any) => any): any;\n    }\n    interface LoDashImplicitWrapper<TValue> {\n        /**\n         * @see _.update\n         */\n        update(path: PropertyPath, updater: (value: any) => any): Object<any>;\n    }\n    interface LoDashExplicitWrapper<TValue> {\n        /**\n         * @see _.update\n         */\n        update(path: PropertyPath, updater: (value: any) => any): ObjectChain<any>;\n    }\n    interface LoDashStatic {\n        /**\n         * This method is like `_.update` except that it accepts `customizer` which is\n         * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n         * path creation is handled by the method instead. The `customizer` is invoked\n         * with three arguments: (nsValue, key, nsObject).\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @since 4.6.0\n         * @category Object\n         * @param object The object to modify.\n         * @param path The path of the property to set.\n         * @param updater The function to produce the updated value.\n         * @param [customizer] The function to customize assigned values.\n         * @returns Returns `object`.\n         * @example\n         *\n         * var object = {};\n         *\n         * _.updateWith(object, '[0][1]', _.constant('a'), Object);\n         * // => { '0': { '1': 'a' } }\n         */\n        updateWith<T extends object>(object: T, path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<T>): T;\n        /**\n         * @see _.updateWith\n         */\n        updateWith<T extends object, TResult>(object: T, path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<T>): TResult;\n    }\n    interface Object<T> {\n        /**\n         * @see _.updateWith\n         */\n        updateWith(path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<T>): this;\n        /**\n         * @see _.updateWith\n         */\n        updateWith<TResult>(path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<T>): Object<TResult>;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.updateWith\n         */\n        updateWith(path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<T>): this;\n        /**\n         * @see _.updateWith\n         */\n        updateWith<TResult>(path: PropertyPath, updater: (oldValue: any) => any, customizer?: SetWithCustomizer<T>): ObjectChain<TResult>;\n    }\n    interface LoDashStatic {\n        /**\n         * Creates an array of the own enumerable property values of object.\n         *\n         * @param object The object to query.\n         * @return Returns an array of property values.\n         */\n        values<T>(object: Dictionary<T> | NumericDictionary<T> | List<T> | null | undefined): T[];\n        /**\n         * @see _.values\n         */\n        values<T extends object>(object: T | null | undefined): Array<T[keyof T]>;\n        /**\n         * @see _.values\n         */\n        values(object: any): any[];\n    }\n    interface String {\n        /**\n         * @see _.values\n         */\n        values(): Collection<string>;\n    }\n    interface Object<T> {\n        /**\n         * @see _.values\n         */\n        values(): Collection<T[keyof T]>;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.values\n         */\n        values(): CollectionChain<T[keyof T]>;\n    }\n    interface StringChain {\n        /**\n         * @see _.values\n         */\n        values(): CollectionChain<string>;\n    }\n    interface StringNullableChain {\n        /**\n         * @see _.values\n         */\n        values(): CollectionChain<string>;\n    }\n    interface LoDashStatic {\n        /**\n         * Creates an array of the own and inherited enumerable property values of object.\n         *\n         * @param object The object to query.\n         * @return Returns the array of property values.\n         */\n        valuesIn<T>(object: Dictionary<T> | NumericDictionary<T> | List<T> | null | undefined): T[];\n        /**\n         * @see _.valuesIn\n         */\n        valuesIn<T extends object>(object: T | null | undefined): Array<T[keyof T]>;\n    }\n    interface String {\n        /**\n         * @see _.valuesIn\n         */\n        valuesIn(): Collection<string>;\n    }\n    interface Object<T> {\n        /**\n         * @see _.valuesIn\n         */\n        valuesIn(): Collection<T[keyof T]>;\n    }\n    interface StringChain {\n        /**\n         * @see _.valuesIn\n         */\n        valuesIn(): CollectionChain<string>;\n    }\n    interface StringNullableChain {\n        /**\n         * @see _.valuesIn\n         */\n        valuesIn(): CollectionChain<string>;\n    }\n    interface ObjectChain<T> {\n        /**\n         * @see _.valuesIn\n         */\n        valuesIn(): CollectionChain<T[keyof T]>;\n    }\n}\n"}}]);
//# sourceMappingURL=411.46cd16cb.chunk.js.map