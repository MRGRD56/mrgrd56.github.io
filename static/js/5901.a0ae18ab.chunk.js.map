{"version":3,"file":"static/js/5901.a0ae18ab.chunk.js","mappings":";iIAEIA,EAAyBC,EAAQ,OAKrCC,EAAQ,OAAU,EAElB,IAAIC,EAAiBH,EAAuBC,EAAQ,QAEhDG,EAAcH,EAAQ,OAEtBI,GAAW,EAAIF,EAAeG,UAAuB,EAAIF,EAAYG,KAAK,OAAQ,CACpFC,EAAG,4ZACD,OAEJN,EAAQ,EAAUG,4BCfdL,EAAyBC,EAAQ,OAKrCC,EAAQ,OAAU,EAElB,IAAIC,EAAiBH,EAAuBC,EAAQ,QAEhDG,EAAcH,EAAQ,OAEtBI,GAAW,EAAIF,EAAeG,UAAuB,EAAIF,EAAYG,KAAK,OAAQ,CACpFC,EAAG,uLACD,QAEJN,EAAQ,EAAUG,6BCfdL,EAAyBC,EAAQ,OAKrCC,EAAQ,OAAU,EAElB,IAAIC,EAAiBH,EAAuBC,EAAQ,QAEhDG,EAAcH,EAAQ,OAEtBI,GAAW,EAAIF,EAAeG,UAAuB,EAAIF,EAAYG,KAAK,OAAQ,CACpFC,EAAG,kOACD,cAEJN,EAAQ,EAAUG,mDCflB,KAAeI,EAAAA,EAAAA,IAA4BC,EAAAA,EAAAA,KAAK,OAAQ,CACtDF,EAAG,+FACD,yDCFJ,KAAeC,EAAAA,EAAAA,IAA4BC,EAAAA,EAAAA,KAAK,OAAQ,CACtDF,EAAG,4EACD,kECFJ,KAAeC,EAAAA,EAAAA,IAA4BC,EAAAA,EAAAA,KAAK,OAAQ,CACtDF,EAAG,gEACD,6MCWJ,SAASG,EAAcC,EAAIC,EAAMC,GAC7B,GAAIA,GAA6B,IAArBC,UAAUC,OAAc,IAAK,IAA4BC,EAAxBC,EAAI,EAAGC,EAAIN,EAAKG,OAAYE,EAAIC,EAAGD,KACxED,GAAQC,KAAKL,IACRI,IAAIA,EAAKG,MAAMC,UAAUC,MAAMC,KAAKV,EAAM,EAAGK,IAClDD,EAAGC,GAAKL,EAAKK,IAGrB,OAAON,EAAGY,OAAOP,GAAMG,MAAMC,UAAUC,MAAMC,KAAKV,IAMtD,SAASY,EAAWC,GAChB,OAAOA,EAAO,IAAMA,EAAO,GAK/B,SAASC,EAAUD,EAAMb,EAAMD,GAI3B,OAFAA,EAAKA,GAAM,IACXc,IAAQ,MAFRb,EAAOA,GAAQ,KAGQa,GAAQd,EAEnC,SAASgB,EAAmBF,GACxB,OAAOD,EAAWC,IAASG,EAAYH,GAE3C,SAASG,EAAYH,GACjB,OAAgB,KAATA,GAAuBC,EAAUD,GAc5C,SAASI,EAAQJ,GACb,OATJ,SAAwBA,GACpB,OAAgB,KAATA,GACS,IAATA,GACS,MAATA,EAMAK,CAAeL,IACN,KAATA,GACS,KAATA,EAKX,SAASM,EAAUN,GACf,OAAgB,KAATA,GAAgC,KAATA,MAM5BO,EAAAA,WACF,WAAYC,EAAKC,EAAOC,IAAK,eACd,MAAPA,GAA8B,kBAARF,IACtBE,EAAMF,EAAIlB,QAEdqB,KAAKC,OAASJ,EACdG,KAAKE,IAAMF,KAAKF,MAAQA,GAAS,EACjCE,KAAKD,IAAMA,GAAO,oCAKtB,WACI,OAAOC,KAAKE,KAAOF,KAAKD,yBAO5B,SAAMD,EAAOC,GACT,OAAO,IAAIH,EAAQI,KAAKC,OAAQH,EAAOC,uBAM3C,WACI,OAAOC,KAAKC,OAAOE,WAAWH,KAAKE,yBAMvC,WACI,GAAIF,KAAKE,IAAMF,KAAKC,OAAOtB,OACvB,OAAOqB,KAAKC,OAAOE,WAAWH,KAAKE,0BAS3C,SAAIE,GACA,IAAMC,EAAKL,KAAKM,OACVC,EAAsB,oBAAVH,EAAuBA,EAAMC,GAAMA,IAAOD,EAI5D,OAHIG,GACAP,KAAKQ,OAEFD,0BAMX,SAASH,GAEL,IADA,IAAMN,EAAQE,KAAKE,KACXF,KAAKS,OAAST,KAAKU,IAAIN,KAC/B,OAAOJ,KAAKE,MAAQJ,wBAMxB,SAAOa,GACHX,KAAKE,KAAQS,GAAK,yBAMtB,WACI,OAAOX,KAAKY,UAAUZ,KAAKF,MAAOE,KAAKE,8BAK3C,SAAUJ,EAAOC,GACb,OAAOC,KAAKC,OAAOhB,MAAMa,EAAOC,wBAKpC,SAAMc,GAAyB,IAAhBX,EAAgB,uDAAVF,KAAKE,IACtB,OAAO,IAAIY,EAAJ,UAAoBD,EAApB,eAAkCX,EAAM,GAAKA,EAAKF,KAAKC,cAtFhEL,GAyFAkB,EAAAA,SAAAA,iCACF,WAAYD,EAASX,EAAKL,GAAK,6BAC3B,cAAMgB,IACDX,IAAMA,EACX,EAAKD,OAASJ,EAHa,mBAD7BiB,SAAqBC,QAQ3B,SAASC,EAAeC,GACpB,MAAO,CACHA,OAAAA,EACAnB,MAAO,EACPI,IAAK,EACLgB,KAAMD,EAAOtC,QAGrB,SAASwC,EAAOC,GACZ,OAAOA,EAAQH,OAAOG,EAAQlB,KAElC,SAASM,EAAKY,GACV,OAAOA,EAAQH,OAAOG,EAAQlB,OAElC,SAASjB,EAAMmC,GAAiD,IAAxC5C,EAAwC,uDAAjC4C,EAAQtB,MAAOvB,EAAkB,uDAAb6C,EAAQlB,IACvD,OAAOkB,EAAQH,OAAOhC,MAAMT,EAAMD,GAEtC,SAAS8C,EAAWD,GAChB,OAAOA,EAAQlB,IAAMkB,EAAQF,KAEjC,SAASI,EAAUF,EAASG,GACxB,IAAMC,EAAQL,EAAOC,GACrB,SAAII,IAASD,EAAKC,MACdJ,EAAQlB,OACD,GAIf,SAASuB,EAAQL,EAASP,GAAkC,IAAzBW,EAAyB,uDAAjBL,EAAOC,GAC1CI,GAAwB,MAAfA,EAAM1B,QACfe,GAAW,OAAJ,OAAWW,EAAM1B,QAE5B,IAAM4B,EAAM,IAAIX,MAAMF,GAEtB,OADAa,EAAG,IAAUF,GAASA,EAAM1B,MACrB4B,EAWX,SAASC,EAAWP,EAASQ,GAQzB,IAPA,IAKIC,EALEC,EAAS,CACXC,KAAM,aACNC,SAAU,IAEVC,EAAMH,EAEJI,EAAQ,GACPb,EAAWD,KACVS,EAAOM,EAAUf,EAASQ,IAAYQ,EAAMhB,EAASQ,KAErD,GADAK,EAAID,SAASK,KAAKR,GACdP,EAAUF,EAASkB,GACnBJ,EAAMG,KAAKJ,GACXA,EAAMJ,MAEL,IAAIP,EAAUF,EAASmB,GACxB,SAEC,GAAIjB,EAAUF,EAASoB,GACxB,GACQN,EAAMvD,SACNsD,EAAMC,EAAMO,aAEXnB,EAAUF,EAASoB,IAOxC,OAAOV,EAKX,SAASM,EAAMhB,EAASQ,GACpB,GAAIN,EAAUF,EAASsB,GAAe,CAClC,IAAMZ,EAASH,EAAWP,EAASQ,GAKnC,OAHIe,EADUnC,EAAKY,GACI,SAAS,KAC5BU,EAAOc,OA8GnB,SAAkBxB,GACd,OAAOyB,EAAW1B,EAAOC,IACnBA,EAAQH,OAAOG,EAAQlB,YACvB,EAjHkB4C,CAAS1B,IAEtBU,GAMf,SAASK,EAAUf,EAASQ,GACxB,IAAImB,EACEC,EAAO,CACTjB,KAAM,eACNkB,UAAM,EACNC,gBAAY,EACZC,WAAO,EACPP,YAAQ,EACRQ,WAAW,EACXpB,SAAU,IAKd,IA+JJ,SAAqBZ,EAASQ,GAC1B,IAAM9B,EAAQsB,EAAQlB,IACtB,GAAI0B,EAAQ1D,KAAOoD,EAAUF,EAASiC,GAGlC,KAAOhC,EAAWD,IAAU,CACxB,IAAQlB,EAAQkB,EAARlB,IACR,IAAKoB,EAAUF,EAASkC,KAAyBhC,EAAUF,EAASiC,GAAuB,CACvFjC,EAAQlB,IAAMA,EACd,OAIZ,KAAOmB,EAAWD,IAAYE,EAAUF,EAASmC,KAGjD,GAAInC,EAAQlB,MAAQJ,EAEhB,OADAsB,EAAQtB,MAAQA,GACT,EAEX,OAAO,EAtLH0D,CAAYpC,EAASQ,KACrBoB,EAAKC,KAAOhE,EAAMmC,IAEfC,EAAWD,IAEd,GADAA,EAAQtB,MAAQsB,EAAQlB,IACnB8C,EAAKJ,QAAWa,EAAQT,KAAS1B,EAAUF,EAASyB,GAGpD,IAAKG,EAAKG,OAASO,EAAKtC,GACzB4B,EAAKG,MAAQQ,EAAQvC,OAEpB,MAAI2B,EAAOa,EAAexC,EAAS,KAAMQ,IAAYgC,EAAexC,EAAS,QAASQ,IAAYiC,EAAazC,IAQ/G,EACIqC,EAAQT,IAAS1B,EAAUF,EAAS0C,MACrCd,EAAKI,WAAY,GACZJ,EAAKJ,QAAUtB,EAAUF,EAASyB,KACnCG,EAAKJ,OAASxB,EAAQH,OAAOG,EAAQlB,IAAM,KAGnD,MAdK8C,EAAKE,WAINF,EAAKE,WAAaF,EAAKE,WAAW/D,OAAO4D,GAHzCC,EAAKE,WAAanE,MAAMgF,QAAQhB,GAAQA,EAAK9D,QAAU,CAAC8D,QAP5DC,EAAKJ,OAASxB,EAAQH,OAAOG,EAAQlB,IAAM,GAuBnD,OAAQuD,EAAQT,QAAe,EAAPA,EAK5B,SAASa,EAAazC,GAClB,GAAIE,EAAUF,EAAS4C,GAAsB,CAGzC,IAFA,IACIjB,EADEG,EAAa,GAEZ7B,EAAWD,IACd,GAAI2B,EAAOkB,EAAU7C,GACjB8B,EAAWb,KAAKU,OAEf,IAAIzB,EAAUF,EAAS8C,GACxB,MAEC,IAAK5C,EAAUF,EAAS+C,GACzB,MAAM1C,EAAQL,EAAD,sBAAyBD,EAAOC,GAASW,KAAzC,YAGrB,OAAOmB,GAMf,SAASU,EAAexC,EAASW,EAAMH,GACnC,GAAIwC,EAAajD,EAAOC,GAAUW,GAAO,CACrCX,EAAQlB,MACR,IAAM6C,EAAO,CACTE,KAAM,EAkNOE,EAlNUpB,EAmNxB,CAAEA,KAAM,UAAWoB,MAAAA,MAzMtB,OAPIvB,EAAQ1D,KAAOwF,EAAKtC,IACpB2B,EAAKI,MAAQQ,EAAQvC,GACrB2B,EAAKsB,YAAa,GAGlBtB,EAAKI,MAAQmB,EAAUlD,GAAWnC,EAAMmC,QAAW,EAEhD2B,EAwMf,IAAyBI,EAlMzB,SAASc,EAAU7C,GACf,OAAImD,EAAOnD,GAEA,CACH+B,MAAOlE,EAAMmC,IAGjBkD,EAAUlD,GAAS,GACZ,CACH6B,KAAMhE,EAAMmC,GACZ+B,MAAO7B,EAAUF,EAASoD,KAAcD,EAAOnD,IAAYkD,EAAUlD,GAAS,IACxEnC,EAAMmC,QACN,QALd,EAiBJ,SAASmD,EAAOnD,GACZ,IAAMtB,EAAQsB,EAAQlB,IAChBuE,EAAQtD,EAAOC,GACrB,GAAIsD,EAAUD,GAAQ,CAElB,IADArD,EAAQlB,MACDmB,EAAWD,IACd,GAAIsD,EAAUlE,EAAKY,GAAUqD,EAAME,QAE/B,OADAvD,EAAQtB,MAAQA,GACT,EAGf,MAAM2B,EAAQL,EAAS,iBAAkBqD,GAE7C,OAAO,EAKX,SAASH,EAAUlD,EAASwD,GAOxB,IANA,IAAM9E,EAAQsB,EAAQlB,IAChB2E,EAAW,CACbZ,UAAW,EACXI,WAAY,EACZjC,MAAO,GAEJf,EAAWD,IAAU,CACxB,IAAMI,EAAQL,EAAOC,GACrB,GAAIyD,EAASR,WAEL1B,EAAYnB,EAAO,gBACnBqD,EAASrD,EAAMsD,UAAYtD,EAAMuD,KAAO,GAAK,OAGhD,IAAIL,EAAUlD,IAAU4C,EAAa5C,IAAU2C,EAAe3C,IAAUqB,EAAWrB,GACpF,MAEC,GAAImB,EAAYnB,GAAQ,CACzB,IAAKoD,EACD,MAEJ,GAAIpD,EAAMuD,KACNF,EAASrD,EAAMsD,eAEd,KAAKD,EAASrD,EAAMsD,SAGrB,MAGAD,EAASrD,EAAMsD,aAGvB1D,EAAQlB,MAEZ,OAAIJ,IAAUsB,EAAQlB,MAClBkB,EAAQtB,MAAQA,GACT,GAgCf,SAAS4D,EAAKtC,GACV,IAAMtB,EAAQsB,EAAQlB,IACtB,GAAIoB,EAAUF,EAAS4D,GAAc,CAEjC,IADA,IAAIH,EAAW,EACRxD,EAAWD,IAAU,CACxB,IAAMI,EAAQhB,EAAKY,GACnB,GAAIuB,EAAYnB,EAAO,cACnB,GAAIA,EAAMuD,KACNF,QAEC,KAAKA,EACN,MAGAA,KAKZ,OADAzD,EAAQtB,MAAQA,GACT,EAEX,OAAO,EAEX,SAAS6D,EAAQvC,GACb,IAAI5C,EAAO4C,EAAQtB,MACfvB,EAAK6C,EAAQlB,IAOjB,OANIyC,EAAYvB,EAAQH,OAAOzC,GAAO,cAAc,IAChDA,IAEAmE,EAAYvB,EAAQH,OAAO1C,EAAK,GAAI,cAAc,IAClDA,IAEGU,EAAMmC,EAAS5C,EAAMD,GAEhC,SAASoE,EAAYnB,EAAOsD,EAASG,GACjC,OAAOC,QAAQ1D,GAAwB,YAAfA,EAAMO,QACrB+C,GAAWtD,EAAMsD,UAAYA,KACpB,MAAVG,GAAkBzD,EAAMuD,OAASE,IAE7C,SAASb,EAAa5C,EAAOO,GACzB,OAAOmD,QAAQ1D,GAAwB,aAAfA,EAAMO,QAAyBA,GAAQP,EAAM2D,WAAapD,IAEtF,SAAS2C,EAAUlD,EAAO4D,GACtB,OAAOF,QAAQ1D,GAAwB,UAAfA,EAAMO,OAAiC,MAAZqD,GAAoB5D,EAAMmD,SAAWS,IAE5F,SAASjB,EAAe3C,GACpB,OAAO0D,QAAQ1D,GAAwB,eAAfA,EAAMO,MAElC,SAASyC,EAAShD,GACd,OAAO4C,EAAa5C,EAAO,SAE/B,SAASqB,EAAWrB,GAChB,OAAO0D,QAAQ1D,GAAwB,aAAfA,EAAMO,MAKlC,SAASsB,EAAqB7B,GAC1B,GAJJ,SAAqBA,GACjB,MAAsB,YAAfA,EAAMO,KAGTsD,CAAY7D,GAAQ,CACpB,IAAMnB,EAAKmB,EAAM2B,MAAMhD,WAAW,GAClC,OAAOE,GAAM,IAAMA,GAAM,GAE7B,OAAO,EAEX,SAASkD,EAAc/B,GACnB,MAAsB,YAAfA,EAAMO,MAAqC,mBAAfP,EAAMO,MAA4C,wBAAfP,EAAMO,KAEhF,SAASuB,EAAoB9B,GACzB,OAAO4C,EAAa5C,EAAO,SAE/B,SAASwC,EAAoBxC,GACzB,OAAOmB,EAAYnB,EAAO,aAAa,GAE3C,SAAS0C,EAAkB1C,GACvB,OAAOmB,EAAYnB,EAAO,aAAa,GAE3C,SAASwD,EAAYxD,GACjB,OAAOmB,EAAYnB,EAAO,cAAc,GAE5C,SAASkB,EAAalB,GAClB,OAAOmB,EAAYnB,EAAO,SAAS,GAKvC,SAASiC,EAAQT,GACb,OAAQA,EAAKC,OAASD,EAAKG,QAAUH,EAAKE,WAE9C,SAASZ,EAAgBd,GACrB,OAAO4C,EAAa5C,EAAO,SAE/B,SAASe,EAAoBf,GACzB,OAAO4C,EAAa5C,EAAO,WAE/B,SAASgB,EAAgBhB,GACrB,OAAO4C,EAAa5C,EAAO,SAE/B,SAASsC,GAAgBtC,GACrB,OAAO4C,EAAa5C,EAAO,SAM/B,SAAS8D,GAAQlE,GACb,QAAIA,EAAQV,IAAI,MACZU,EAAQtB,MAAQsB,EAAQlB,IACnBkB,EAAQX,OACTW,EAAQlB,OAEL,GAqCf,SAASqF,GAAWnE,EAASa,GACzB,OA0LJ,SAAiBb,EAASa,GACtB,IAAMnC,EAAQsB,EAAQlB,IAEtB,IAAK+B,EAAIoC,YAAcpC,EAAIgC,YAAc7C,EAAQV,IAAI,KAAoBU,EAAQV,IAAI,KAA6B,CAE9G,IAAI8E,EADJpE,EAAQtB,MAAQsB,EAAQlB,IAExB,IAAI+C,EAAO,GAUX,GATI7B,EAAQqE,SAASrG,IAEjBoG,EAAQE,OAAOtE,EAAQuE,WACvB1C,EAAO7B,EAAQV,IAAI,IAAkBkF,GAAqBxE,GAAW,IAEhE9B,EAAU8B,EAAQd,UAEvB2C,EAAO2C,GAAqBxE,IAE5BA,EAAQV,IAAI,KACZ,MAAO,CACHqB,KAAM,QACNyD,MAAAA,EAAOvC,KAAAA,EACPnD,MAAAA,EACAC,IAAKqB,EAAQlB,KAGrB,MAAMkB,EAAQyE,MAAM,eAIxBzE,EAAQlB,IAAMJ,EAtNPgG,CAAQ1E,EAASa,IA6I5B,SAA6Bb,GACzB,IAAMtB,EAAQsB,EAAQlB,IACtB,GAAIkB,EAAQV,IAAI,KAAoBU,EAAQV,IAAI,IAC5C,MAAO,CACHqB,KAAM,sBACNoB,WAAO,EACPrD,MAAAA,EACAC,IAAKqB,EAAQlB,KAGrBkB,EAAQlB,IAAMJ,EAtJPiG,CAAoB3E,IA2J/B,SAAwBA,GACpB,IAAMtB,EAAQsB,EAAQlB,IACtB,GAAIkB,EAAQqE,SAAS,IAAkB,CACnC,IAAMvE,EAAOE,EAAQlB,IAAMJ,EACvBkG,GAAU,EACVC,EAAO,EACPC,EAAS,EACb,GAAI9E,EAAQV,IAAI,IAAc,CAE1B,KAAOU,EAAQV,IAAI,KACfwF,IAEJF,EAAU5E,EAAQV,IAAI,IACtBU,EAAQtB,MAAQsB,EAAQlB,IACpBkB,EAAQqE,SAASrG,KACjB6G,EAAOP,OAAOtE,EAAQuE,YAI9B,OADAvE,EAAQtB,MAAQA,EACT,CACHiC,KAAM,iBACNb,KAAAA,EACA8E,QAAAA,EACAC,KAAAA,EACAC,OAAAA,EACApG,MAAAA,EACAC,IAAKqB,EAAQlB,MApLdiG,CAAe/E,IAkH1B,SAAoBA,GAChB,IAAMtB,EAAQsB,EAAQlB,IACtB,GAAIkB,EAAQV,IAAI,IAAoB,CAChCU,EAAQtB,MAAQsB,EAAQlB,IACxB,IAAIkG,EAAQ,EACRC,GAAW,EAOf,OANIjF,EAAQqE,SAASrG,GACjBgH,EAAQV,OAAOtE,EAAQuE,WAGvBU,GAAW,EAER,CACHtE,KAAM,WACNqE,MAAAA,EACAjD,MAAO,EACPkD,SAAAA,EACAvG,MAAAA,EACAC,IAAKqB,EAAQlB,MAnIdoG,CAAWlF,IAsDtB,SAAsBA,GAClB,IAAMtB,EAAQsB,EAAQlB,IACtB,GAAIkB,EAAQqE,SAAShG,GACjB,MAAO,CACHsC,KAAM,aACNjC,MAAAA,EACAC,IAAKqB,EAAQlB,IACbiD,MAAO/B,EAAQR,UAAUd,EAAOsB,EAAQlB,MA5DzCqG,CAAanF,IASxB,SAAqBA,EAASa,GAC1B,IAAMnC,EAAQsB,EAAQlB,IAClBiD,EAAQ,GACZ,MAAQ/B,EAAQX,OAEZ,GAAI6E,GAAQlE,GACR+B,GAAS/B,EAAQuE,cADrB,CAIA,IAAMtF,EAAKe,EAAQd,OACnB,GAAID,IAAO4B,EAAIwC,OAAgB,KAAPpE,GAA0BmG,GAAkBnG,EAAI4B,GAIpE,MAEJ,GAAIA,EAAIoC,YAAqB,MAAPhE,EAClB,MAEJ,IAAK4B,EAAIwC,QAAUxC,EAAIoC,WAAY,CAE/B,IAAKpC,EAAIgC,YAAcwC,GAAgBpG,GACnC,MAEJ,GAAIqG,GAAerG,EAAI4B,IAAQ0E,GAAkBtG,EAAI4B,IAAQtC,EAAUU,IAAOuG,GAAYvG,GAEtF,MAGR8C,GAAS/B,EAAQnB,OAAOmB,EAAQlB,OAEpC,GAAIJ,IAAUsB,EAAQlB,IAElB,OADAkB,EAAQtB,MAAQA,EACT,CACHiC,KAAM,UACNoB,MAAAA,EACArD,MAAAA,EACAC,IAAKqB,EAAQlB,KA7Cd2G,CAAYzF,EAASa,IAgGhC,SAAoBb,GAChB,IAAM0F,EAAKC,GAAe3F,EAAQd,QAClC,GAAIwG,EACA,MAAO,CACH/E,KAAM,WACNoD,SAAU2B,EACVhH,MAAOsB,EAAQlB,MACfH,IAAKqB,EAAQlB,KAtGd8G,CAAW5F,IAiEtB,SAAeA,GACX,IAAMf,EAAKe,EAAQd,OACnB,GAAIX,EAAUU,GACV,MAAO,CACH0B,KAAM,QACN4C,OAAe,KAAPtE,EACRP,MAAOsB,EAAQlB,MACfH,IAAKqB,EAAQlB,KAvEduE,CAAMrD,IA8EjB,SAAmBA,GACf,IAAMf,EAAKe,EAAQd,OACbwE,EAAU8B,GAAYvG,GAC5B,GAAIyE,EACA,MAAO,CACH/C,KAAM,UACNgD,KAAMkC,GAAgB5G,GACtByE,QAAAA,EACAhF,MAAOsB,EAAQlB,MACfH,IAAKqB,EAAQlB,KAtFdgH,CAAU9F,GAmNrB,SAASwE,GAAqBuB,GAC1B,IAAMjF,EAAQ,GAEd,IADAiF,EAAOrH,MAAQqH,EAAOjH,KACdiH,EAAO1G,OACX,GAAI0G,EAAOzG,IAAI,KACXwB,EAAMG,KAAK8E,EAAOjH,UAEjB,GAAIiH,EAAOzG,IAAI,KAA8B,CAC9C,IAAKwB,EAAMvD,OAAQ,CACfwI,EAAOjH,MACP,MAEJgC,EAAMO,WAGN0E,EAAOjH,MAGf,GAAIgC,EAAMvD,OAEN,MADAwI,EAAOjH,IAAMgC,EAAMO,MACb0E,EAAOtB,MAAP,eAEV,OAAOsB,EAAOxB,UAKlB,SAASa,GAAkBnG,EAAI4B,GAC3B,IAAM6E,EAAKC,GAAe1G,GAC1B,SAAKyG,GAAM7E,EAAIwC,OAASxC,EAAIoC,eAKpBpC,EAAIgC,WAAoB,UAAP6C,GAM7B,SAASJ,GAAerG,EAAI4B,GACxB,OAAOxC,EAAQY,KAAQ4B,EAAIoC,WAK/B,SAASsC,GAAkBtG,EAAI4B,GAC3B,OAAc,KAAP5B,IAA6B4B,EAAIgC,YAAchC,EAAIoC,WAK9D,SAASuC,GAAYvG,GACjB,OAAW,KAAPA,GAA2C,KAAPA,EAC7B,QAEA,KAAPA,GAA4C,KAAPA,EAC9B,YAEA,MAAPA,GAA4C,MAAPA,EAC9B,kBADX,EAOJ,SAAS0G,GAAe1G,GACpB,OAAe,KAAPA,EAAyB,QAClB,KAAPA,GAA2B,YACpB,KAAPA,GAAyB,SAClB,KAAPA,GAAuB,SAChB,KAAPA,GAAwB,MACjB,KAAPA,GAAyB,SAClB,KAAPA,GAA0B,cAC3B,EAKX,SAAS4G,GAAgB5G,GACrB,OAAc,MAAPA,GACO,KAAPA,GACO,KAAPA,EAKX,SAASoG,GAAgBpG,GACrB,OAAOd,EAAmBc,IACZ,KAAPA,GACO,KAAPA,GACO,KAAPA,EAGX,IAAM+G,GAAY,CACdC,MAAO,IACPC,MAAO,IACPC,MAAO,IACPC,GAAI,IACJC,MAAO,IACPC,MAAO,IACPC,QAAS,KAEPC,GAAe,CACjBC,QADiB,SACTrG,GACJ,OAAOA,EAAM2B,OAEjB2E,MAJiB,SAIXtG,GACF,OAAOA,EAAMmD,OAAS,IAAO,KAEjCoD,QAPiB,SAOTvG,GACJ,MAAsB,cAAlBA,EAAMsD,QACCtD,EAAMuD,KAAO,IAAM,IAEH,eAAlBvD,EAAMsD,QACJtD,EAAMuD,KAAO,IAAM,IAGnBvD,EAAMuD,KAAO,IAAM,KAGlCiD,SAlBiB,SAkBRxG,GACL,OAAO4F,GAAU5F,EAAM2D,WAE3B8C,MArBiB,SAqBXzG,EAAO0G,GACT,OAAmB,MAAf1G,EAAMgE,MAEChE,EAAMyB,KAAN,YACKzB,EAAMgE,MADX,YACoBhE,EAAMyB,KAD1B,iBAEKzB,EAAMgE,OAEbhE,EAAMyB,KAEJiF,EAAMC,YAAY3G,EAAMyB,MAE5B,IAEXmF,oBAlCiB,SAkCG5G,EAAO0G,GAGvB,IADA,IAAIpF,EACKjE,EAAIqJ,EAAMG,UAAU1J,OAAS,EAAGE,GAAK,EAAGA,IAC7C,GAAIqJ,EAAMG,UAAUxJ,GAAGwH,SAAU,CAC7BvD,EAAWoF,EAAMG,UAAUxJ,GAC3B,MAIR,OADAqJ,EAAMI,UAAW,EACVJ,EAAMvE,QAAQb,GAAYA,EAASK,QAE9CoF,eA9CiB,SA8CF/G,EAAO0G,GAClB,IAAI/E,EAAQ,EACNqF,EAASN,EAAMG,UAAU1J,OAAS,EAElCmE,EAAWoF,EAAMG,UAAUG,GACjC,GAAI1F,IACAK,EAAQ3B,EAAMwE,QACRxE,EAAMyE,KAAOnD,EAASsD,MAAQtD,EAASK,MAAQ,EAC/C3B,EAAMyE,KAAOnD,EAASK,MACxB3B,EAAM0E,QAAQ,CACd,IAAMuC,EAAWC,KAAKC,IAAI,EAAGH,EAAShH,EAAM0E,QAC5C,GAAIuC,IAAaD,EAAQ,CACrB,IAAMI,EAAiBV,EAAMG,UAAUI,GACvCtF,GAASL,EAASsD,MAAQwC,EAAezF,OAKrD,IADA,IAAIrB,EAAS+G,OAAO1F,GACbrB,EAAOnD,OAAS6C,EAAMN,MACzBY,EAAS,IAAMA,EAEnB,OAAOA,GAEXgH,WArEiB,SAqENtH,GACP,OAAOA,EAAM2B,QAMrB,SAAS4F,GAAYvH,EAAO0G,GACxB,IAAKN,GAAapG,EAAMO,MACpB,MAAM,IAAIhB,MAAJ,wBAA2BS,EAAMO,OAE3C,OAAO6F,GAAapG,EAAMO,MAAMP,EAAO0G,GAG3C,IAAMc,GAAW,iDACXC,GAAa,2CA+DnB,SAASC,GAAiBrH,EAAMqG,GAC5B,IAAIpG,EAAS,GACb,GAAID,EAAKe,OAAQ,CAGb,IAKIuG,EALEC,EAAWvH,EAAKe,OAChBA,EAASyG,OAAOC,OAAO,GAAIF,GACjCxG,EAAOwD,MAAQxD,EAAOyD,UAAYtH,MAAMgF,QAAQmE,EAAMxE,MAChDwE,EAAMqB,UAAU5K,OACfiE,EAAOwD,OAAS,EAEvB8B,EAAMG,UAAUhG,KAAKO,GACrB,IAAK,IAAI/D,EAAI,EAAGA,EAAI+D,EAAOwD,MAAOvH,IAAK,CAMnC,GALA+D,EAAOO,MAAQtE,EACfgD,EAAKe,OAASA,EACduG,EAAQK,GAAQ3H,GACV4H,GAAa5H,EAAMqG,GACnBwB,GAAe7H,EAAMqG,GACvBtF,EAAOyD,WAAa6B,EAAMI,SAAU,CAGpC,IAAMqB,EAASC,GAAOT,GAChBU,EAAUF,GAAUG,GAAYH,GAClCE,GACAE,GAAWF,EAAS3B,EAAMvE,QAAQf,EAAOO,QAMjD,GAHArB,EAASA,EAAO3C,OAAOgK,KAGjBjB,EAAM8B,aAAe,EACvB,MAGR9B,EAAMG,UAAU5F,MAChBZ,EAAKe,OAASwG,EACVxG,EAAOyD,WACP6B,EAAMI,UAAW,QAIrBxG,EAASA,EAAO3C,OAAOqK,GAAQ3H,GAAQ4H,GAAa5H,EAAMqG,GAASwB,GAAe7H,EAAMqG,IAE5F,OAAOpG,EAEX,SAAS4H,GAAe7H,EAAMqG,GAC1B,IADiC,EAC7B+B,EAAW,GACTjH,EAAO,CACTjB,KAAM,mBACNkB,KAAMpB,EAAKoB,MAAQiH,GAAcrI,EAAKoB,KAAMiF,GAC5C/E,MAAOtB,EAAKsB,OAASgH,GAAiBtI,EAAKsB,MAAO+E,GAClDhF,gBAAY,EACZ+G,SAAAA,EACArH,OAAQf,EAAKe,QAAUyG,OAAOC,OAAO,GAAIzH,EAAKe,QAC9CwH,YAAavI,EAAKuB,WAElBtB,EAAS,CAACkB,GAXmB,UAYbnB,EAAKG,UAZQ,IAYjC,2BAAmC,KAAxBqF,EAAwB,QAC/B4C,EAAWA,EAAS9K,OAAO+J,GAAiB7B,EAAOa,KAbtB,8BAejC,GAAIrG,EAAKqB,WAAY,CACjBF,EAAKE,WAAa,GADD,gBAEErB,EAAKqB,YAFP,IAEjB,2BAAoC,KAAzBH,EAAyB,QAChCC,EAAKE,WAAWb,KAAKgI,GAAiBtH,EAAMmF,KAH/B,+BAgBrB,OARKlF,EAAKC,MAASD,EAAKE,aAAcF,EAAKG,OAAUH,EAAKG,MAAMmH,KAAKC,IAMjEvH,EAAKiH,SAAWA,EAHhBnI,EAASA,EAAO3C,OAAO8K,GAKpBnI,EAEX,SAAS2H,GAAa5H,EAAMqG,GACxB,IAD+B,EAC3BpG,EAAS,GADkB,UAEXD,EAAKG,UAFM,IAE/B,2BAAmC,KAAxBqF,EAAwB,QAC/BvF,EAASA,EAAO3C,OAAO+J,GAAiB7B,EAAOa,KAHpB,8BAQ/B,OAHIrG,EAAKe,SACLd,EAqIR,SAAwBqH,EAAOrG,GAAU,gBAClBqG,GADkB,IACrC,2BAA0B,KAAfqB,EAAe,QACjBA,EAAK5H,SACN4H,EAAK5H,OAASyG,OAAOC,OAAO,GAAIxG,KAHH,8BAMrC,OAAOqG,EA3IMsB,CAAe3I,EAAQD,EAAKe,SAElCd,EAEX,SAASuI,GAAiBxI,EAAMqG,GAC5B,IAGI/E,EAHAuH,GAAU,EACVC,GAAY,EACZC,EAAY/I,EAAKwC,WAAa,aAAe,MAE3CpB,EAAOpB,EAAKoB,MAAQiH,GAAcrI,EAAKoB,KAAMiF,GAOnD,GANIjF,GAAoB,MAAZA,EAAK,KACbyH,GAAU,GAEVzH,GAAkC,MAA1BA,EAAKA,EAAKtE,OAAS,KAC3BgM,GAAY,GAEZ9I,EAAKsB,MAAO,CACZ,IAAMlC,EAASY,EAAKsB,MAAMlE,QAC1B,GAAIyF,EAAUzD,EAAO,IAAK,CAGtB,IAAMwD,EAAQxD,EAAO4J,QACjB5J,EAAOtC,QAAUiL,GAAO3I,GAAQc,OAAS0C,EAAM1C,MAC/Cd,EAAOwB,MAEXmI,EAAYnG,EAAME,OAAS,cAAgB,mBAEtChC,EAAY1B,EAAO,GAAI,cAAc,KAE1C2J,EAAY,aACZ3J,EAAO4J,QACHlI,EAAYiH,GAAO3I,GAAS,cAAc,IAC1CA,EAAOwB,OAGfU,EAAQgH,GAAiBlJ,EAAQiH,GAErC,MAAO,CACHjF,KAAM0H,GAAaD,EACbzH,EAAKhE,MAAMyL,EAAU,EAAI,EAAGC,GAAa,OAAI,GAC7C1H,EACNE,MAAAA,EACA2H,QAASH,EACTD,QAAAA,EACAE,UAAAA,GAMR,SAASV,GAAcjJ,EAAQiH,GAE3B,IADA,IAAIrI,EAAM,GACDhB,EAAI,EAAGA,EAAIoC,EAAOtC,OAAQE,IAC/BgB,GAAOkJ,GAAY9H,EAAOpC,GAAIqJ,GAElC,OAAOrI,EAKX,SAASsK,GAAiBlJ,EAAQiH,GAG9B,IAFA,IAEgB1G,EAFVM,EAAS,GACXjC,EAAM,GACDhB,EAAI,EAAUA,EAAIoC,EAAOtC,OAAQE,IAElC0L,GADJ/I,EAAQP,EAAOpC,KAKPgB,IACAiC,EAAOO,KAAKxC,GACZA,EAAM,IAEViC,EAAOO,KAAKb,IAGZ3B,GAAOkJ,GAAYvH,EAAO0G,GAMlC,OAHIrI,GACAiC,EAAOO,KAAKxC,GAETiC,EAEX,SAAS0H,GAAQ3H,GACb,MAAqB,eAAdA,EAAKE,KAEhB,SAASwI,GAAU/I,GACf,MAAwB,kBAAVA,GAAqC,UAAfA,EAAMO,MAAmC,MAAfP,EAAMgE,MAExE,SAASoE,GAAOmB,GACZ,OAAOA,EAAIA,EAAIpM,OAAS,GAE5B,SAASmL,GAAYjI,GACjB,OAAOA,EAAKoI,SAAStL,OAASmL,GAAYF,GAAO/H,EAAKoI,WAAapI,EAEvE,SAASkI,GAAWlI,EAAM6B,GAClB7B,EAAKsB,MAEoB,kBADPyG,GAAO/H,EAAKsB,OAE1BtB,EAAKsB,MAAMtB,EAAKsB,MAAMxE,OAAS,IAAM+E,EAGrC7B,EAAKsB,MAAMd,KAAKqB,GAIpB7B,EAAKsB,MAAQ,CAACO,GAGtB,SAASsH,GAAWnJ,EAAM6B,GACtB,IAAIuH,EACAC,EAAO,GACPlC,GAASzH,KAAKmC,GAET,OAAOnC,KADZ2J,EAAOxH,IACoBwH,EAAKC,WAAW,QACvCD,EAAO,UAAH,OAAaA,IAGhBjC,GAAW1H,KAAKmC,KACrBwH,EAAO,UAAH,OAAaxH,IAErB,IAAM0H,EAA2C,QAA1BH,EAAKpJ,EAAKqB,kBAA+B,IAAP+H,OAAgB,EAASA,EAAGI,MAAK,SAAAtI,GAAI,MAAkB,SAAdA,EAAKE,QAClGmI,EAMKA,EAAcjI,QACpBiI,EAAcjI,MAAQ,CAAC+H,KANlBrJ,EAAKqB,aACNrB,EAAKqB,WAAa,IAEtBrB,EAAKqB,WAAWb,KAAK,CAAEY,KAAM,OAAQE,MAAO,CAAC+H,GAAON,UAAW,iBAkBvE,SAASU,GAAkBC,EAAM3J,GAC7B,IAEI,OAlSR,SAAiB2J,GAAoB,IAE7BhC,EAFe3H,EAAc,uDAAJ,GACzB4J,GAAe,EAEf5J,EAAQ8B,OAEJ6F,EADAxK,MAAMgF,QAAQnC,EAAQ8B,MACV9B,EAAQ8B,KAAK+H,QAAO,SAAAC,GAAC,OAAIA,EAAEC,UAG3B/J,EAAQ8B,MAG5B,IAAM5B,EAAS,CACXC,KAAM,eACNkI,SAAUR,GAAa8B,EAAM,CACzBjD,UAAU,EACVD,UAAW,GACX3E,KAAM9B,EAAQ8B,KACd6F,UAAAA,EACAS,YAAapI,EAAQgK,WAAalG,OAAOmG,kBACzClI,QANyB,SAMjBzD,GACJ,IAAI+K,EAEA9H,EACJ,GAFAqI,GAAe,EAEXzM,MAAMgF,QAAQnC,EAAQ8B,MAAO,CAC7B,QAAYoI,IAAR5L,GAAqBA,GAAO,GAAKA,EAAMqJ,EAAU5K,OACjD,OAAO4K,EAAUrJ,GAErBiD,OAAgB2I,IAAR5L,EAAoB0B,EAAQ8B,KAAKxD,GAAO0B,EAAQ8B,KAAKqI,KAAK,WAGlE5I,EAAgC,QAAvB8H,EAAKrJ,EAAQ8B,YAAyB,IAAPuH,EAAgBA,EAAK,GAEjE,OAAO9H,GAEXgF,YArByB,SAqBblF,GACR,IAAM+I,EAAWpK,EAAQqK,WAAarK,EAAQqK,UAAUhJ,GACxD,OAAmB,MAAZ+I,EAAmBA,EAAW/I,MAIjD,GAAoB,MAAhBrB,EAAQ8B,OAAiB8H,EAAc,CAGvC,IAAM3B,EAAUC,GAAYF,GAAO9H,EAAOmI,WAC1C,GAAIJ,EAAS,CACT,IAAMnG,EAAO3E,MAAMgF,QAAQnC,EAAQ8B,MAAQ9B,EAAQ8B,KAAKqI,KAAK,MAAQnK,EAAQ8B,KAC7EqG,GAAWF,EAASnG,GACC,MAAjBmG,EAAQ5G,MAAgBrB,EAAQsJ,MAEhCF,GAAWnB,EAASnG,IAIhC,OAAO5B,EA6OIoK,CA/kCf,SAAsBX,GAAoB,IAAd3J,EAAc,uDAAJ,GAC5BR,EAAUJ,EAAeuK,GACzBzJ,EAASH,EAAWP,EAASQ,GACnC,GAAIP,EAAWD,GACX,MAAMK,EAAQL,EAAS,wBAE3B,OAAOU,EAykCYqK,CADgB,kBAATZ,EA7tB9B,SAAoBa,GAWhB,IAVA,IASI5K,EATEJ,EAAU,IAAIxB,EAAQwM,GACtBtK,EAAS,GACTG,EAAM,CACRG,MAAO,EACP6B,UAAW,EACXI,WAAY,EACZI,MAAO,GAEPpE,EAAK,GAEDe,EAAQX,OAAO,CAGnB,GAFAJ,EAAKe,EAAQd,SACbkB,EAAQ+D,GAAWnE,EAASa,IAWxB,MAAMb,EAAQyE,MAAM,wBATpB/D,EAAOO,KAAKb,GACO,UAAfA,EAAMO,KACNE,EAAIwC,MAAQpE,IAAO4B,EAAIwC,MAAQ,EAAIpE,EAEf,YAAfmB,EAAMO,OACXE,EAAIT,EAAMsD,UAAYtD,EAAMuD,KAAO,GAAK,GAOpD,OAAOjD,EAksBuCuK,CAAWd,GAAQA,EACzB3J,GAAUA,GAElD,MAAOF,GAIH,MAHIA,aAAeZ,GAAgC,kBAATyK,IACtC7J,EAAIb,SAAJ,YAAoB0K,EAApB,aAA6B,IAAI3I,OAAOlB,EAAIxB,KAA5C,MAEEwB,GAmCd,SAAS4K,GAASlL,EAASmL,GACvB,OASJ,SAAiBnL,GACb,IAAMtB,EAAQsB,EAAQlB,IACtB,GAAIkB,EAAQV,IAAI,KAAoBU,EAAQV,IAAI,KAA6B,CAEzE,IAAI8E,EADJpE,EAAQtB,MAAQsB,EAAQlB,IAExB,IAAI+C,EAAO,GAUX,GATI7B,EAAQqE,SAASrG,IAEjBoG,EAAQE,OAAOtE,EAAQuE,WACvB1C,EAAO7B,EAAQV,IAAI,IAAkB8L,GAAqBpL,GAAW,IAEhE9B,EAAU8B,EAAQd,UAEvB2C,EAAOuJ,GAAqBpL,IAE5BA,EAAQV,IAAI,KACZ,MAAO,CACHqB,KAAM,QACNyD,MAAAA,EAAOvC,KAAAA,EACPnD,MAAAA,EACAC,IAAKqB,EAAQlB,KAGrB,MAAMkB,EAAQyE,MAAM,eAIxBzE,EAAQlB,IAAMJ,EApCP2M,CAAQrL,IAyGnB,SAAqBA,GACjB,IAAMtB,EAAQsB,EAAQlB,IACtB,GAkJJ,SAAuBiH,GACnB,IAAMrH,EAAQqH,EAAOjH,IACrBiH,EAAOzG,IAAI,IACX,IAAMgM,EAAgBvF,EAAOjH,IACvByM,EAAaxF,EAAO1B,SAASrG,GAC7BwN,EAAUzF,EAAOjH,IACvB,GAAIiH,EAAOzG,IAAI,IAAe,CAG1B,IAAMmM,EAAW1F,EAAO1B,SAASrG,GAC5BuN,GAAeE,IAEhB1F,EAAOjH,IAAM0M,GAIjBzF,EAAOjH,MAAQwM,IACfvF,EAAOjH,IAAMJ,GAEjB,OAAOqH,EAAOjH,MAAQJ,EArKlBgN,CAAc1L,GAAU,CACxBA,EAAQtB,MAAQA,EAChB,IAAMiN,EAAW3L,EAAQuE,UAIzB,OAFAvE,EAAQtB,MAAQsB,EAAQlB,IACxBkB,EAAQV,IAAI,KAAqBU,EAAQqE,SAASjG,GAC3C,CACHuC,KAAM,cACNoB,MAAOuC,OAAOqH,GACdA,SAAAA,EACAC,KAAM5L,EAAQuE,UACd7F,MAAAA,EACAC,IAAKqB,EAAQlB,MAtHd+M,CAAY7L,IA0JvB,SAAoBA,GAMhB,IAAMtB,EAAQsB,EAAQlB,IACtB,GAAIkB,EAAQV,IAAI,IAAgB,CAC5B,IAAMwM,EAAa9L,EAAQlB,IACvBiN,EAAQ,GACRC,EAAQ,GAYZ,GAXIhM,EAAQqE,SAAS4H,KACjBF,EAAQ/L,EAAQR,UAAUsM,EAAY9L,EAAQlB,KAC9CkN,EAAQE,GAAWlM,IAEdA,EAAQV,IAAI,MACjByM,EAAQ,IACRC,EAAQE,GAAWlM,IAAY,KAG/BgM,EAAQE,GAAWlM,GAEnB+L,GAASC,GAAShM,EAAQX,MAAO,CACjC,MAgIZ,SAAoB0C,EAAOiK,GACvB,IAAIG,EAAI,IACJC,EAAI,IACJC,EAAI,IACJC,EAAIhI,OAAgB,MAAT0H,GAA2B,KAAVA,EAAeA,EAAQ,GACvD,GAAc,MAAVjK,EACAuK,EAAI,OAGJ,OAAQvK,EAAMxE,QACV,KAAK,EACD,MACJ,KAAK,EACD4O,EAAIC,EAAIC,EAAItK,EAAQA,EACpB,MACJ,KAAK,EACDoK,EAAIC,EAAIC,EAAItK,EACZ,MACJ,KAAK,EACDoK,EAAIpK,EAAM,GAAKA,EAAM,GACrBqK,EAAIrK,EAAM,GAAKA,EAAM,GACrBsK,EAAItK,EAAM,GAAKA,EAAM,GACrB,MACJ,QAEIoK,GADApK,GAASA,GACClE,MAAM,EAAG,GACnBuO,EAAIrK,EAAMlE,MAAM,EAAG,GACnBwO,EAAItK,EAAMlE,MAAM,EAAG,GAG/B,MAAO,CACHsO,EAAGI,SAASJ,EAAG,IACfC,EAAGG,SAASH,EAAG,IACfC,EAAGE,SAASF,EAAG,IACfC,EAAAA,GAlK2BE,CAAWT,EAAOC,GACzC,MAAO,CACHrL,KAAM,aACNwL,EAHJ,EAAQA,EAGDC,EAHP,EAAWA,EAGDC,EAHV,EAAcA,EAGDC,EAHb,EAAiBA,EAIbG,IAAKzM,EAAQR,UAAUd,EAAQ,EAAGsB,EAAQlB,KAC1CJ,MAAAA,EACAC,IAAKqB,EAAQlB,KAKjB,OAAO4N,GAAc1M,EAAStB,GAGtCsB,EAAQlB,IAAMJ,EA9LPiO,CAAW3M,IA4HtB,SAAqBA,GACjB,IAAMf,EAAKe,EAAQd,OACbR,EAAQsB,EAAQlB,IAClB8N,GAAW,EACf,GAAIrO,EAAUU,GAAK,CAEf,IADAe,EAAQlB,OACAkB,EAAQX,OAAO,CAEnB,GAAIW,EAAQV,IAAIL,GAAK,CACjB2N,GAAW,EACX,MAGA5M,EAAQlB,MAIhB,OADAkB,EAAQtB,MAAQA,EACT,CACHiC,KAAM,cACNoB,MAAO/B,EAAQR,UAAUd,EAAQ,EAAGsB,EAAQlB,KAAO8N,EAAW,EAAI,IAClEvJ,MAAc,KAAPpE,EAA8B,SAAW,SAChDP,MAAAA,EACAC,IAAKqB,EAAQlB,MAjJd+N,CAAY7M,IA6NvB,SAAiBA,GACb,IAAMf,EAAKe,EAAQd,OACnB,GAuEJ,SAAmBjB,GACf,OAAgB,KAATA,GAA+C,KAATA,EAxEzC6O,CAAU7N,GACV,MAAO,CACH0B,KAAM,UACNgD,KAAa,KAAP1E,EACNP,MAAOsB,EAAQlB,MACfH,IAAKqB,EAAQlB,KAnOdiO,CAAQ/M,IACR+D,GAAS/D,IA8MpB,SAAoBA,GAChB,IAAMtB,EAAQsB,EAAQlB,IACtB,GAAIkB,EAAQqE,SAAShG,GACjB,MAAO,CACHsC,KAAM,aACNjC,MAAAA,EACAC,IAAKqB,EAAQlB,KAnNdkO,CAAWhN,IAkEtB,SAAmBA,EAASmL,GACxB,IAAMzM,EAAQsB,EAAQlB,IAClBkB,EAAQV,IAAI2N,IAIZjN,EAAQqE,SAAS3F,EAAQwO,GAAYC,IAEhCnN,EAAQV,IAAIlB,GACjB4B,EAAQqE,SAAS8G,EAAQgC,GAAYD,KAIrClN,EAAQV,IAAI,IACZU,EAAQqE,SAAS8I,KAErB,GAAIzO,IAAUsB,EAAQlB,IAElB,OADAkB,EAAQtB,MAAQA,EACTgO,GAAc1M,EAASA,EAAQtB,MAAQA,GAnF3C0O,CAAUpN,EAASmL,GAkC9B,SAASC,GAAqBrF,GAC1B,IAAMjF,EAAQ,GAEd,IADAiF,EAAOrH,MAAQqH,EAAOjH,KACdiH,EAAO1G,OACX,GAAI0G,EAAOzG,IAAI,KACXwB,EAAMG,KAAK8E,EAAOjH,UAEjB,GAAIiH,EAAOzG,IAAI,KAA8B,CAC9C,IAAKwB,EAAMvD,OAAQ,CACfwI,EAAOjH,MACP,MAEJgC,EAAMO,WAGN0E,EAAOjH,MAGf,GAAIgC,EAAMvD,OAEN,MADAwI,EAAOjH,IAAMgC,EAAMO,MACb0E,EAAOtB,MAAP,eAEV,OAAOsB,EAAOxB,UA8BlB,SAASmI,GAAc1M,GAAmD,IAA1CtB,EAA0C,uDAAlCsB,EAAQtB,MAAOC,EAAmB,uDAAbqB,EAAQlB,IACjE,MAAO,CACH6B,KAAM,UACNoB,MAAO/B,EAAQR,UAAUd,EAAOC,GAChCD,MAAAA,EACAC,IAAAA,GAmGR,SAASuN,GAAWlM,GAChB,IAAMtB,EAAQsB,EAAQlB,IACtB,OAAIkB,EAAQV,IAAI,KACZU,EAAQtB,MAAQA,EACZsB,EAAQqE,SAASrG,GACVgC,EAAQuE,UAEZ,KAEJ,GAgCX,SAASR,GAAS/D,GACd,IAyCkBf,EAzCZyG,GA0CS,MADGzG,EAzCMe,EAAQd,QA0CG,IACpB,KAAPD,GAAwB,MACjB,KAAPA,GAAyB,KAClB,KAAPA,GAAyB,KAClB,KAAPA,GAAwB,UACzB,EA9CP,GAAIyG,EACA,MAAO,CACH/E,KAAM,WACNoD,SAAU2B,EACVhH,MAAOsB,EAAQlB,MACfH,IAAKqB,EAAQlB,KA6BzB,SAASmO,GAAchP,GACnB,OAAgB,KAATA,GAAiC,KAATA,EAgBnC,SAASgO,GAAMhO,GACX,OAAOD,EAAWC,IAASC,EAAUD,EAAM,GAAI,IAEnD,SAASiP,GAAUjP,GACf,OAAOE,EAAmBF,IAAkB,KAATA,EAKvC,SAASkP,GAAUlP,GACf,OAAOG,EAAYH,IAAkB,KAATA,GAAsC,KAATA,EA8C7D,SAASoP,GAAuBjN,GAC5B,MAAsB,eAAfA,EAAMO,MAAyC,gBAAfP,EAAMO,OAA2BP,EAAMwL,KAUlF,SAAS0B,GAAYtN,EAASH,GAG1B,IAFA,IAmBU8J,EAnBNjL,EAAQ,EACRC,EAAM,EACHkB,EAAOtC,QAAQ,CAClB,IAAM6C,GAgBAuJ,EAhBa9J,GAiBZ8J,EAAIpM,OAAS,GAhBpB,GAAmB,YAAf6C,EAAMO,MAAqC,gBAAfP,EAAMO,KAQlC,MAPAjC,EAAQ0B,EAAM1B,MACTC,IACDA,EAAMyB,EAAMzB,KAEhBkB,EAAOwB,MAMX3C,IAAUC,GACVkB,EAAOoB,KAAKyL,GAAc1M,EAAStB,EAAOC,IAOlD,SAAS4O,GAAa1N,GAClB,MAAO,CACHA,OAAAA,EACAnB,MAAO,EACPI,IAAK,EACLgB,KAAMD,EAAOtC,QAGrB,SAASiQ,GAAOxN,GACZ,OAAOA,EAAQH,OAAOG,EAAQlB,KAElC,SAAS2O,GAASzN,GACd,OAAOA,EAAQlB,IAAMkB,EAAQF,KAEjC,SAAS4N,GAAU1N,EAASG,GACxB,QAAIA,EAAKqN,GAAOxN,MACZA,EAAQlB,OACD,GAIf,SAAS2F,GAAMzE,EAASP,GAAkC,IAAzBW,EAAyB,uDAAjBoN,GAAOxN,GACxCI,GAAwB,MAAfA,EAAM1B,QACfe,GAAW,OAAJ,OAAWW,EAAM1B,QAE5B,IAAM4B,EAAM,IAAIX,MAAMF,GAEtB,OADAa,EAAG,IAAUF,GAASA,EAAM1B,MACrB4B,EAoBX,SAASqN,GAAgB3N,EAASQ,GAC9B,IAAIqB,EAEA+L,EADAC,GAAY,EAEV9L,EAAQ,GACR3B,EAAQoN,GAAOxN,GACf8N,IAActN,EAAQuB,MAW5B,IAVK+L,IAAaC,GAAY3N,IAoHlC,SAAyBJ,GACrB,IAAMgO,EAAKhO,EAAQH,OAAOG,EAAQlB,KAC5BmP,EAAKjO,EAAQH,OAAOG,EAAQlB,IAAM,GACxC,OAAOkP,GAAMC,GAAMF,GAAYC,IAAmB,YAAZC,EAAGtN,KAvHAuN,CAAgBlO,KACrDA,EAAQlB,MACR+C,EAAOzB,EAAM2B,MAEb2L,GAAU1N,EAASmO,KAGnBL,GACAJ,GAAU1N,EAASoO,IAEhBX,GAASzN,IACZ,GAAI0N,GAAU1N,EAASqO,IACnBR,GAAY,OAEX,GAAID,EAAgBU,GAAatO,EAAS8N,GAC3C/L,EAAMd,KAAK2M,QAEV,IAAKF,GAAU1N,EAASuO,IACzB,MAGR,GAAI1M,GAAQE,EAAMxE,QAAUsQ,EACxB,MAAO,CAAEhM,KAAAA,EAAME,MAAAA,EAAO8L,UAAAA,GAM9B,SAASS,GAAatO,EAASwO,GAI3B,IAHA,IACIpO,EACAqO,EAFE/N,EAAS,GAGR+M,GAASzN,IAEZ,GAAI0O,GADJtO,EAAQoN,GAAOxN,IAEXA,EAAQlB,MACJiP,GAAY3N,KAAWqO,EAAOE,GAAiB3O,IAC/CU,EAAOO,KAAK,CACRN,KAAM,eACNkB,KAAMzB,EAAM2B,MACZzE,UAAWmR,IAIf/N,EAAOO,KAAKb,OAGf,MAAI+N,GAAiB/N,IAAWoO,GAAcJ,GAAehO,IAI9D,MAHAJ,EAAQlB,MAMhB,OAAO4B,EAAOnD,OACR,CAAEoD,KAAM,WAAYoB,MAAOrB,QAC3B,EAEV,SAASiO,GAAiB3O,GACtB,IAAMtB,EAAQsB,EAAQlB,IACtB,GAAI4O,GAAU1N,EAAS4O,IAAkB,CAGrC,IAFA,IACI7M,EADE0M,EAAO,GAENhB,GAASzN,KAAa0N,GAAU1N,EAAS6O,KAC5C,GAAI9M,EAAQuM,GAAatO,GAAS,GAC9ByO,EAAKxN,KAAKc,QAET,IAAK2L,GAAU1N,EAASoO,MAAoBV,GAAU1N,EAAS8O,IAChE,MAAMrK,GAAMzE,EAAS,oBAI7B,OADAA,EAAQtB,MAAQA,EACT+P,GAGf,SAASV,GAAY3N,GACjB,OAAOA,GAAwB,YAAfA,EAAMO,KAE1B,SAASoO,GAAY3O,EAAOuD,GACxB,OAAOvD,GAAwB,YAAfA,EAAMO,OAA+B,MAARgD,GAAgBvD,EAAMuD,OAASA,GAEhF,SAASiL,GAAgBxO,GACrB,OAAO2O,GAAY3O,GAAO,GAE9B,SAASyO,GAAiBzO,GACtB,OAAO2O,GAAY3O,GAAO,GAE9B,SAASgO,GAAehO,GACpB,OAAOA,GAAwB,eAAfA,EAAMO,KAE1B,SAASqO,GAAW5O,EAAO2D,GACvB,OAAO3D,GAAwB,aAAfA,EAAMO,QAAyBoD,GAAY3D,EAAM2D,WAAaA,GAElF,SAASkL,GAAkB7O,GACvB,OAAO4O,GAAW5O,EAAO,KAE7B,SAAS0O,GAAoB1O,GACzB,OAAO4O,GAAW5O,EAAO,KAE7B,SAASmO,GAAoBnO,GACzB,OAAO0O,GAAoB1O,GAE/B,SAASiO,GAAYjO,GACjB,OAAO4O,GAAW5O,EAAO,KAE7B,SAASsO,GAAQtO,GACb,MAAsB,gBAAfA,EAAMO,MACS,eAAfP,EAAMO,MACS,gBAAfP,EAAMO,MACS,YAAfP,EAAMO,MACS,UAAfP,EAAMO,KAEjB,SAASwN,GAAiB/N,GACtB,OAAO4O,GAAW5O,EAAO,MAClB4O,GAAW5O,EAAO,KAW7B,SAAS8O,GAAQ/E,EAAM3J,GACnB,IACI,IAAMX,EAAyB,kBAATsK,EAnlB9B,SAAkBA,EAAMuE,GAKpB,IAJA,IACItO,EADAqD,EAAW,EAETzD,EAAU,IAAIxB,EAAQ2L,GACtBtK,EAAS,IACPG,EAAQX,OAAO,CAEnB,KADAe,EAAQ8K,GAASlL,EAAsB,IAAbyD,IAAmBiL,IAEzC,MAAM1O,EAAQyE,MAAM,wBAExB,GAAmB,YAAfrE,EAAMO,QACD8C,GAAYrD,EAAMuD,MACnB2J,GAAYtN,EAASH,IAEzB4D,GAAYrD,EAAMuD,KAAO,GAAK,GACf,GACX,MAAM3D,EAAQyE,MAAM,qBAAsBrE,EAAM1B,OAGxDmB,EAAOoB,KAAKb,GAGRiN,GAAuBjN,KAAWA,EAAQ2D,GAAS/D,KACnDH,EAAOoB,KAAKb,GAGpB,OAAOP,EAyjBuCsP,CAAShF,EAAM3J,GAAWA,EAAQuB,OAASoI,EACrF,OAxJR,SAAgBtK,GAIZ,IAJkC,IAG9BuP,EAHgB5O,EAAc,uDAAJ,GACxBR,EAAUuN,GAAa1N,GACvBa,EAAS,GAER+M,GAASzN,IACZ,GAAIoP,EAAWzB,GAAgB3N,EAASQ,GACpCE,EAAOO,KAAKmO,QAEX,IAAK1B,GAAU1N,EAASiP,IACzB,MAAMxK,GAAMzE,EAAS,oBAG7B,OAAOU,EA4II2O,CAAOxP,EAAQW,GAE1B,MAAOF,GAIH,MAHIA,aAAeZ,GAAgC,kBAATyK,IACtC7J,EAAIb,SAAJ,YAAoB0K,EAApB,aAA6B,IAAI3I,OAAOlB,EAAIxB,KAA5C,MAEEwB,GAwCd,SAASgP,GAAWC,EAAMnQ,EAAMoQ,GAC5B,GAAID,GAAQnQ,EAAM,CACVmQ,EAAKhS,QAAUiS,GACfC,GAAOF,EAAMC,GAFH,gBAIEpQ,GAJF,IAId,2BAAsB,CAClBqQ,GAAOF,EADW,UAJR,8BAOd,OAAOA,EAEX,IAAM7O,EAAS6O,GAAQnQ,EACvB,OAAOsB,GAAUA,EAAO7C,QAK5B,SAAS6R,GAAkBC,EAAMC,EAAKC,GAelC,OAdAF,EAAK9N,KAAO+N,EAAI/N,KACXgO,EAAOrP,QAAQ,8BAChBmP,EAAK5N,MAAQ6N,EAAI7N,OAGhB4N,EAAKrG,UACNqG,EAAKrG,QAAUsG,EAAItG,SAElBqG,EAAKjG,UACNiG,EAAKjG,QAAUkG,EAAIlG,SAEA,eAAnBiG,EAAKnG,YACLmG,EAAKnG,UAAYoG,EAAIpG,WAElBmG,EAEX,SAASF,GAAO5P,EAAQkC,GACpB,IAAMqF,EAASvH,EAAOtC,OAAS,EACD,kBAAnBsC,EAAOuH,IAAyC,kBAAVrF,EAC7ClC,EAAOuH,IAAWrF,EAGlBlC,EAAOoB,KAAKc,GAuBpB,SAAS+N,GAAYrP,GAEjB,IADA,IAAIqE,EACGrE,EAAKoI,SAAStL,QACjBuH,EAASrE,EACTA,EAAOA,EAAKoI,SAASpI,EAAKoI,SAAStL,OAAS,GAEhD,MAAO,CAAEuH,OAAAA,EAAQrE,KAAAA,GAErB,SAASsP,GAAOtP,GACZ,MAAqB,qBAAdA,EAAKE,KA0ChB,SAASqP,GAAYvP,EAAMwP,EAASJ,GAChC,IADwC,EACpChH,EAAW,GADyB,UAEpBpI,EAAKoI,UAFe,IAExC,2BAAmC,KAAxB5C,EAAwB,QACzBiK,EAAWD,EAAQhK,GACzB,GAAIiK,EAAU,CACVrH,EAAWA,EAAS9K,OAAOmS,EAASrH,UACpC,IAAMJ,EAAUqH,GAAYI,GACxBH,GAAOtH,EAAQhI,QACfgI,EAAQhI,KAAKoI,SAAWJ,EAAQhI,KAAKoI,SAAS9K,OAAOiS,GAAY/J,EAAOgK,UAI5EpH,EAAS5H,KAAKgF,GACdA,EAAM4C,SAAWmH,GAAY/J,EAAOgK,IAbJ,8BAgBxC,OAAOxP,EAAKoI,SAAWA,EAK3B,SAASsH,GAAW/S,EAAMD,GAClBC,EAAK4L,cACL7L,EAAG6L,aAAc,GAEH,MAAd5L,EAAK2E,QACL5E,EAAG4E,MAAQ3E,EAAK2E,OAEhB3E,EAAKoE,SACLrE,EAAGqE,OAASpE,EAAKoE,QAIzB,SAAS4O,GAAmB5P,GAAoB,IAAX6P,EAAW,uDAAH,EACzC,MAAO,CACH7P,QAAAA,EACAuB,MAAO,GACPsO,MAAAA,EACAC,OAAQ,EACRC,KAAM,EACNC,OAAQ,GAMhB,SAASvP,GAAK8E,EAAQzD,GAElBmO,GAAM1K,GAAQ2K,EADM3K,EAAOvF,QAAQ,gBACT8B,EAAMyD,EAAOuK,OAAQvK,EAAOwK,KAAMxK,EAAOyK,SAKvE,SAASG,GAAW5K,EAAQhE,GAIxB,IADA,IAAM6O,EAwFV,SAAsBtO,GAClB,OAAOA,EAAKuO,MAAM,eAzFJC,CAAa/O,GAClBtE,EAAI,EAAGsT,EAAKH,EAAMrT,OAAS,EAAGE,GAAKsT,EAAItT,IAC5CwD,GAAK8E,EAAQ6K,EAAMnT,IACfA,IAAMsT,GACNC,GAAYjL,GAAQ,GAOhC,SAASiL,GAAYjL,EAAQkL,GACzB,IAAMC,EAAanL,EAAOvF,QAAQ,qBAElCS,GAAK8E,EADWA,EAAOvF,QAAQ,kBACR0Q,GACvBnL,EAAOwK,OACPxK,EAAOyK,OAASU,EAAW3T,OACvB0T,GAOR,SAAoBlL,GAA6B,IAArBjG,EAAqB,uDAAdiG,EAAOsK,MAChCY,EAASlL,EAAOvF,QAAQ,iBAC9BS,GAAK8E,EAAQkL,EAAOzP,OAAO8F,KAAKC,IAAIzH,EAAM,KARtCqR,CAAWpL,GAAmB,IAAXkL,EAAkBlL,EAAOsK,MAAQY,GAa5D,SAASG,GAAUrL,EAAQ3B,EAAOiN,GAG9BZ,GAAM1K,GAAQuL,EAFAvL,EAAOvF,QAAQ,iBAET4D,EAAOiN,EAAatL,EAAOuK,OAAQvK,EAAOwK,KAAMxK,EAAOyK,SAW/E,SAASe,GAAS1P,EAAMgO,GACpB,OAAO2B,GAAQ3P,EAAMgO,EAAOrP,QAAQ,yBAKxC,SAASiR,GAAU9P,EAAMkO,EAAQhM,GAC7B,MAAuB,eAAnBlC,EAAK6H,UACE3F,EAAS,IAAM,IAE0B,WAA7CgM,EAAOrP,QAAQ,0BAAyC,IAAO,IAK1E,SAASkR,GAAmB/P,EAAMkO,GAC9B,OAAOlO,EAAK+H,SACLmG,EAAOrP,QAAQ,4BAA4BmR,UAAUhQ,EAAKE,MAAQ,IAAI+P,eAgBjF,SAASC,GAASpR,EAAMoP,GACpB,MAAoB,kBAATpP,EACAoP,EAAOrP,QAAQsR,eAAeH,SAASlR,EAAKmR,eAGhDnR,EAAKoB,KAAOgQ,GAASpR,EAAKoB,KAAMgO,GAAU/L,QAAQrD,EAAKsB,QAAUtB,EAAKqB,YAWjF,SAAS2O,GAAM1K,EAAQzD,GACnByD,EAAOhE,OAASO,EAChByD,EAAOuK,QAAUhO,EAAK/E,OACtBwI,EAAOyK,QAAUlO,EAAK/E,OAE1B,SAASiU,GAAQ/S,EAAKkC,GAClB,OAAIA,EACgB,UAATA,EAAmBlC,EAAIsT,cAAgBtT,EAAImT,cAE/CnT,EAGX,IAAMuT,GAAa,CACfC,EAAG,OACHC,GAAI,KACJC,GAAI,KACJC,MAAO,KACPC,GAAI,KACJC,MAAO,KACPC,MAAO,KACPC,MAAO,KACPC,SAAU,MACVC,OAAQ,SACRC,SAAU,SACVC,MAAO,SACPC,MAAO,SACPC,OAAQ,QACRC,IAAK,QAOT,SAASC,GAAmBvS,EAAMwS,EAAWpD,GACzC,IAAM/K,EAYV,SAA0BmO,GACtB,IAAK,IAAIxV,EAAIwV,EAAU1V,OAAS,EAAGE,GAAK,EAAGA,IAAK,CAC5C,IAAMmE,EAAOqR,EAAUxV,GACvB,GAAIsS,GAAOnO,GACP,OAAOA,GAhBAsR,CAAiBD,GAC1BE,EAActD,EAAOnM,QAAUmM,EAAOnM,QAAQ7B,KAAO,GACrDuR,IAAuBtO,EAASA,EAAOjD,KAAOsR,IAKrC,IAAIvB,cAJnBnR,EAAKoB,KAAOmQ,GAAWoB,KACfvB,GAASuB,EAAYvD,GAAU,OAAS,OAiBpD,IAgGMwD,GAAe,CAAEC,GA/Dd,CACR,OAAU,CAAC,4EAAiB,eAAM,+DAAc,uCAAU,8CAAY,6CAAW,gEAAe,iCAAS,uCAAU,wCACnH,MAAS,CAAC,iCAAS,wCAAW,qBAAO,yDAAa,iCAAS,oDAAa,yDACvE,mDAAY,yDAAa,uCAAU,yDAAa,uCAAU,2BAC1D,uCAAU,wCAAW,2EAAgB,eAAK,iCAAS,2EACnD,yDAAa,qBAAO,yGAAqB,uCAAU,6CAAW,mDAC9D,qEAAe,mDAAY,iCAAS,qBAAO,2BAAQ,+DACnD,+DAAc,eAAM,iCAAS,uCAAU,qBAAO,6CAAW,mDACzD,mDAAY,mGAAoB,iCAAS,iCAAS,6CAAW,2BAC7D,yDAAa,6CAAU,6CAAW,uCAAU,iCAAS,QAAS,QAC9D,uCAAU,iCAAS,6CAAW,qBAAO,+DAAc,6CAAW,6CAC9D,2EAAgB,SAAK,2BAAQ,6CAAW,iCAAS,uCAAU,6CAC3D,mDAAY,uCAAU,6CAAW,eAAM,iCAAS,qBAAO,iCACvD,2BAAQ,iCAAS,eAAM,uCAAU,2BAAQ,iCAAS,yDAAa,2BAC/D,yDAAa,6CAAW,eAAM,2BAAQ,mDAAY,uCAClD,qEAAe,uCAAU,6CAAW,yDAAa,qBAAO,uCACxD,yDAAa,uCAAU,iCAAS,uCAAU,uCAAU,6CAAW,uCAC/D,yDAAa,yDAAa,6CAAW,6CAAW,2EAAgB,uCAChE,mDAAY,mDAAY,2EAAgB,uCAAU,mDAAY,qBAC9D,2BAAQ,yDAAa,2BAAQ,2BAAQ,uCAAU,mDAAY,mDAC3D,qBAAO,2EAAiB,2BAAQ,qBAAO,uFAAkB,yDACzD,qBAAO,2EAAgB,qBAAO,2BAAQ,mDAAY,qBAAO,yDACzD,qEAAe,eAAM,iCAAS,2BAAQ,+DAAc,uCAAU,2EAC9D,mDAAY,qBAAO,yDAAa,2BAAQ,2BAAQ,uCAAU,qBAC1D,2EAAgB,mDAAY,qEAAe,yDAAa,6CACxD,yDAAa,uCAAU,iCAAS,+DAAc,2BAAQ,yDACtD,6CAAW,2EAAgB,iCAAS,iCAAS,iCAAS,mDACtD,2BAAQ,+DAAc,eAAM,iCAAS,qBAAO,eAAM,qBAAO,uBAoChCC,GAjClB,CACR,OAAU,CAAC,QAAS,MAAO,QAAS,SAAO,KAAM,QAAS,QAAS,MACnE,MAAS,CAAC,YAAa,cAAe,cAAe,UAAW,UAC/D,WAAY,QAAS,UAAW,YAAa,QAAS,WAAS,aAAc,eAC7E,OAAQ,eAAgB,OAAQ,OAAQ,YAAa,OAAQ,SAC7D,SAAU,KAAM,OAAQ,WAAY,YAAU,eAC9C,YAAa,QAAS,YAAa,gBAAc,OAAQ,WAAY,SACrE,UAAQ,SAAU,OAAQ,QAAS,UAAW,OAAQ,YACtD,QAAS,SAAU,aAAW,QAAS,MAAO,KAAM,IAAK,aACzD,eAAgB,WAAY,WAAY,cAAY,YAAa,WACjE,WAAY,WAAY,OAAQ,WAAY,kBAAgB,QAC5D,iBAAkB,aAAc,aAAc,aAAW,YACzD,UAAW,YAAU,YAAU,YAAa,QAAS,YACrD,UAAW,QAAS,eAAgB,QAAS,aAAc,SAC3D,MAAO,QAAS,WAAY,QAAS,aAAc,QAAS,UAC5D,cAAe,cAAe,QAAS,UAAW,cAAe,YACjE,UAAW,aAAc,QAAS,WAAY,aAAW,SACzD,QAAS,eAAa,YAAU,YAAU,gBAAc,UACxD,UAAW,SAAU,YAAa,cAAe,WAAY,YAC7D,eAAa,gBAAc,OAAQ,WAAY,QAAS,QAAS,IACjE,UAAW,YAAa,WAAY,OAAQ,gBAAc,SAAU,WACpE,iBAAkB,WAAY,aAAc,OAAQ,gBACpD,eAAgB,QAAS,IAAK,WAAY,QAAS,QAAS,SAC5D,YAAU,aAAc,OAAQ,YAAa,SAAU,KAAM,cAAY,MAAO,MAChF,eAAa,aAAW,SAAU,YAAa,QAAS,WACxD,UAAW,YAAa,QAAS,WAAY,YAAU,eACvD,SAAU,cAAY,SAAU,aAAc,YAC9C,MAAO,aAAc,UAAW,WAAY,UAAW,cACvD,aAAc,UAAW,OAAQ,aAAc,OAAQ,IAAK,eAC5D,cAAY,QAAS,OAAQ,UAAW,aAAc,UAAW,OACjE,SAAU,aAGmBC,MAhGnB,CACX,OAAU,CAAC,QAAS,QAAS,QAAS,MAAO,OAAQ,cAAe,cAAe,QACnF,MAAS,CAAC,iBAAkB,cAAe,eAAgB,UAAW,UACrE,OAAQ,OAAQ,MAAO,QAAS,MAAO,MAAO,WAAY,YAC1D,OAAQ,cAAe,QAAS,MAAO,WAAY,MAAO,WAC1D,SAAU,MAAO,OAAQ,UAAW,UAAW,cAC/C,UAAW,QAAS,QAAS,WAAY,QAAS,OAAQ,QAC1D,OAAQ,QAAS,SAAU,WAAY,QAAS,OAAQ,QACxD,QAAS,QAAS,QAAS,OAAQ,MAAO,KAAM,KAAM,eACtD,UAAW,YAAa,UAAW,YAAa,WAAY,UAC5D,UAAW,UAAW,OAAQ,YAAa,cAAe,MAC1D,iBAAkB,WAAY,WAAY,SAAU,WACpD,WAAY,UAAW,OAAQ,cAAe,OAAQ,WACtD,YAAa,MAAO,aAAc,aAAc,SAAU,OAC1D,MAAO,UAAW,QAAS,QAAS,SAAU,OAAQ,QACtD,aAAc,WAAY,YAAa,QAAS,UAAW,SAC3D,UAAW,cAAe,QAAS,YAAa,QAAS,OACzD,QAAS,WAAY,UAAW,OAAQ,aAAc,UACtD,YAAa,QAAS,UAAW,OAAQ,aAAc,YACvD,QAAS,aAAc,QAAS,QAAS,UAAW,aAAc,KAClE,OAAQ,OAAQ,WAAY,OAAQ,aAAc,QAAS,WAC3D,aAAc,QAAS,eAAgB,MAAO,aAC9C,YAAa,YAAa,KAAM,QAAS,QAAS,QAAS,OAC3D,KAAM,KAAM,OAAQ,QAAS,UAAW,KAAM,KAAM,KAAM,OAC1D,gBAAiB,UAAW,OAAQ,SAAU,MAAO,YACrD,SAAU,cAAe,SAAU,aAAc,OAAQ,YACzD,aAAc,UAAW,cAAe,aAAc,UACtD,QAAS,QAAS,SAAU,aAAc,WAAY,SACtD,aAAc,MAAO,OAAQ,WAAY,QAAS,IAAK,YACvD,MAAO,QAAS,SAAU,UAAW,WAAY,QAAS,SAC1D,SAAU,cAmENC,GAAU,+BAmBhB,SAASC,GAAKtW,EAAMD,GAChB,OAAOmK,KAAKqM,MAAMrM,KAAKsM,UAAYzW,EAAKC,GAAQA,GAEpD,SAASyW,GAAOlK,EAAK3E,GAIjB,IAHA,IAAM8O,EAAMnK,EAAIpM,OACVwW,EAAazM,KAAK0M,IAAIF,EAAK9O,GAC3BtE,EAAS,GACRA,EAAOnD,OAASwW,GAAY,CAC/B,IAAMtV,EAAMkL,EAAI+J,GAAK,EAAGI,IACnBpT,EAAOiR,SAASlT,IACjBiC,EAAOO,KAAKxC,GAGpB,OAAOiC,EAKX,SAASuT,GAASC,EAAOvV,GAMzB,IAAoBwV,EATJC,EAOZ,OAHIF,EAAM3W,SACN2W,EAAQ,EAIIC,EAJQD,EAAM,GAKvBC,EAAK,GAAGpC,cAAgBoC,EAAKtW,MAAM,KALPE,OAAOmW,EAAMrW,MAAM,KAE/CqW,EAAMvJ,KAAK,MAAQhM,IAPdyV,EAO4B,SAN7BV,GAAK,EAAGU,EAAI7W,OAAS,KAepC,SAAS8W,GAAaH,GAClB,GAAIA,EAAM3W,OAAS,EACf,OAAO2W,EAGX,IAAMJ,GADNI,EAAQA,EAAMrW,SACIN,OACZ+W,EAAW,KACbC,EAAc,EAEdA,EADAT,EAAM,GAAKA,GAAO,EACJJ,GAAK,EAAG,GAEjBI,EAAM,GAAKA,GAAO,GACTJ,GAAK,EAAG,GAGRA,GAAK,EAAG,GAE1B,IAAK,IAAW5U,EAAPrB,EAAI,EAAQA,EAAI8W,EAAa9W,IAClCqB,EAAM4U,GAAK,EAAGI,EAAM,GACfQ,EAASnU,KAAK+T,EAAMpV,MACrBoV,EAAMpV,IAAQ,KAGtB,OAAOoV,EAQX,SAASM,GAAUC,EAAMC,EAAWC,GAChC,IAEIT,EAFExT,EAAS,GACXkU,EAAa,EAOjB,IALID,GAAmBF,EAAKI,SAExBD,IADAV,EAAQO,EAAKI,OAAOhX,MAAM,EAAG6W,IACTnX,OACpBmD,EAAOO,KAAKgT,GAASI,GAAaH,GAAQ,OAEvCU,EAAaF,GAEhBE,IADAV,EAAQL,GAAOY,EAAKP,MAAO5M,KAAK0M,IAAIN,GAAK,EAAG,IAAKgB,EAAYE,KACzCrX,OACpBmD,EAAOO,KAAKgT,GAASI,GAAaH,KAEtC,OAAOxT,EAAOiK,KAAK,KAoBvB,SAASmK,GAAOnT,GACM,UAAdA,EAAKE,KACLF,EAAKE,KAAO,YAEO,QAAdF,EAAKE,OACVF,EAAKE,KAAO,WAapB,SAASkT,GAAUpT,GACf,MAAqB,WAAdA,EAAKE,KAMhB,IAAMmT,GAAY,8BACZC,GAAa,+BACbC,GAAmB,SAACC,GAAD,MAAe,YAAYhV,KAAKgV,IACnDC,GAAmB,SAACD,GAAD,MAAe,UAAUhV,KAAKgV,IACvD,SAASE,GAAI5U,EAAMwS,EAAWpD,IAS9B,SAA0BpP,GACtB,IAD4B,EACtB6U,EAAOC,GAAW9U,GAClB+U,EAAa,GAFS,UAGXF,EAAKE,YAHM,IAG5B,2BAAkC,KAAvBC,EAAuB,QAExBC,EAAKD,EAAGE,QAAQ,KAClBD,EAAK,IAAMD,EAAG1L,WAAW,MACzByL,EAAWvU,KAAKwU,EAAG5X,MAAM,EAAG6X,IAC5BF,EAAWvU,KAAKwU,EAAG5X,MAAM6X,KAGzBF,EAAWvU,KAAKwU,IAXI,8BAcxBD,EAAWjY,SACX+X,EAAKE,WAAaA,EAAWnL,OAAOuL,IACpCN,EAAKO,MAAQC,GAAcR,EAAKE,YAChCO,GAAYtV,EAAM6U,EAAKE,WAAW7K,KAAK,OAzB3CqL,CAAiBvV,GA+BrB,SAA6BA,EAAMwS,EAAWpD,GAC1C,IADkD,EAC5CyF,EAAOC,GAAW9U,GAClB+U,EAAa,GACXhV,EAAYqP,EAAZrP,QACFyV,EAAOhD,EAAUpV,MAAM,GAAGE,OAAO0C,GAJW,UAKnC6U,EAAKE,YAL8B,IAKlD,2BAAgC,KAAvBC,EAAuB,QACxBS,EAAS,GACTC,OAAC,EACCC,EAAgBX,GAElBU,EAAIV,EAAGzW,MAAMgW,OACbkB,EAASG,GAAaJ,EAAME,EAAE,GAAG5Y,OAAQsS,EAAOnM,SAAWlD,EAAQ,eAAiB2V,EAAE,GACtFX,EAAWvU,KAAKiV,GAChBT,EAAKA,EAAG5X,MAAMsY,EAAE,GAAG5Y,UAGnB4Y,EAAIV,EAAGzW,MAAMiW,OACRiB,IACDA,EAASG,GAAaJ,EAAME,EAAE,GAAG5Y,QACjCiY,EAAWvU,KAAKiV,IAEpBV,EAAWvU,KAAX,UAAmBiV,GAAnB,OAA4B1V,EAAQ,iBAApC,OAAsD2V,EAAE,KACxDV,EAAKA,EAAG5X,MAAMsY,EAAE,GAAG5Y,SAEnBkY,IAAOW,GAGPZ,EAAWvU,KAAKmV,IA3B0B,8BA8BlD,IAAME,EAAgBd,EAAWnL,OAAOuL,IACpCU,EAAc/Y,QACdwY,GAAYtV,EAAM6V,EAAc3L,KAAK,MA9DzC4L,CAAoB9V,EAAMwS,EAAWpD,GAoEzC,SAAS0F,GAAW9U,GAChB,IAAKA,EAAK+V,KAAM,CACZ,IAAIC,EAAa,GACjB,GAAIhW,EAAKqB,WAAY,iBACErB,EAAKqB,YADP,IACjB,2BAAoC,KAAzBH,EAAyB,QAChC,GAAkB,UAAdA,EAAKE,MAAoBF,EAAKI,MAAO,CACrC0U,EAAaC,GAAe/U,EAAKI,OACjC,QAJS,+BAQrBtB,EAAK+V,KAAOG,GAASF,GAEzB,OAAOhW,EAAK+V,KAEhB,SAASI,GAAsBlT,GAI3B,OAHKA,EAAQ8S,OACT9S,EAAQ8S,KAAOG,GAASjT,EAAQ5B,YAAc4B,EAAQ5B,WAAWoE,OAAS,KAEvExC,EAAQ8S,KAKnB,SAASG,GAASF,GACd,IAAMjB,EAAaiB,EAAaA,EAAW5F,MAAM,OAAS,GAC1D,MAAO,CACH2E,WAAAA,EACAK,MAAOC,GAAcN,IAO7B,SAASa,GAAapD,GAA+B,IAApB4D,EAAoB,uDAAZ,EAAGnT,EAAS,uCAC3CoT,EAAc,EAChBzP,EAAWC,KAAKC,IAAI0L,EAAU1V,OAASsZ,EAAOC,GAClD,EAAG,CACC,IAAMhS,EAASmO,EAAU5L,GACzB,GAAIvC,EAAQ,CACR,IAAMwQ,EAAOC,GAAWzQ,GACxB,GAAIwQ,EAAKO,MACL,OAAOP,EAAKO,aAGfiB,EAAczP,KACvB,GAAI3D,EAAS,CACT,IAAM4R,EAAOsB,GAAsBlT,GACnC,GAAI4R,EAAKO,MACL,OAAOP,EAAKO,MAGpB,MAAO,GAEX,SAASC,GAAcN,GACnB,OAAOvL,GAAKuL,EAAYN,KACjBjL,GAAKuL,EAAYJ,UACjB,EAKX,SAASnL,GAAKuL,EAAYnL,GAAQ,gBACbmL,GADa,IAC9B,2BAA6B,KAAlBC,EAAkB,QACzB,GAAIT,GAAU7U,KAAKsV,IAAOR,GAAW9U,KAAKsV,GACtC,MAEJ,GAAIpL,EAAOoL,GACP,OAAOA,GANe,+BAUlC,SAASM,GAAYtV,EAAMsB,GAAO,gBACXtB,EAAKqB,YADM,IAC9B,2BAAoC,KAAzBH,EAAyB,QAChC,GAAkB,UAAdA,EAAKE,KAAkB,CACvBF,EAAKI,MAAQ,CAACA,GACd,QAJsB,+BAQlC,SAAS2U,GAAe3U,GACpB,IAD2B,EACvBrB,EAAS,GADc,UAEXqB,GAFW,IAE3B,2BAAuB,KAAZgV,EAAY,QACnBrW,GAAuB,kBAANqW,EAAiBA,EAAIA,EAAElV,MAHjB,8BAK3B,OAAOnB,EAEX,SAASkV,GAAYxM,EAAMsM,EAAI/L,GAC3B,QAASP,GAAQO,EAAIgM,QAAQvM,KAAUsM,EAG3C,SAASsB,GAAO7M,EAAM8M,EAASnQ,GAC3B,IAAMoQ,EAAW,SAACrW,EAAKuD,EAAO2D,GAC1B,IAAQjD,EAAoBgC,EAApBhC,OAAQP,EAAYuC,EAAZvC,QAChBuC,EAAMhC,OAASP,EACfuC,EAAMvC,QAAU1D,EAChBoW,EAAQpW,EAAKuD,EAAO2D,EAAOjB,EAAO1H,GAClC0H,EAAMvC,QAAUA,EAChBuC,EAAMhC,OAASA,GAEb1F,EAAO,SAACqB,EAAM2D,EAAO2D,GACvBjB,EAAMmM,UAAUhS,KAAK6F,EAAMvC,SAC3B2S,EAASzW,EAAM2D,EAAO2D,GACtBjB,EAAMmM,UAAU5R,OAEpB8I,EAAKtB,SAASsO,QAAQD,GAE1B,SAASE,GAAgBvH,GACrB,MAAO,CAEHtL,QAAS,KACTO,YAAQ,EACRmO,UAAW,GACXpD,OAAAA,EACAyB,MAAO,EACP+F,IAAKjH,GAAmBP,EAAOrP,UAIvC,IAAM8W,GAAQ,CAAC,CAAE3W,KAAM,QAASyD,MAAO,EAAGvC,KAAM,KAIhD,SAAS0V,GAAU9W,GACf,QAAOA,KAAQA,EAAKoB,OAASpB,EAAKqB,YAMtC,SAAS0V,GAAgB/W,EAAMoP,GAC3B,QAAOpP,GAAOoR,GAASpR,EAAMoP,GAKjC,SAAS4H,GAAQrX,GACb,MAAwB,kBAAVA,GAAqC,UAAfA,EAAMO,KAE9C,SAAS+W,GAAW7X,EAAQiH,GACxB,IAD+B,EACvBuQ,EAAQvQ,EAARuQ,IACJM,GAAgB,EAFW,UAGf9X,GAHe,IAG/B,2BAAwB,KAAbkX,EAAa,QACH,kBAANA,EACPpG,GAAW0G,EAAKN,IAGhB3F,GAAUiG,EAAKvQ,EAAMwK,MAAQyF,EAAE3S,MAAO2S,EAAElV,MACpCkV,EAAE3S,MAAQuT,IACVA,EAAeZ,EAAE3S,SAVE,+BAcT,IAAlBuT,IACA7Q,EAAMwK,OAASqG,EAAe,GA6BtC,SAASC,GAAsBjW,GAG3B,OAAQA,EAAK2H,SAA8B,QAAnB3H,EAAK6H,aAA0B7H,EAAKI,OAASJ,EAAKI,MAAMxE,OAAS,EAW7F,SAASsa,GAASvV,GAMd,IALA,IAEI+O,EAFExR,EAAS,GACTG,EAAU,CAAElB,IAAK,EAAGwD,KAAAA,GAEtBgO,EAAStQ,EAAQlB,IACjBA,EAAMkB,EAAQlB,IACXkB,EAAQlB,IAAMkB,EAAQsC,KAAK/E,QAC9BuB,EAAMkB,EAAQlB,KACVuS,EAAcyG,GAAmB9X,KAC7BsQ,IAAWtQ,EAAQlB,KACnBe,EAAOoB,KAAKqB,EAAKzE,MAAMyS,EAAQxR,IAEnCe,EAAOoB,KAAKoQ,GACZf,EAAStQ,EAAQlB,KAGjBkB,EAAQlB,MAMhB,OAHIwR,IAAWtQ,EAAQlB,KACnBe,EAAOoB,KAAKqB,EAAKzE,MAAMyS,IAEpBzQ,EAKX,SAASiY,GAAmB9X,GACxB,GAAsB,KAAlBd,GAAKc,GAKL,IAJA,IAAMtB,IAAUsB,EAAQlB,IACpBiZ,EAAUrZ,EACVsZ,EAAWtZ,EACXoC,EAAQ,EACLd,EAAQlB,IAAMkB,EAAQsC,KAAK/E,QAAQ,CACtC,IAAMU,EAAOiB,GAAKc,GAClB,GAAIiY,GAAaha,GAAO,CAEpB,IADA8Z,EAAU/X,EAAQlB,IACXoZ,GAAQhZ,GAAKc,KAChBA,EAAQlB,MAEZkZ,EAAWhY,EAAQlB,QAElB,CACD,GAAa,KAATb,EACA6C,SAEC,GAAa,KAAT7C,GACW,MAAV6C,EACF,MAAO,CACHqX,OAAQnY,EAAQsC,KAAKzE,MAAMa,EAAOqZ,GAClCK,MAAOpY,EAAQsC,KAAKzE,MAAMma,EAAUhY,EAAQlB,OAC5C+C,KAAM7B,EAAQsC,KAAKzE,MAAMka,EAASC,IAI9ChY,EAAQlB,QAKxB,SAASI,GAAKc,GAA4B,IAAnBlB,EAAmB,uDAAbkB,EAAQlB,IACjC,OAAOkB,EAAQsC,KAAKvD,WAAWD,GAEnC,SAASmZ,GAAaha,GAClB,OAAOA,GAAQ,IAAMA,GAAQ,GAEjC,SAASia,GAAQja,GACb,OAAOga,GAAaha,IACZA,EAAO,IAAMA,EAAO,IACZ,KAATA,GACS,KAATA,EA+BX,SAASoa,GAAc5X,EAAMqG,GACzB,IAAQwR,EAAYxR,EAAZwR,QACR,IAAKA,EAAQC,UAAYD,EAAQE,UAAY/X,EAAKoB,OAASpB,EAAKqB,WAC5D,OAAO,EAHqB,gBAKbrB,EAAKqB,YALQ,IAKhC,2BAAoC,KAAzBH,EAAyB,QAChC,GAAIA,EAAKE,MAAQyW,EAAQE,QAAQ7G,SAAShQ,EAAKE,MAC3C,OAAO,GAPiB,8BAUhC,OAAO,EAKX,SAAS4W,GAAOhY,EAAMZ,EAAQiH,GAC1B,IADiC,EAC3B4R,EAAQ,GACNrB,EAAQvQ,EAARuQ,IAFyB,UAId5W,EAAKqB,YAJS,IAIjC,2BAAoC,KAAzBH,EAAyB,QAC5BA,EAAKE,MAAQF,EAAKI,QAClB2W,EAAM/W,EAAKE,KAAKkQ,eAAiBpQ,EAAKI,QANb,8CAUblC,GAVa,IAUjC,2BAA4B,KAAjBO,EAAiB,QACH,kBAAVA,EACPuQ,GAAW0G,EAAKjX,GAEXsY,EAAMtY,EAAMyB,QACjB8O,GAAW0G,EAAKjX,EAAM+X,QACtBT,GAAWgB,EAAMtY,EAAMyB,MAAOiF,GAC9B6J,GAAW0G,EAAKjX,EAAMgY,SAjBG,+BAsBrC,IAAMO,GAAe,oBACrB,SAASC,GAAKzO,EAAM0F,GAChB,IAAM/I,EAAQsQ,GAAgBvH,GAG9B,OAFA/I,EAAMwR,QApEV,SAA4BzI,GACxB,IAAQrP,EAAYqP,EAAZrP,QACR,MAAO,CACH+X,QAAS/X,EAAQ,mBACjBgY,QAAShY,EAAQ,mBACjB2X,OAAQ3X,EAAQ,kBAAoBqX,GAASrX,EAAQ,wBAAqB,EAC1E4X,MAAO5X,EAAQ,iBAAmBqX,GAASrX,EAAQ,uBAAoB,GA8D3DqY,CAAmBhJ,GACnCmH,GAAO7M,EAAM2O,GAAShS,GACfA,EAAMuQ,IAAItV,MASrB,SAAS+W,GAAQrY,EAAM2D,EAAO2D,EAAOjB,EAAO1H,GACxC,IAAQiY,EAAgBvQ,EAAhBuQ,IAAKxH,EAAW/I,EAAX+I,OACPkJ,EAASC,GAAavY,EAAM2D,EAAO2D,EAAOjB,GAE1CuJ,EA8KV,SAAmBvJ,GACf,IAAQ+I,EAAmB/I,EAAnB+I,OAAQ/K,EAAWgC,EAAXhC,OAChB,IAAKA,GAAUyS,GAAUzS,IAAYA,EAAOjD,MAAQgO,EAAOrP,QAAQ,qBAAqBmR,SAAS7M,EAAOjD,MACpG,OAAO,EAEX,OAAO,EAnLOoX,CAAUnS,GAGxB,GAFAuQ,EAAIhH,OAASA,EACb0I,GAAU/H,GAAYqG,GAAK,GACvB5W,EAAKoB,KAAM,CACX,IAAMA,EA5wBd,SAAiBA,EAAMgO,GACnB,OAAO2B,GAAQ3P,EAAMgO,EAAOrP,QAAQ,mBA2wBnB0Y,CAAQzY,EAAKoB,KAAMgO,GAGhC,GA9ER,SAA2BpP,EAAMqG,GACzBuR,GAAc5X,EAAMqG,IAAUA,EAAMwR,QAAQH,QAC5CM,GAAOhY,EAAMqG,EAAMwR,QAAQH,OAAQrR,GA0EnCqS,CAAkB1Y,EAAMqG,GACxB6J,GAAW0G,EAAD,WAAUxV,IAChBpB,EAAKqB,WAAY,iBACErB,EAAKqB,YADP,IACjB,2BAAoC,KAAzBH,EAAyB,QAC5BiW,GAAsBjW,IACtByX,GAAczX,EAAMmF,IAHX,+BAOrB,IAAIrG,EAAKuI,aAAgBvI,EAAKoI,SAAStL,QAAWkD,EAAKsB,MAGlD,CAED,GADA4O,GAAW0G,EAAK,MACXgC,GAAY5Y,EAAMqG,EAAO1H,GAAO,CACjC,GAAIqB,EAAKsB,MAAO,CACZ,IAAMuX,EAAc7Y,EAAKsB,MAAMmH,KAAKqQ,KAyKxD,SAA4BxX,EAAO8N,GAC/B,GAAI9N,EAAMxE,QAA8B,kBAAbwE,EAAM,GAAiB,CAC9C,IAAMyX,EAAUb,GAAac,KAAK1X,EAAM,IACxC,IAAiB,OAAZyX,QAAgC,IAAZA,OAAqB,EAASA,EAAQjc,UAAYsS,EAAOrP,QAAP,eAAiCmR,SAAS6H,EAAQ,GAAG5H,eAC5H,OAAO,EAGf,OAAO,EAhL4D8H,CAAmBjZ,EAAKsB,MAAO8N,GAClFyJ,GAAetI,GAAYlK,EAAMuQ,MAAOA,EAAIhH,OAC5CqH,GAAWjX,EAAKsB,MAAO+E,GACvBwS,GAAetI,GAAYlK,EAAMuQ,MAAOA,EAAIhH,OAGhD,GADA5P,EAAKoI,SAASsO,QAAQ/X,IACjBqB,EAAKsB,QAAUtB,EAAKoI,SAAStL,OAAQ,CACtC,IAAM+b,EAAczJ,EAAOrP,QAAQ,0BAC5BqP,EAAOrP,QAAQ,sBAAsBmR,SAASlR,EAAKoB,MAC1DyX,GAAetI,GAAYlK,EAAMuQ,MAAOA,EAAIhH,OAC5CqH,GAAWJ,GAAOxQ,GAClBwS,GAAetI,GAAYlK,EAAMuQ,MAAOA,EAAIhH,QAGpDM,GAAW0G,EAAD,YAAWxV,EAAX,MAlGtB,SAA0BpB,EAAMqG,GACxBuR,GAAc5X,EAAMqG,IAAUA,EAAMwR,QAAQF,OAC5CK,GAAOhY,EAAMqG,EAAMwR,QAAQF,MAAOtR,GAiG9B6S,CAAiBlZ,EAAMqG,QArBvB6J,GAAW0G,EAAD,UA3vBtB,SAAmBxH,GACf,OAAQA,EAAOrP,QAAQ,4BACnB,IAAK,QAAS,MAAO,KACrB,IAAK,MAAO,MAAO,IACnB,QAAS,MAAO,IAuvBOwB,CAAU6N,GAAnB,WAwBRwJ,GAAY5Y,EAAMqG,EAAO1H,IAASqB,EAAKsB,QAE7C2V,GAAWjX,EAAKsB,MAAO+E,GACvBrG,EAAKoI,SAASsO,QAAQ/X,IAE1B,GAAI2Z,GAAU3U,IAAU2D,EAAMxK,OAAS,GAAKuJ,EAAMhC,OAAQ,CACtD,IAAMwL,EAASiH,GAAUzQ,EAAMhC,QAAU,EAAI,EAC7CkM,GAAYqG,EAAKA,EAAIhH,MAAQC,GAEjC+G,EAAIhH,OAASA,EAKjB,SAAS+I,GAAczX,EAAMmF,GACzB,IAAQuQ,EAAgBvQ,EAAhBuQ,IAAKxH,EAAW/I,EAAX+I,OACb,GAAIlO,EAAKE,KAAM,CACX,IAAMA,EAAO0P,GAAS5P,EAAKE,KAAMgO,GAC3B+J,EAASnI,GAAU9P,EAAMkO,GAAQ,GACjCgK,EAASpI,GAAU9P,EAAMkO,GAC3B9N,EAAQJ,EAAKI,MACb2P,GAAmB/P,EAAMkO,KAAY9N,EAIhC8N,EAAOrP,QAAQ,2BAChBuB,EAAQ,CAACF,IAGPE,IACNA,EAAQuV,IAEZ3G,GAAW0G,EAAK,IAAMxV,GAClBE,GACA4O,GAAW0G,EAAK,IAAMuC,GACtBlC,GAAW3V,EAAO+E,GAClB6J,GAAW0G,EAAKwC,IAEmC,SAA9ChK,EAAOrP,QAAQ,4BACpBmQ,GAAW0G,EAAK,IAAMuC,EAASC,IAI3C,SAASR,GAAY5Y,EAAMqG,EAAO1H,GAC9B,GAAIqB,EAAKsB,OAAStB,EAAKoI,SAAStL,OAAQ,CAGpC,IAAMuc,EAAUrZ,EAAKsB,MAAMgY,UAAUtC,IACrC,IAAiB,IAAbqC,EAAgB,CAChBpC,GAAWjX,EAAKsB,MAAMlE,MAAM,EAAGic,GAAUhT,GACzC,IAAMyJ,EAAOzJ,EAAMuQ,IAAI9G,KACnBzR,EAAMgb,EAAU,EAOpB,OANArZ,EAAKoI,SAASsO,QAAQ/X,GAElB0H,EAAMuQ,IAAI9G,OAASA,GAAmC,kBAApB9P,EAAKsB,MAAMjD,IAC7C6R,GAAW7J,EAAMuQ,IAAK5W,EAAKsB,MAAMjD,KAAOkb,YAE5CtC,GAAWjX,EAAKsB,MAAMlE,MAAMiB,GAAMgI,IAC3B,GAGf,OAAO,EAKX,SAASkS,GAAavY,EAAM2D,EAAO2D,EAAOjB,GACtC,IAAQ+I,EAAmB/I,EAAnB+I,OAAQ/K,EAAWgC,EAAXhC,OAChB,IAAK+K,EAAOrP,QAAQ,iBAChB,OAAO,EAEX,GAAc,IAAV4D,IAAgBU,EAEhB,OAAO,EAGX,GAAIA,GAAUyS,GAAUzS,IAA4B,IAAjBiD,EAAMxK,OACrC,OAAO,EAKX,GAAIga,GAAU9W,KAEK8W,GAAUxP,EAAM3D,EAAQ,KAAOmT,GAAUxP,EAAM3D,EAAQ,KAE/D3D,EAAKsB,MAAMmH,KAAKqQ,KAEf9Y,EAAKsB,MAAMmH,KAAKuO,KAAYhX,EAAKoI,SAAStL,QAE9C,OAAO,EAGf,GAAIsU,GAASpR,EAAMoP,GAAS,CAExB,GAAc,IAAVzL,GAEA,IAAK,IAAI3G,EAAI,EAAGA,EAAIsK,EAAMxK,OAAQE,IAC9B,IAAKoU,GAAS9J,EAAMtK,GAAIoS,GACpB,OAAO,OAId,IAAKgC,GAAS9J,EAAM3D,EAAQ,GAAIyL,GAEjC,OAAO,EAEX,GAAIA,EAAOrP,QAAQ,sBAAuB,CAKtC,IAHA,IAAIyZ,EAAiB,EACjB9B,EAAS/T,EACTgU,EAAQhU,EACLoT,GAAgBzP,IAAQoQ,GAAStI,IACpCoK,IAEJ,KAAOzC,GAAgBzP,IAAQqQ,GAAQvI,IACnCoK,IAEJ,GAAIA,GAAkBpK,EAAOrP,QAAQ,sBACjC,OAAO,EAIf,IAAK,IAAI/C,EAAI,EAAGsT,EAAKtQ,EAAKoI,SAAStL,OAAQE,EAAIsT,EAAItT,IAC/C,GAAIub,GAAavY,EAAKoI,SAASpL,GAAIA,EAAGgD,EAAKoI,SAAU/B,GACjD,OAAO,EAGf,OAAO,EAEX,OAAO,EAeX,SAASyS,GAAWxX,GAChB,MAAwB,kBAAVA,GAAsB,QAAQ5B,KAAK4B,GAerD,SAASmY,GAAa/P,EAAM0F,EAAQrP,GAChC,IAAMsG,EAAQsQ,GAAgBvH,GAG9B,OAFA/I,EAAMtG,QAAUA,GAAW,GAC3BwW,GAAO7M,EAAMgQ,GAAWrT,GACjBA,EAAMuQ,IAAItV,MASrB,SAASoY,GAAU1Z,EAAM2D,EAAO2D,EAAOjB,EAAO1H,GAC1C,IAAQiY,EAAiBvQ,EAAjBuQ,IAAK7W,EAAYsG,EAAZtG,QACb,EA6BJ,SAA2BC,GACvB,IAAM2Z,EAAU,GACVC,EAAY,GAClB,GAAI5Z,EAAKqB,WAAY,iBACErB,EAAKqB,YADP,IACjB,2BAAoC,KAAzBH,EAAyB,QAC5B2Y,GAAmB3Y,GACnByY,EAAQnZ,KAAKU,GAGb0Y,EAAUpZ,KAAKU,IANN,+BAUrB,MAAO,CAAEyY,QAAAA,EAASC,UAAAA,GA1CaE,CAAkB9Z,GAAzC2Z,EAAR,EAAQA,QAASC,EAAjB,EAAiBA,UAEXhK,EAAQvJ,EAAMhC,OAAS,EAAI,EACjCuS,EAAIhH,OAASA,EAiJjB,SAAwB5P,EAAM2D,EAAO2D,EAAOjB,GAExC,IAAKA,EAAMhC,QAAoB,IAAVV,EACjB,OAAO,EAEX,OAAQmT,GAAU9W,GApJd+Z,CAAe/Z,EAAM2D,EAAO2D,EAAOjB,IACnCkK,GAAYqG,GAAK,IAEjB5W,EAAKoB,MAAuB,QAAdpB,EAAKoB,MAAmBuY,EAAQ7c,QAC9CoT,GAAW0G,GAAM7W,EAAQia,YAAc,IAAMha,EAAKoB,MAAQrB,EAAQka,WAAa,KAsCvF,SAA+BhC,EAAO5R,GAAO,gBACtB4R,GADsB,IACzC,2BAA0B,KAAf/W,EAAe,QACtB,GAAIA,EAAKI,MACL,GAAkB,UAAdJ,EAAKE,KACL8O,GAAW7J,EAAMuQ,IAAK,KAGtBK,GADe/V,EAAKI,MAAMgR,KAAI,SAAAgE,GAAC,MAAiB,kBAANA,EAAiBA,EAAE4D,QAAQ,OAAQ,KAAO5D,KACjEjQ,QAInB6J,GAAW7J,EAAMuQ,IAAK,KACtBK,GAAW/V,EAAKI,MAAO+E,IAZM,+BApCzC8T,CAAsBR,EAAStT,GAwDnC,SAAiC4R,EAAO5R,GACpC,GAAI4R,EAAMnb,OAAQ,CACd,IAAQ8Z,EAAyBvQ,EAAzBuQ,IAAKxH,EAAoB/I,EAApB+I,OAAQrP,EAAYsG,EAAZtG,QACrBA,EAAQqa,iBAAmBlK,GAAW0G,EAAK7W,EAAQqa,iBACnD,IAAK,IAAIpd,EAAI,EAAGA,EAAIib,EAAMnb,OAAQE,IAAK,CACnC,IAAMkE,EAAO+W,EAAMjb,GACnBkT,GAAW0G,EAAK9F,GAAS5P,EAAKE,MAAQ,GAAIgO,IACtC6B,GAAmB/P,EAAMkO,KAAYlO,EAAKI,OACrC8N,EAAOrP,QAAQ,0BAA4BA,EAAQsa,cACpDnK,GAAW0G,EAAK,IAAM7W,EAAQsa,eAIlCnK,GAAW0G,EAAK,IAAM5F,GAAU9P,EAAMkO,GAAQ,IAC9C6H,GAAW/V,EAAKI,OAASuV,GAAOxQ,GAChC6J,GAAW0G,EAAK5F,GAAU9P,EAAMkO,KAEhCpS,IAAMib,EAAMnb,OAAS,GAAKiD,EAAQua,eAClCpK,GAAW0G,EAAK7W,EAAQua,eAGhCva,EAAQwa,gBAAkBrK,GAAW0G,EAAK7W,EAAQwa,iBA5EtDC,CAAwBZ,EAAUhQ,OAAOuN,IAAwB9Q,IAC7DrG,EAAKuI,aAAgBvI,EAAKsB,OAAUtB,EAAKoI,SAAStL,SAiF1D,SAAmBkD,EAAMqG,GAErB,IAAKrG,EAAKsB,OAAStB,EAAKoI,SAAStL,OAC7B,OAEJ,IAAMwE,EAAQtB,EAAKsB,OAASuV,GACtB1G,EA3fV,SAAwB/Q,GACpB,IAD4B,EACtBa,EAAS,GACX6P,EAAO,GAFiB,UAGZ1Q,GAHY,IAG5B,2BAAwB,KAAbkX,EAAa,QACpB,GAAiB,kBAANA,EAAgB,CACvB,IAAMnG,EAAQmG,EAAElG,MAAM,aAEtB,IADAN,EAAKtP,KAAK2P,EAAMnH,SAAW,IACpBmH,EAAMrT,QACTmD,EAAOO,KAAKsP,GACZA,EAAO,CAACK,EAAMnH,SAAW,SAI7B8G,EAAKtP,KAAK8V,IAbU,8BAiB5B,OADAxG,EAAKhT,QAAUmD,EAAOO,KAAKsP,GACpB7P,EA0eOwa,CAAenZ,GACrBsV,EAAiBvQ,EAAjBuQ,IAAK7W,EAAYsG,EAAZtG,QACb,GAAqB,IAAjBoQ,EAAMrT,QACFkD,EAAKoB,MAAQpB,EAAKqB,aAClBb,GAAKoW,EAAK,KAEdK,GAAW3V,EAAO+E,OAEjB,CAGD,IAHC,EAGKqU,EAAc,GAChBC,EAAY,EAJf,UAMkBxK,GANlB,IAMD,2BAA0B,KAChBkD,EAAMuH,GADU,SAEtBF,EAAYla,KAAK6S,GACbA,EAAMsH,IACNA,EAAYtH,IAVnB,8BAcDuD,EAAIhH,QACJ,IAAK,IAAI5S,EAAI,EAAGA,EAAImT,EAAMrT,OAAQE,IAC9BuT,GAAYqG,GAAK,GACjB7W,EAAQ8a,gBAAkBra,GAAKoW,EAAK7W,EAAQ8a,gBAC5C5D,GAAW9G,EAAMnT,GAAIqJ,GACjBtG,EAAQ+a,gBACRta,GAAKoW,EAAK,IAAI7V,OAAO4Z,EAAYD,EAAY1d,KAC7CwD,GAAKoW,EAAK7W,EAAQ+a,gBAG1BlE,EAAIhH,SAjHJmL,CAAU/a,EAAMqG,GAChBrG,EAAKoI,SAASsO,QAAQ/X,IANlB0H,EAAMtG,QAAQwB,WACd2O,GAAW0G,EAAKvQ,EAAMtG,QAAQwB,WAOtCqV,EAAIhH,OAASA,EAiHjB,SAASiK,GAAmB3Y,GACxB,MAAqB,UAAdA,EAAKE,MAAkC,OAAdF,EAAKE,KAKzC,SAASwZ,GAAYxb,GACjB,IADyB,EACrBiU,EAAM,EADe,UAELjU,GAFK,IAEzB,2BAA4B,KAAjBO,EAAiB,QACxB0T,GAAwB,kBAAV1T,EAAqBA,EAAM7C,OAAS6C,EAAMyB,KAAKtE,QAHxC,8BAKzB,OAAOuW,EAyCX,IAAM2H,GAAa,CAAE7C,KAAAA,GAAM8C,KA/B3B,SAAcvR,EAAM0F,GAChB,OAAOqK,GAAa/P,EAAM0F,EAAQ,CAC9B4K,WAAY,IACZI,gBAAiB,IACjBG,eAAgB,IAChBD,cAAe,IACfQ,cAAe,KACfT,aAAc,OACd9Y,UAAW,OAuBc2Z,KAnBjC,SAAcxR,EAAM0F,GAChB,OAAOqK,GAAa/P,EAAM0F,EAAQ,CAC9BgL,gBAAiB,IACjBE,cAAe,IACfO,eAAgB,KAChBtZ,UAAW,OAcoB4Z,IAVvC,SAAazR,EAAM0F,GACf,OAAOqK,GAAa/P,EAAM0F,EAAQ,CAC9BgL,gBAAiB,IACjBG,eAAgB,IAChBD,cAAe,KACfO,eAAgB,KAChBtZ,UAAyD,QAA9C6N,EAAOrP,QAAQ,2BAAuC,IAAM,OAS/E,SAASqb,GAAM1R,EAAM0F,GACjB,IAAIiM,EACJ,GAAoB,kBAAT3R,EAAmB,CAC1B,IAAI4R,EAAWlM,EACXA,EAAOrP,QAAQ,iBACfub,EAAW9T,OAAOC,OAAOD,OAAOC,OAAO,GAAI6T,GAAW,CAAEjf,KAAK,KAE7D+S,EAAOrP,QAAQ,iBACfub,EAAW9T,OAAOC,OAAOD,OAAOC,OAAO,GAAI6T,GAAW,CAAEjS,MAAM,KAElEK,EAAOD,GAAkBC,EAAM4R,GAG/BD,EAAejM,EAAOvN,KACtBuN,EAAOvN,UAAOoI,EASlB,OAHAP,EAhzCJ,SAAyBA,EAAM0F,GAC3B,IAAM/O,EAAQ,GACRkb,EAAWnM,EAAOrP,QAAQ,4BA0BhC,OADAwP,GAAY7F,GAxBI,SAAV8F,EAAWhK,GACb,IAAMgW,EAAUhW,EAAMpE,MAAQgO,EAAOqM,SAASjW,EAAMpE,MAKpD,IAAKoa,GAAWnb,EAAM6Q,SAASsK,GAC3B,OAAO,KAEX,IAAME,EAAcjS,GAAkB+R,EAASpM,GAC/C/O,EAAMG,KAAKgb,GACXjM,GAAYmM,EAAalM,GACzBnP,EAAMO,MAZiB,gBAcD8a,EAAYtT,UAdX,IAcvB,2BAA4C,KAAjCuT,EAAiC,QACxC,GAAInW,EAAMnE,WAAY,CAClB,IAAM1E,EAAOgf,EAAQta,YAAc,GAC7B3E,EAAK8I,EAAMnE,YAAc,GAC/Bsa,EAAQta,WAAaka,EAAW7e,EAAGY,OAAOX,GAAQA,EAAKW,OAAOZ,GAElEgT,GAAWlK,EAAOmW,IApBC,8BAsBvB,OAAOD,KAGJhS,EAoxCAkS,CAAgBlS,EAAM0F,GAl1CjC,SAAcpP,EAAM6b,EAAIxV,GACpB,IAAMmM,EAAY,CAACxS,GAOnBA,EAAKoI,SAASsO,SANG,SAAXD,EAAYrW,GACdyb,EAAGzb,EAAKoS,EAAWnM,GACnBmM,EAAUhS,KAAKJ,GACfA,EAAIgI,SAASsO,QAAQD,GACrBjE,EAAU5R,SA60Cdkb,CAAKpS,EAAMqS,GAAW3M,GACtBA,EAAOvN,KAAwB,OAAjBwZ,QAA0C,IAAjBA,EAA0BA,EAAejM,EAAOvN,KAChF6H,EAKX,SAASsS,GAAUtS,EAAM0F,GAErB,OADkB4L,GAAW5L,EAAO6M,SAAW9D,IAC9BzO,EAAM0F,GAK3B,SAAS2M,GAAU/b,EAAMwS,EAAWpD,IA9mCpC,SAAqBpP,EAAMwS,EAAWpD,IAC7BpP,EAAKoB,MAAQpB,EAAKqB,YACnBkR,GAAmBvS,EAAMwS,EAAWpD,GA6mCxC8M,CAAYlc,EAAMwS,EAAWpD,GAn7CjC,SAAyBpP,EAAMoP,GAC3B,GAAKpP,EAAKqB,WAAV,CAGA,IAJmC,EAI7BA,EAAa,GACb8a,EAAS,GALoB,UAMhBnc,EAAKqB,YANW,IAMnC,2BAAoC,KAAzBH,EAAyB,QAChC,GAAIA,EAAKE,KAAM,CACX,IAAM0P,EAAW5P,EAAKE,KACtB,GAAI0P,KAAYqL,EAAQ,CACpB,IAAMrN,EAAOqN,EAAOrL,GACH,UAAbA,EACAhC,EAAKxN,MAAQuN,GAAWC,EAAKxN,MAAOJ,EAAKI,MAAO,KAGhD2N,GAAkBH,EAAM5N,EAAMkO,QAKlC/N,EAAWb,KAAK2b,EAAOrL,GAAYtJ,OAAOC,OAAO,GAAIvG,SAIzDG,EAAWb,KAAKU,IAxBW,8BA2BnClB,EAAKqB,WAAaA,GAy5ClB+a,CAAgBpc,EAAMoP,GAn/B1B,SAAepP,EAAMwS,EAAWpD,GAC5B,IAAIsG,EACJ,GAAI1V,EAAKoB,OAASsU,EAAI1V,EAAKoB,KAAK7C,MAAMyU,KAAW,CAC7C,IAAMqJ,EAAKzJ,GAAa8C,EAAE,KAAO9C,GAAaG,MACxCuJ,EAAe5G,EAAE,GAAK7O,KAAKC,IAAI,EAAGjD,OAAO6R,EAAE,KAAO,GAElDzB,EAAYhB,GAAKqJ,EADF5G,EAAE,GAAK7O,KAAKC,IAAIwV,EAAczY,OAAO6R,EAAE,GAAGtY,MAAM,KAAOkf,GAEtEvb,EAASf,EAAKe,QAyF5B,SAAsByR,GAClB,IAAK,IAAIxV,EAAIwV,EAAU1V,OAAS,EAAGE,GAAK,EAAGA,IAAK,CAC5C,IAAMqb,EAAU7F,EAAUxV,GAC1B,GAAqB,qBAAjBqb,EAAQnY,MAA+BmY,EAAQtX,OAC/C,OAAOsX,EAAQtX,QA7FWwb,CAAa/J,GAC3CxS,EAAKoB,KAAOpB,EAAKqB,gBAAa,EAC9BrB,EAAKsB,MAAQ,CAACyS,GAAUsI,EAAIpI,GAAYlT,GAA2B,IAAjBA,EAAOO,QACrDtB,EAAKe,QAAUyR,EAAU1V,OAAS,GAClCyV,GAAmBvS,EAAMwS,EAAWpD,IAy+B5CoN,CAAMxc,EAAMwS,EAAWpD,GACD,QAAlBA,EAAO6M,QAt3Bf,SAAajc,GAQb,IAAqBoB,EACD,kBADCA,EAPDpB,EAAKoB,OAQsB,mBAATA,IARJpB,EAAKqB,aAAerB,EAAKoI,SAAStL,SAAUkD,EAAKsB,QAC3EtB,EAAKqB,WAAarB,EAAKqB,WAAWuI,OAAO0K,KAq3BzCmI,CAAIzc,GAEJoP,EAAOrP,QAAQ,gBA34BvB,SAAaC,GACLA,EAAKqB,YACLrB,EAAKqB,WAAWqV,QAAQrC,IA04BxBhY,CAAI2D,GAEJoP,EAAOrP,QAAQ,gBACf6U,GAAI5U,EAAMwS,EAAWpD,GAI7B,IAAMsN,GAAa,wCACbC,GAAM,CAAErb,OAAO,GAIrB,SAASsb,GAAcC,EAAKvb,GAIxB,IAAMoU,EAAIpU,EAAM/C,MAAMme,IACtB,GAAIhH,EAAG,CACH,IADG,EACGoH,EAAW,GACXC,EAASrH,EAAE,GAAKA,EAAE,GAAGtF,MAAM,KAAKkC,IAAI0K,IAAc,GAFrD,UAGgBD,GAHhB,IAGH,2BAA2B,OAAhBpU,EAAgB,kBACFA,GADE,IACvB,2BAA2B,CACvBsU,GADuB,QACCH,IAFL,gCAHxB,8BAQH,MAAO,CACH5c,KAAM,WACN2c,IAAAA,EACAlO,SAAU+G,EAAE,GACZpU,MAAOyb,EACPD,SAAAA,EACAI,aAAc,IAGtB,MAAO,CAAEhd,KAAM,MAAiB2c,IAAAA,EAAKvb,MAAAA,GAoCzC,SAAS6b,GAAatR,EAAGD,GACrB,OAAIC,EAAEgR,MAAQjR,EAAEiR,IACL,EAEJhR,EAAEgR,IAAMjR,EAAEiR,KAAO,EAAI,EAEhC,SAASG,GAAW1b,GAChB,OAAOmN,GAAQnN,EAAMwI,OAAQ6S,IAAK,GAAGrb,MAEzC,SAAS8b,GAAW5B,GAChB,MAAwB,aAAjBA,EAAQtb,KAEnB,SAAS+c,GAAgBI,EAAQnO,GAAM,gBACnBmO,EAAO/b,OADY,IACnC,2BAA8B,KAAnBgc,EAAmB,QAC1B,GAAe,YAAXA,EAAEpd,KACFgP,EAAKoO,EAAEhc,OAASgc,OAEf,GAAe,iBAAXA,EAAEpd,KACPgP,EAAKoO,EAAElc,MAAQkc,OAEd,GAAe,UAAXA,EAAEpd,KAAkB,CAEzB,IAAMoB,EAAQgc,EAAElc,KAAK0I,OACjBxI,IACA4N,EAAK5N,GAAS,CAAEpB,KAAM,UAAWoB,MAAAA,MAZV,+BA4BvC,SAASic,GAAWC,EAAMC,GAA4B,IAAtBC,EAAsB,wDAGlD,IAFAF,EAAOA,EAAKrM,kBACZsM,EAAOA,EAAKtM,eAER,OAAO,EAGX,IAAKqM,IAASC,GAAQD,EAAKlf,WAAW,KAAOmf,EAAKnf,WAAW,GACzD,OAAO,EAEX,IAAMqf,EAAUH,EAAK1gB,OACf8gB,EAAUH,EAAK3gB,OACrB,IAAK4gB,GAAgBC,EAAUC,EAC3B,OAAO,EAoBX,IATA,IAAMC,EAAYhX,KAAK0M,IAAIoK,EAASC,GAC9BjD,EAAY9T,KAAKC,IAAI6W,EAASC,GAChC5gB,EAAI,EACJ8gB,EAAI,EACJC,EAAQpD,EACRqD,EAAM,EACNC,EAAM,EACNC,GAAQ,EACRC,GAAU,EACPnhB,EAAI2gB,GAAS,CAIhB,IAHAK,EAAMR,EAAKlf,WAAWtB,GACtBkhB,GAAQ,EACRC,GAAU,EACHL,EAAIF,GAAS,CAEhB,GAAII,KADJC,EAAMR,EAAKnf,WAAWwf,IACL,CACbI,GAAQ,EACRH,GAASpD,GAAawD,EAAUnhB,EAAI8gB,GACpC,MAGJK,EAAkB,KAARF,EACVH,IAEJ,IAAKI,EAAO,CACR,IAAKR,EACD,OAAO,EAEX,MAEJ1gB,IAEJ,IAAMohB,EAAaphB,EAAI2d,EACjB0D,EAAQ1D,EAAYkD,EACpBS,EAAWC,GAAI5D,GAAa4D,GAAIF,GACtC,OAAQN,EAAQK,EAAcE,EAKlC,SAASC,GAAIzf,GACT,OAAOA,GAAKA,EAAI,GAAK,EAGzB,SAASwM,GAAM3L,EAAO6e,GAClB,OAAK7e,EAAM+L,GAAM/L,EAAMgM,GAAMhM,EAAMiM,GAAMjM,EAAMkM,EAG1B,IAAZlM,EAAMkM,EASnB,SAAelM,EAAO+K,GAClB,IAAMmR,EAAMnR,GAAS+T,GAAW9e,EAAM+L,IAAM+S,GAAW9e,EAAMgM,IAAM8S,GAAW9e,EAAMiM,GAC9E8S,GAAaC,GACnB,MAAO,IAAM9C,EAAGlc,EAAM+L,GAAKmQ,EAAGlc,EAAMgM,GAAKkQ,EAAGlc,EAAMiM,GAXvCgT,CAAMjf,EAAO6e,GAgB5B,SAAe7e,GACX,IAAMkf,EAAS,CAAClf,EAAM+L,EAAG/L,EAAMgM,EAAGhM,EAAMiM,GACxB,IAAZjM,EAAMkM,GACNgT,EAAOre,KAAKse,GAAKnf,EAAMkM,EAAG,IAE9B,gBAA4B,IAAlBgT,EAAO/hB,OAAe,MAAQ,OAAxC,YAAkD+hB,EAAO3U,KAAK,MAA9D,KAnBO6U,CAAMpf,GALF,cA0Bf,SAASmf,GAAKE,GAAiB,IAAZC,EAAY,uDAAH,EACxB,OAAOD,EAAIE,QAAQD,GAAQ/E,QAAQ,SAAU,IAEjD,SAASuE,GAAWU,GAChB,QAASA,EAAM,IAEnB,SAAST,GAAWM,GAChB,OAAQA,GAAO,GAAGI,SAAS,IAE/B,SAAST,GAAMK,GACX,OAEJ,SAAa1d,EAAO+R,GAChB,KAAO/R,EAAMxE,OAASuW,GAClB/R,EAAQ,IAAMA,EAElB,OAAOA,EANA+d,CAAIL,EAAII,SAAS,IAAK,GASjC,SAASE,GAAI5V,EAAM0F,GACf,IAAIhG,EACEwN,EAAMjH,GAAmBP,EAAOrP,SAChCuY,EAASlJ,EAAOrP,QAAQ,iBAC+C,eAA9C,QAAzBqJ,EAAKgG,EAAOnM,eAA4B,IAAPmG,OAAgB,EAASA,EAAGhI,QAE/DsI,EAAOA,EAAKE,QAAO,SAAA5J,GAAI,OAAIA,EAAKwb,YAEpC,IAAK,IAAIxe,EAAI,EAAGA,EAAI0M,EAAK5M,OAAQE,IACzBsb,GAAgB,IAANtb,GACVuT,GAAYqG,GAAK,GAErBjI,GAASjF,EAAK1M,GAAI4Z,EAAKxH,GAE3B,OAAOwH,EAAItV,MAKf,SAASqN,GAAS3O,EAAM4W,EAAKxH,GACzB,IAAMmQ,EAASnQ,EAAOrP,QAAQ,mBAC9B,GAAIC,EAAKoB,KAAM,CAGX8O,GAAW0G,GADE2I,EAAqBvf,EAAKoB,KA+GhC8Y,QAAQ,WAAW,SAACsF,EAAGC,GAAJ,OAAeA,EAAOnO,iBA/GDtR,EAAKoB,MAC7BgO,EAAOrP,QAAQ,uBAClCC,EAAKsB,MAAMxE,OA0BvB,SAAuBkD,EAAM4W,EAAKxH,GAC9B,IAAMmQ,EAASnQ,EAAOrP,QAAQ,mBACxBif,EAAMO,EAqEhB,SAA0Bvf,GACtB,GAA0B,IAAtBA,EAAKsB,MAAMxE,OAAc,CACzB,IAAMugB,EAASrd,EAAKsB,MAAM,GAC1B,GAA4B,IAAxB+b,EAAO/b,MAAMxE,QAAyC,gBAAzBugB,EAAO/b,MAAM,GAAGpB,KAC7C,OAAOmd,EAAO/b,MAAM,IAzEPoe,CAAiB1f,GAAQ,KAC9C,IAAIgf,GAASA,EAAI7T,MAAqB,OAAb6T,EAAI7T,KAKxB,CACD,IAAMvI,EA4Ed,SAAkBwM,GACd,OAAOA,EAAOrP,QAAQ,+BAAiC,IAAM,IA7E3C4f,CAASvQ,GACvBmQ,GAAU/e,GAAKoW,EAAKhU,GACpB,IAAK,IAAI5F,EAAI,EAAGA,EAAIgD,EAAKsB,MAAMxE,OAAQE,IACzB,IAANA,GACAwD,GAAKoW,EAAK,MAEdgJ,GAAY5f,EAAKsB,MAAMtE,GAAI4Z,EAAKxH,GAEpCmQ,GAAU/e,GAAKoW,EAAKhU,QAXpBpC,GAAKoW,EAAK5P,OAAOgY,EAAI1d,QA/BjBue,CAAc7f,EAAM4W,EAAKxH,GAGzBuB,GAAUiG,EAAK,EAAG,IAElB2I,EAGA/e,GAAKoW,EAAK,MAGVkJ,GAAgB9f,EAAM4W,GAAK,GAC3BpW,GAAKoW,EAAKxH,EAAOrP,QAAQ,0BAG5B,iBAEoBC,EAAKsB,OAFzB,IAED,2BAAiC,OAAtB+b,EAAsB,kBACbA,EAAO/b,OADM,IAC7B,2BAA8B,CAC1Bye,GAD0B,QACXnJ,EAAKxH,IAFK,gCAFhC,8BAOD0Q,GAAgB9f,EAAM4W,EAAK5W,EAAKsB,MAAMxE,OAAS,IAuBvD,SAASgjB,GAAgB9f,EAAM4W,EAAKoJ,GAC5BhgB,EAAKoN,YACD4S,GACAxf,GAAKoW,EAAK,KAEdpW,GAAKoW,EAAK,eAGlB,SAASgJ,GAAYte,EAAOsV,EAAKxH,GAC7B,IAAK,IAAIpS,EAAI,EAAGijB,GAAW,EAAGjjB,EAAIsE,EAAMA,MAAMxE,OAAQE,IAAK,CACvD,IAAM2C,EAAQ2B,EAAMA,MAAMtE,GAGhB,IAANA,GAA2B,UAAf2C,EAAMO,MAAoBP,EAAM1B,QAAUgiB,GACtDzf,GAAKoW,EAAK,KAEdmJ,GAAYpgB,EAAOiX,EAAKxH,GACxB6Q,EAAUtgB,EAAK,KAGvB,SAASogB,GAAYpgB,EAAOiX,EAAKxH,GAC7B,GAAmB,eAAfzP,EAAMO,KACNM,GAAKoW,EAAKtL,GAAM3L,EAAOyP,EAAOrP,QAAQ,8BAErC,GAAmB,YAAfJ,EAAMO,KACXgQ,GAAW0G,EAAKjX,EAAM2B,YAErB,GAAmB,gBAAf3B,EAAMO,KACXgQ,GAAW0G,EAAKkI,GAAKnf,EAAM2B,MAAO,GAAK3B,EAAMwL,WAE5C,GAAmB,gBAAfxL,EAAMO,KAAwB,CACnC,IAAM0C,EAAwB,WAAhBjD,EAAMiD,MAAqB,IAAM,IAC/CsN,GAAW0G,EAAKhU,EAAQjD,EAAM2B,MAAQsB,QAErC,GAAmB,UAAfjD,EAAMO,KACXyQ,GAAUiG,EAAKjX,EAAMgE,MAAOhE,EAAMyB,WAEjC,GAAmB,iBAAfzB,EAAMO,KAAyB,CACpCM,GAAKoW,EAAKjX,EAAMyB,KAAO,KACvB,IAAK,IAAIpE,EAAI,EAAGA,EAAI2C,EAAM9C,UAAUC,OAAQE,IACpCA,GACAwD,GAAKoW,EAAK,MAEdgJ,GAAYjgB,EAAM9C,UAAUG,GAAI4Z,EAAKxH,GAEzC5O,GAAKoW,EAAK,MAwBlB,IAAMsJ,GAAe,KAKrB,SAASC,GAAQzW,EAAM0F,GACnB,IAAIhG,EACEqS,GAAoC,QAAvBrS,EAAKgG,EAAOgR,aAA0B,IAAPhX,OAAgB,EAASA,EAAGiX,qBAgBlF,SAAyB5E,GAErB,IADA,IAAMxb,EAAS,GACf,MAAkBuH,OAAO8Y,KAAK7E,GAA9B,eAAyC,CAApC,IAAMoB,EAAG,KACV5c,EAAOO,KAAKoc,GAAcC,EAAKpB,EAASoB,KAE5C,OAjWJ,SAAcpB,GACVA,EAAWA,EAASre,QAAQmjB,KAAKpD,IACjC,IACIrO,EAHgB,EAEdzO,EAAQ,GAFM,UAOFob,EAAS7R,OAAOwT,KAPd,IAOpB,2BAA+C,CAI3C,IAJ2C,IAApCoD,EAAoC,QAIpCngB,EAAMvD,QAAQ,CAEjB,GADAgS,EAAOzO,EAAMA,EAAMvD,OAAS,GACxB0jB,EAAI7R,SAASrF,WAAWwF,EAAKH,WACwB,KAAlD6R,EAAI7R,SAASrQ,WAAWwQ,EAAKH,SAAS7R,QAAwB,CACjEgS,EAAKoO,aAAa1c,KAAKggB,GACvBngB,EAAMG,KAAKggB,GACX,MAEJngB,EAAMO,MAELP,EAAMvD,QACPuD,EAAMG,KAAKggB,IAtBC,8BAyBpB,OAAO/E,EAwUAgF,CAAKxgB,GArByFygB,CAAgBtR,EAAOqM,UACxHrM,EAAOgR,QACPhR,EAAOgR,MAAMC,mBAAqB5E,GAElB,kBAAT/R,IACPA,EAAO+E,GAAQ/E,EAAM,CAAEpI,MAAOqf,GAAavR,MAE/C,IAT2B,EASrBwR,EAkVV,SAA6BnF,EAAUrM,GACnC,GAAIA,EAAOnM,QAAS,CAChB,GAA4B,cAAxBmM,EAAOnM,QAAQ7B,KACf,OAAOqa,EAAS7R,QAAO,SAAAC,GAAC,MAAe,QAAXA,EAAE3J,QAElC,GAA4B,eAAxBkP,EAAOnM,QAAQ7B,KACf,OAAOqa,EAAS7R,QAAO,SAAAC,GAAC,MAAe,aAAXA,EAAE3J,QAGtC,OAAOub,EA3VkBoF,CAAoBpF,EAAUrM,GAT5B,UAUR1F,GAVQ,IAU3B,2BAAyB,CACrBoX,GADqB,QACHF,EAAkBxR,IAXb,8BAa3B,OAAO1F,EAgBX,SAASoX,GAAY9gB,EAAMyb,EAAUrM,GACjC,IA+BJ,SAAyBpP,EAAMoP,GAC3B,IAAI2R,EAAa,KACX1D,EAA+B,IAAtBrd,EAAKsB,MAAMxE,OAAekD,EAAKsB,MAAM,GAAK,KACzD,GAAI+b,GAAkC,IAAxBA,EAAO/b,MAAMxE,OAAc,CACrC,IAAMwgB,EAAID,EAAO/b,MAAM,GACR,iBAAXgc,EAAEpd,MAA2Bod,EAAElc,OAAS8e,KACxCa,EAAazD,GAGrB,GAAIyD,GAAc/gB,EAAKoB,OAAS8e,GAe5B,OANIa,EARCA,EAQYvZ,OAAOC,OAAOD,OAAOC,OAAO,GAAIsZ,GAAa,CAAE3f,KAAM,oBAPrD,CACTlB,KAAM,eACNkB,KAAM,kBACNvE,UAAW,CAACmkB,GAASnQ,GAAM,EAAG,OAMjCzB,EAAOnM,UACRjD,EAAKoB,KAAO,oBAEhBpB,EAAKsB,MAAQ,CAAC0f,GAASD,KAChB,EAEX,OAAO,EAzDFE,CAAgBjhB,EAAMoP,GAAS,CAChC,IAAM2O,EAAQ3O,EAAOrP,QAAQ,kCAC7B,GAAI4gB,GAAavR,GAAS,CAEtB,IAAM8R,EAAW9R,EAAOnM,QAAQ7B,KAC1Boa,EAAUC,EAASjS,MAAK,SAAAK,GAAC,MAAe,aAAXA,EAAE3J,MAAsC2J,EAAE8E,WAAauS,KAC1FC,GAAqBnhB,EAAMoP,EAAQoM,EAASuC,GAC5C/d,EAAKwb,QAAUA,OAEd,GAAIxb,EAAKoB,KAAM,CAChB,IAAMoa,EAAU4F,GAAcphB,EAAKoB,KAAMqa,EAAUsC,GAAO,GAC1D/d,EAAKwb,QAAUA,EACXA,IACqB,aAAjBA,EAAQtb,KAiD5B,SAA2BF,EAAMwb,EAASpM,GACtC,IAOMiS,EAmHV,SAA0B3X,EAAM1L,GAC5B,IAAK,IAAIhB,EAAI,EAAGskB,EAAU,EAAGtkB,EAAI0M,EAAK5M,OAAQE,IAAK,CAE/C,IAAiB,KADjBskB,EAAUtjB,EAAIkX,QAAQxL,EAAK1M,GAAIskB,IAE3B,OAAO5X,EAAKtM,MAAMJ,GAEtBskB,IAEJ,MAAO,GA3HaC,CAPPvhB,EAAKoB,KAOyBoa,EAAQqB,KACnD,GAAIwE,EAAa,CACb,GAAIrhB,EAAKsB,MAAMxE,OAEX,OAAOkD,EAEX,IAAMwhB,EAAKC,GAAeJ,EAAajS,EAAQoM,GAC/C,IAAKgG,EACD,OAAOxhB,EAEXA,EAAKsB,MAAMd,KAAKwgB,GAASQ,IAG7B,GADAxhB,EAAKoB,KAAOoa,EAAQ7M,SAChB3O,EAAKsB,MAAMxE,OAEXqkB,GAAqBnhB,EAAMoP,EAAQoM,QAElC,GAAIA,EAAQla,MAAMxE,OAAQ,CAC3B,IAAM4kB,EAAelG,EAAQla,MAAM,GAInCtB,EAAKsB,MAAiC,IAAzBka,EAAQla,MAAMxE,QAAgB4kB,EAAajZ,KAAKkZ,IACvDD,EACAA,EAAapP,KAAI,SAAAxT,GAAC,OAAI8iB,GAAc9iB,EAAGsQ,OAhFjCyS,CAAkB7hB,EAAMwb,EAASpM,GAgHrD,SAA0BpP,EAAMwb,GAI5B,IACI9F,EADA7F,EAAS,EAEPiS,EAAU,wBACVC,EAAa/hB,EAAKsB,MAAM,GACxBse,EAAc,GACpB,KAAOlK,EAAIoM,EAAQ9I,KAAKwC,EAAQla,QACxBuO,IAAW6F,EAAE/R,OACbic,EAAYpf,KAAKwhB,GAAQxG,EAAQla,MAAMlE,MAAMyS,EAAQ6F,EAAE/R,SAE3DkM,EAAS6F,EAAE/R,MAAQ+R,EAAE,GAAG5Y,OACpBilB,GAAcA,EAAWzgB,MAAMxE,OAC/B8iB,EAAYpf,KAAKuhB,EAAWzgB,MAAM0H,SAGlC4W,EAAYpf,KAAKqQ,GAAMhN,OAAO6R,EAAE,IAAKA,EAAE,GAAKA,EAAE,GAAGtY,MAAM,GAAK,KAGpE,IAAM6kB,EAAOzG,EAAQla,MAAMlE,MAAMyS,GAC7BoS,GACArC,EAAYpf,KAAKwhB,GAAQC,IAE7BjiB,EAAKoB,UAAO,EACZpB,EAAKsB,MAAQ,CAAC0f,GAAQ,WAAR,EAAYpB,IAvIVsC,CAAiBliB,EAAMwb,KASvC,OAJIxb,EAAKoB,MAAQgO,EAAOnM,UAqM5B,SAA6BjD,EAAMoP,GAC/B,IADuC,EACjC+S,EAAU/S,EAAOrP,QAAQ,0BACzBqiB,EAAWhT,EAAOrP,QAAQ,uBAFO,UAGvBC,EAAKsB,OAHkB,IAGvC,2BAA4B,OAAjBgc,EAAiB,kBACRA,EAAEhc,OADM,IACxB,2BAAyB,KAAdgV,EAAc,QACN,gBAAXA,EAAEpW,OACEoW,EAAEnL,KACFmL,EAAEnL,KAAOgX,EAAQ7L,EAAEnL,OAASmL,EAAEnL,KAEb,IAAZmL,EAAEhV,OAAgB8gB,EAASlR,SAASlR,EAAKoB,QAC9CkV,EAAEnL,KAAOmL,EAAEpL,SAASgG,SAAS,KACvB9B,EAAOrP,QAAQ,wBACfqP,EAAOrP,QAAQ,yBATT,gCAHW,+BAnMnCsiB,CAAoBriB,EAAMoP,GAEvBpP,EAwEX,SAASmhB,GAAqBnhB,EAAMoP,EAAQoM,EAAS8G,GAAU,gBACtCtiB,EAAKsB,OADiC,IAC3D,2BAAiC,OAAtB+b,EAAsB,QACvB/b,EAAQ,GADe,UAET+b,EAAO/b,OAFE,IAE7B,2BAAkC,KAAvB3B,EAAuB,QAC9B,GAAmB,YAAfA,EAAMO,KACNoB,EAAMd,KAAKihB,GAAe9hB,EAAM2B,MAAO8N,EAAQoM,EAAS8G,IAAa3iB,QAEpE,GAAmB,iBAAfA,EAAMO,KAAyB,CAGpC,IAAM3B,EAAQkjB,GAAe9hB,EAAMyB,KAAMgO,EAAQoM,EAAS8G,GACtD/jB,GAAwB,iBAAfA,EAAM2B,KACfoB,EAAMd,KAAKgH,OAAOC,OAAOD,OAAOC,OAAO,GAAIlJ,GAAQ,CAAE1B,UAAW8C,EAAM9C,UAAUS,OAAOiB,EAAM1B,UAAUO,MAAMuC,EAAM9C,UAAUC,YAG7HwE,EAAMd,KAAKb,QAIf2B,EAAMd,KAAKb,IAlBU,8BAqB7B0d,EAAO/b,MAAQA,GAtBwC,+BA+D/D,SAAS8f,GAAc1X,EAAMpC,GAA2C,MAApCgb,EAAoC,uDAAzB,EAAG5E,EAAsB,wDAChE6E,EAAc,KACdjE,EAAW,EAFqD,UAGjDhX,GAHiD,IAGpE,2BAA0B,KAAfqB,EAAe,QAChBoV,EAAQR,GAAW7T,EAAM8Y,GAAe7Z,GAAO+U,GACrD,GAAc,IAAVK,EAEA,OAAOpV,EAEPoV,GAASA,GAASO,IAClBA,EAAWP,EACXwE,EAAc5Z,IAX8C,8BAcpE,OAAO2V,GAAYgE,EAAWC,EAAc,KAEhD,SAASC,GAAe7Z,GACpB,MAAuB,kBAATA,EAAoBA,EAAOA,EAAKkU,IAqBlD,SAAS4E,GAAeD,EAAIpS,EAAQoM,EAAS8G,GACzC,IAAIG,EACJ,GAAIjH,EAAS,CACT,GAAIiH,EAAMrB,GAAcI,EAAIha,OAAO8Y,KAAK9E,EAAQsB,UAAWwF,GACvD,OAAO9G,EAAQsB,SAAS2F,GAFnB,gBAISjH,EAAQ0B,cAJjB,IAIT,2BAAwC,KAA7BwF,EAA6B,QACpC,GAAID,EAAMrB,GAAcI,EAAIha,OAAO8Y,KAAKoC,EAAI5F,UAAWwF,GACnD,OAAOI,EAAI5F,SAAS2F,IANnB,+BAUb,OAAIA,EAAMrB,GAAcI,EAAIpS,EAAOrP,QAAQ,uBAAwBuiB,IACxDN,GAAQS,GAEZ,KA0BX,SAASzB,KAAkB,2BAANhT,EAAM,yBAANA,EAAM,gBACvB,MAAO,CACH9N,KAAM,WACNoB,MAAO0M,GAMf,SAASgU,GAAQ1gB,GACb,MAAO,CAAEpB,KAAM,UAAWoB,MAAAA,GAK9B,SAASuP,GAAMlN,EAAOvC,GAClB,MAAO,CAAElB,KAAM,QAASyD,MAAAA,EAAOvC,KAAAA,GAKnC,SAASugB,GAASrgB,GAAO,gBACLA,EAAMA,OADD,IACrB,2BAA6B,KAAlBgc,EAAkB,QACzB,GAAe,UAAXA,EAAEpd,MAAgC,iBAAXod,EAAEpd,MAA2Bod,EAAEzgB,UAAU4L,KAAKkZ,IACrE,OAAO,GAHM,8BAMrB,OAAO,EAKX,SAASC,GAAc5hB,EAAMoP,GAA8B,MAAtB/I,EAAsB,uDAAd,CAAE1C,MAAO,GAC9CrC,EAAQ,GAD2C,UAEvCtB,EAAKsB,OAFkC,IAEvD,2BAA4B,KAAjBgc,EAAiB,QACxB,OAAQA,EAAEpd,MACN,IAAK,aACDoB,EAAMd,KAAKqQ,GAAMxK,EAAM1C,QAAS2H,GAAMgS,EAAGlO,EAAOrP,QAAQ,0BACxD,MACJ,IAAK,UACDuB,EAAMd,KAAKqQ,GAAMxK,EAAM1C,QAAS2Z,EAAEhc,QAClC,MACJ,IAAK,cACDA,EAAMd,KAAKqQ,GAAMxK,EAAM1C,QAAP,UAAmB2Z,EAAEhc,OAArB,OAA6Bgc,EAAEnS,QAC/C,MACJ,IAAK,cACD,IAAMwX,EAAgB,WAAZrF,EAAE1a,MAAqB,IAAO,IACxCtB,EAAMd,KAAKqQ,GAAMxK,EAAM1C,QAASgf,EAAIrF,EAAEhc,MAAQqhB,IAC9C,MACJ,IAAK,eACDrhB,EAAMd,KAAKqQ,GAAMxK,EAAM1C,QAAS2Z,EAAElc,MAAO4gB,GAAQ,MACjD,IAAK,IAAIhlB,EAAI,EAAGsT,EAAKgN,EAAEzgB,UAAUC,OAAQE,EAAIsT,EAAItT,IAC7CsE,EAAQA,EAAMhE,OAAOskB,GAActE,EAAEzgB,UAAUG,GAAIoS,EAAQ/I,GAAO/E,OAC9DtE,IAAMsT,EAAK,GACXhP,EAAMd,KAAKwhB,GAAQ,OAG3B1gB,EAAMd,KAAKwhB,GAAQ,MACnB,MACJ,QACI1gB,EAAMd,KAAK8c,KA5BgC,8BA+BvD,OAAO9V,OAAOC,OAAOD,OAAOC,OAAO,GAAIzH,GAAO,CAAEsB,MAAAA,IAKpD,SAASqf,GAAavR,GAClB,QAAIA,EAAOnM,UACwB,YAAxBmM,EAAOnM,QAAQ7B,OAAmCgO,EAAOnM,QAAQ7B,KAAKkI,WAAW,OAmBhG,IAubMsZ,GAAkB,CACpBC,OAAQ,OACRC,WAAY,OAqDVC,GAAgB,CAClB7iB,KAAM,SACN+b,OAAQ,OACR7R,UArEY,CACf,KAAQ,KACR,OAAU,QACV,QAAW,QACX,YAAe,KACf,QAAW,MAiERqR,SAAU,GACV1b,QAxDmB,CACnB,eAAkB,CACd,IAAK,OAAQ,UAAW,SAAU,IAAK,WAAY,MACnD,MAAO,KAAM,SAAU,OAAQ,OAAQ,MAAO,MAAO,KAAM,OAAQ,IACnE,SAAU,MAAO,QAAS,MAAO,MAAO,QAAS,MAAO,SAAU,IAClE,IAAK,OAAQ,SAAU,QAAS,OAAQ,SAAU,SAAU,MAAO,MACnE,WAAY,KAAM,IAAK,OAE3B,gBAAiB,KACjB,oBAAqB,GACrB,iBAAkB,KAClB,iBAAkB,GAClB,uBAAwB,GACxB,yBAA0B,SAC1B,iBAAiB,EACjB,yBAAyB,EACzB,oBAAqB,CAAC,QACtB,qBAAsB,CAAC,QACvB,qBAAsB,EACtB,yBAAyB,EACzB,2BAA4B,CACxB,kBAAmB,WAAY,QAAS,YACxC,WAAY,UAAW,WAAY,QAAS,WAAY,iBACxD,SAAU,QAAS,OAAQ,WAAY,QAAS,aAAc,WAC9D,WAAY,WAAY,WAAY,iBAExC,4BAA4B,EAC5B,0BAA2B,OAC3B,eAAgB,SAAC4D,EAAOiN,GAAR,OAAwBA,GACxC,cAAe,SAAA/O,GAAI,OAAIA,GACvB,eAAe,EACf,mBAAmB,EACnB,kBAAmB,CAAC,KAAM,SAC1B,iBAAkB,GAClB,gBAAiB,kCACjB,eAAe,EACf,cAAe,KACf,eAAgB,IAChB,eAAe,EACf,sBAAuB,CAAC,OAAQ,UAAW,QAAS,QACpD,sBAAuB,CAAC,UAAW,cAAe,UAAW,cAAe,OAAQ,OAAQ,YAAa,eACzG,uBAAuB,EACvB,qBAAsB,KACtB,mBAAoB,IACpB,qBAAsB,KACtB,uBAAwB,KACxB,yBAA0B,CAAEmhB,EAAG,KAAMxR,EAAG,IAAKyR,EAAG,KAAMvX,EAAG,OACzD,mBAAmB,EACnB,+BAA+B,EAC/B,iCAAkC,IAYhCwX,GAAe,CACjBL,OAAQ,CACJpH,SAAU0H,GA1fG,CACpB,EAAK,UACL,UAAW,kEACX,SAAU,wBACV,SAAU,wBACV,QAAS,sBACT,KAAQ,cACR,cAAe,iBACf,KAAQ,cACR,SAAY,YACZ,GAAM,MACN,MAAS,SACT,GAAM,MACN,IAAO,WACP,QAAS,eACT,QAAS,eACT,IAAO,OACP,KAAQ,6BACR,WAAY,8BACZ,aAAc,0CACd,eAAgB,sEAChB,wBAAyB,iDACzB,aAAc,qDACd,WAAY,6EACZ,YAAa,gFACb,sBAAuB,8CACvB,KAAQ,QACR,WAAY,kEACZ,UAAW,gFACX,cAAe,uDACf,YAAa,sCACb,gBAAiB,oEACjB,UAAW,8BACX,YAAa,iCACb,MAAS,QACT,OAAU,SACV,aAAc,cACd,IAAO,gBACP,mBAAoB,sBACpB,kBAAmB,4BACnB,QAAW,UACX,aAAc,UACd,oBAAqB,mBACrB,sBAAuB,iBACvB,oBAAqB,oCACrB,qBAAsB,uBACtB,qBAAsB,4CACtB,2BAA4B,mCAC5B,4BAA6B,6BAC7B,2BAA4B,0CAC5B,OAAU,4BACV,MAAS,mBACT,OAAU,oBACV,MAAS,qBACT,IAAO,YACP,KAAQ,+BACR,SAAU,sBACV,SAAU,qBACV,SAAU,mBACV,SAAU,mBACV,KAAQ,eACR,WAAY,mBACZ,YAAa,oBACb,MAAS,aACT,MAAS,yBACT,IAAO,2BACP,uBAAwB,0BACxB,qBAAsB,iBACtB,eAAgB,mBAChB,cAAe,kBACf,YAAa,gBACb,yBAA0B,qBAC1B,iBAAkB,qBAClB,aAAc,iBACd,uBAAwB,2BACxB,cAAe,kBACf,aAAc,iBACd,aAAc,iBACd,YAAa,gBACb,eAAgB,mBAChB,cAAe,kBACf,yBAA0B,qBAC1B,sBAAuB,kBACvB,cAAe,kBACf,qBAAsB,iBACtB,uBAAwB,2BACxB,sBAAuB,4BACvB,iCAAkC,2BAClC,cAAe,2BACf,QAAW,WACX,OAAU,4BACV,2BAA4B,oBAC5B,aAAc,gBACd,SAAY,wDACZ,QAAW,8BACX,sBAAuB,qBACvB,sBAAuB,qBACvB,MAAS,aACT,MAAS,aACT,WAAY,2CACZ,OAAU,UACV,QAAW,WACX,+BAAiC,sBACjC,8BAAgC,qBAChC,iCAAmC,oBACnC,4CAA8C,sBAE9C,GAAM,aACN,IAAO,SACP,KAAQ,aACR,IAAO,UACP,IAAO,SACP,IAAO,QACP,IAAO,SACP,IAAO,UACP,KAAQ,WACR,IAAO,WACP,IAAO,SACP,KAAQ,WACR,MAAS,WACT,IAAO,SACP,KAAQ,UACR,IAAO,UACP,IAAO,SACP,IAAO,SACP,IAAO,UACP,IAAO,SACP,IAAO,SACP,KAAQ,WACR,GAAM,OACN,IAAO,WACP,KAAQ,WACR,MAAS,WACT,MAAS,WACT,GAAM,SACN,IAAO,SACP,IAAO,UACP,IAAO,UACP,IAAO,UAEP,cAAe,QACf,mBAAoB,QACpB,cAAe,gBACf,eAAgB,gBAEhB,MAAO,oBACP,IAAO,6IACP,WAAY,UAEZ,EAAK,wBACL,QAAS,uCACT,UAAW,6DAqWRC,MAAO,CACHrjB,QAAS,CACL,0BAA2B,UAGnCsjB,IAAK,CACDtjB,QAAS,CACL,0BAA2B,QAGnC0c,IAAK,CACDhB,SAAU0H,GAvIA,CACd,YAAa,2BACb,WAAY,qBACZ,KAAQ,0BACR,GAAM,mCACN,IAAO,oBACP,IAAO,mBACP,IAAO,oBACP,GAAM,aACN,cAAe,iBACf,GAAM,gBACN,GAAM,eACN,IAAO,kBACP,KAAQ,yBACR,IAAO,qBACP,KAAQ,4BACR,GAAM,8BACN,IAAO,0BACP,KAAQ,oBACR,KAAQ,sBACR,MAAS,0BACT,GAAM,mBACN,GAAM,sBACN,IAAO,uBACP,WAAY,uBACZ,IAAO,WACP,IAAO,cACP,IAAO,4BACP,KAAQ,eACR,IAAO,oBACP,IAAO,mDACP,KAAQ,+BACR,MAAS,4BACT,KAAQ,mCACR,KAAQ,yBACR,OAAU,oCACV,IAAO,uFACP,MAAO,6CAmGHpjB,QAAS,CACL,0BAA2B,QAGnC1D,IAAK,CACD0D,QAAS,CACL,eAAe,IAGvBob,IAAK,CACDM,SAAU0H,GA1GA,CACjB,MAAO,oBA2GJL,WAAY,CACRrH,SAAU0H,GA3XO,CACxB,KAAM,2DACN,MAAO,kXACP,aAAc,qBACd,MAAO,0CACP,YAAa,kCACb,GAAM,qGACN,GAAM,oEACN,KAAQ,uHACR,QAAW,uBACX,QAAW,iEACX,QAAW,6BACX,OAAU,8CACV,OAAU,uCACV,MAAS,iBACT,OAAU,sCACV,OAAU,0HACV,GAAM,kBACN,GAAM,wEACN,EAAK,SACL,GAAM,uCACN,IAAO,8CACP,KAAQ,gCACR,KAAQ,gCACR,KAAQ,qBACR,MAAS,8CACT,OAAU,4BACV,MAAS,+CACT,OAAU,6BACV,KAAQ,sBACR,KAAQ,sBACR,IAAO,yBACP,KAAQ,yCACR,KAAQ,oCACR,IAAO,gEACP,IAAO,yBACP,IAAO,4CACP,KAAQ,8BACR,MAAS,gBACT,KAAQ,8BACR,KAAQ,oBACR,KAAQ,oBACR,IAAO,6CACP,KAAQ,+BACR,KAAQ,+BACR,KAAQ,gBACR,MAAS,qBACT,KAAQ,qBACR,IAAO,2GACP,KAAQ,iBACR,IAAO,2CACP,KAAQ,6BACR,KAAQ,6BACR,MAAS,2CACT,OAAU,yBACV,MAAS,4CACT,OAAU,0BACV,KAAQ,mBACR,KAAQ,mBACR,IAAO,eACP,IAAO,qCACP,GAAM,uBACN,IAAO,qCACP,KAAQ,oDACR,IAAO,6BACP,KAAQ,6DACR,IAAO,6BACP,IAAO,uDACP,IAAO,oCACP,KAAQ,wBACR,KAAQ,wBACR,IAAO,4DACP,KAAQ,gCACR,KAAQ,qEACR,KAAQ,+CACR,EAAK,kBACL,GAAM,oCACN,IAAO,8CACP,GAAM,6BACN,GAAM,aACN,IAAO,oHACP,IAAO,oBACP,KAAQ,UACR,MAAS,eACT,MAAS,cACT,MAAS,aACT,MAAS,cACT,OAAU,oBACV,OAAU,oBACV,OAAU,oBACV,MAAS,cACT,MAAS,eACT,IAAO,gBACP,GAAM,4DACN,IAAO,0BACP,IAAO,oEACP,EAAK,iTACL,GAAM,wBACN,EAAK,gCACL,GAAM,iDACN,IAAO,0CACP,IAAO,iBACP,KAAQ,uCACR,KAAQ,mDACR,GAAM,yDACN,IAAO,oEACP,IAAO,6DACP,IAAO,0CACP,GAAM,wBACN,GAAM,mCACN,IAAO,uDACP,IAAO,oIACP,GAAM,iCACN,IAAO,uDACP,GAAM,yCACN,GAAM,OACN,IAAO,8DACP,IAAO,uDACP,IAAO,YACP,IAAO,YACP,KAAQ,cACR,IAAO,qCACP,IAAO,YACP,KAAQ,mBACR,IAAO,8CACP,IAAO,2CACP,IAAO,sBACP,GAAM,gBACN,GAAM,WACN,IAAO,kBACP,IAAO,eACP,IAAO,kCACP,IAAO,+BACP,IAAO,wDACP,GAAM,OACN,GAAM,cACN,IAAO,oBACP,IAAO,kBACP,GAAM,WACN,IAAO,iBACP,IAAO,eACP,GAAM,YACN,EAAK,SACL,GAAM,uGACN,GAAM,yCACN,GAAM,wCACN,EAAK,OACL,GAAM,yCACN,GAAM,cACN,IAAO,aACP,KAAQ,mBACR,KAAQ,qCACR,KAAQ,0FACR,IAAO,wBACP,EAAK,SACL,IAAO,aACP,IAAO,iBACP,IAAO,YACP,GAAM,gBACN,IAAO,aACP,IAAO,iBACP,IAAO,YACP,GAAM,cACN,GAAM,eACN,GAAM,aACN,GAAM,UACN,IAAO,iCACP,IAAO,iBACP,IAAO,0EACP,IAAO,kCACP,SAAU,UACV,IAAO,QACP,IAAO,iCACP,IAAO,UACP,GAAM,6CACN,IAAO,8DACP,IAAO,+CACP,IAAO,+CACP,EAAK,UACL,GAAM,iBACN,KAAQ,0CACR,KAAQ,2CACR,KAAQ,+BACR,GAAM,eACN,IAAO,mDACP,GAAM,gBACN,GAAM,cACN,EAAK,SACL,IAAO,6CACP,IAAO,6CACP,EAAK,QACL,IAAO,uCACP,EAAK,MACL,GAAM,uCACN,IAAO,oCACP,IAAO,qBACP,GAAM,uDACN,GAAM,yDACN,GAAM,gDACN,GAAM,cACN,GAAM,wFACN,GAAM,uCACN,IAAO,8BACP,GAAM,eACN,IAAO,iWACP,KAAQ,mBACR,KAAQ,8BACR,IAAO,iCACP,MAAS,6BACT,MAAS,gCACT,KAAQ,gCACR,MAAS,qCACT,IAAO,sDACP,GAAM,qDACN,GAAM,8CACN,GAAM,mBACN,EAAK,qCACL,GAAM,2EACN,EAAK,QACL,IAAO,kDACP,KAAQ,oEACR,IAAO,SACP,GAAM,qEACN,IAAO,uCACP,IAAO,eACP,IAAO,yDACP,EAAK,UACL,IAAO,YA0JJG,KAAM,CACFvjB,QAAS,CACL,mBAAoB,KAG5BwjB,OAAQ,CACJxjB,QAAS,CACL,qBAAsB,IACtB,mBAAoB,MAQhC,SAASojB,GAAc1H,GACnB,IAAMxb,EAAS,GAMf,OALAuH,OAAO8Y,KAAK7E,GAAU/E,SAAQ,SAAA8M,GAAK,gBACZA,EAAEpT,MAAM,MADI,IAC/B,2BAAiC,KAAtBhP,EAAsB,QAC7BnB,EAAOmB,GAAQqa,EAAS+H,IAFG,kCAK5BvjB,EAEX,SAASwjB,KAAyC,IAA3BrU,EAA2B,uDAAlB,GAAIsU,EAAc,uDAAJ,GACpCxjB,EAAOkP,EAAOlP,MAAQ,SACtB+b,EAAS7M,EAAO6M,QAAU2G,GAAgB1iB,GAChD,OAAOsH,OAAOC,OAAOD,OAAOC,OAAOD,OAAOC,OAAO,GAAIsb,IAAgB3T,GAAS,CAAElP,KAAAA,EAC5E+b,OAAAA,EAAQ7R,UAAWuZ,GAAWzjB,EAAM+b,EAAQ,YAAa7M,EAAQsU,GAAUjI,SAAUkI,GAAWzjB,EAAM+b,EAAQ,WAAY7M,EAAQsU,GAAU3jB,QAAS4jB,GAAWzjB,EAAM+b,EAAQ,UAAW7M,EAAQsU,KAEzM,SAASC,GAAWzjB,EAAM+b,EAAQY,EAAKzN,GAAsB,IAAdsU,EAAc,uDAAJ,GAC/CE,EAAeV,GAAahjB,GAC5B2jB,EAAeH,EAAQxjB,GACvB4jB,EAAiBZ,GAAajH,GAC9B8H,EAAiBL,EAAQzH,GAC/B,OAAOzU,OAAOC,OAAOD,OAAOC,OAAOD,OAAOC,OAAOD,OAAOC,OAAOD,OAAOC,OAAOD,OAAOC,OAAO,GAAIsb,GAAclG,IAAQ+G,GAAgBA,EAAa/G,IAASiH,GAAkBA,EAAejH,IAASgH,GAAgBA,EAAahH,IAASkH,GAAkBA,EAAelH,IAAQzN,EAAOyN,IAM/R,SAASmH,GAAgBniB,GAAiB,IAAX5D,EAAW,uDAAH,EACnC,MAAO,CAAE4D,KAAAA,EAAM5D,MAAAA,EAAOI,IAAKwD,EAAK/E,QAKpC,SAASmnB,GAAI1kB,GACT,OAAOA,EAAQlB,MAAQkB,EAAQtB,MAKnC,SAASimB,GAAO3kB,GAAqB,IAAZsQ,EAAY,uDAAH,EAC9B,OAAOtQ,EAAQsC,KAAKvD,WAAWiB,EAAQlB,IAAM,EAAIwR,GAKrD,SAASsU,GAAS5kB,GACd,IAAK0kB,GAAI1kB,GACL,OAAOA,EAAQsC,KAAKvD,aAAaiB,EAAQlB,KAMjD,SAAS+lB,GAAQ7kB,EAAShB,GACtB,GAAI0lB,GAAI1kB,GACJ,OAAO,EAEX,IAAMb,EAAsB,oBAAVH,EACZA,EAAM2lB,GAAO3kB,IACbhB,IAAU2lB,GAAO3kB,GAIvB,OAHIb,GACAa,EAAQlB,QAEHK,EAEb,SAAS2lB,GAAa9kB,EAAShB,GAE3B,IADA,IAAMN,EAAQsB,EAAQlB,IACf+lB,GAAQ7kB,EAAShB,KAGxB,OAAOgB,EAAQlB,IAAMJ,EAMzB,SAASqmB,GAAQC,GACb,OAAa,KAANA,GAAoC,KAANA,EAoBzC,IAAMC,IAAU,eACX,GAAmB,KADR,SAEX,GAAkB,KAFP,SAGX,IAAmB,KAHR,GAShB,SAASC,GAAOllB,GACZ,IAAMtB,EAAQsB,EAAQlB,IACtB,IAAK+lB,GAAQ7kB,EAAS,IAClB,OAAO,EAEX,IAAIb,GAAK,EAET,IADA0lB,GAAQ7kB,EAAS,KACT0kB,GAAI1kB,IAAU,CAElB,GADA8kB,GAAa9kB,EAASmlB,IAClBC,GAAaplB,GAAU,CAGvB,GAAI6kB,GAAQ7kB,EAAS,IAAiB,CAElCb,EAAK0lB,GAAQ7kB,EAAS,IACtB,MAEC,GAAI6kB,GAAQ7kB,EAAS,IAAqB,CAE3Cb,GAAK,EACL,MAEC,GAAI0lB,GAAQ7kB,EAASmlB,IAEtB,SAEC,GAAIN,GAAQ7kB,EAAS,IAAkB,CAExC,GAAIolB,GAAaplB,GACb,SAEJ,MAEC,GAAIqlB,GAAkCrlB,GAAU,CAEjDb,GAAK,EACL,MAGJ,MAEJ,IAAImmB,GAAiBtlB,GAGrB,MAGJ,OADAA,EAAQlB,IAAMJ,EACPS,EAMX,SAASmmB,GAAiBtlB,GACtB,OAEJ,SAAyCA,GACrC,IAAMtB,EAAQsB,EAAQlB,IACtB,GAjFJ,SAAuBkB,GACnB,IAAMtB,EAAQsB,EAAQlB,IAChBuE,EAAQuhB,GAAS5kB,GACvB,GAAI+kB,GAAQ1hB,GACR,MAAQqhB,GAAI1kB,IACR,GAAI4kB,GAAS5kB,KAAaqD,GAA6B,KAApBshB,GAAO3kB,GACtC,OAAO,EAKnB,OADAA,EAAQlB,IAAMJ,GACP,EAsEH6mB,CAAcvlB,IAAY6kB,GAAQ7kB,EAAS,KAAoBolB,GAAaplB,GAC5E,OAAO,EAGX,OADAA,EAAQlB,IAAMJ,GACP,EARA8mB,CAAgCxlB,IAAYqlB,GAAkCrlB,GAUzF,SAASqlB,GAAkCrlB,GAGvC,IAFA,IAAMtB,EAAQsB,EAAQlB,IAChBgC,EAAQ,IACN4jB,GAAI1kB,IAAU,CAClB,IAAMf,EAAK0lB,GAAO3kB,GAClB,GAAIylB,GAAexmB,GACf6B,EAAMG,KAAKhC,QAEV,GAAIymB,GAAczmB,IACnB,GAAI6B,EAAMO,QAAU4jB,GAAWhmB,GAE3B,WAGH,IAAK0mB,GAAgB1mB,GACtB,MAEJe,EAAQlB,MAEZ,QAAIJ,IAAUsB,EAAQlB,MAAO+lB,GAAQ7kB,EAAS,MAAoBolB,GAAaplB,MAG/EA,EAAQlB,IAAMJ,GACP,GAKX,SAAS0mB,GAAaplB,GAClB,OAAO8kB,GAAa9kB,EAAS4lB,IAKjC,SAASA,GAAQ3mB,GACb,OAAc,KAAPA,GAAgC,KAAPA,GAKpC,SAAiBA,GAEb,OADAA,IAAM,KACO,IAAMA,GAAM,GAP+B4mB,CAAQ5mB,IAYpE,SAAkBA,GACd,OAAOA,EAAK,IAAMA,EAAK,GAbgD6mB,CAAS7mB,GAkBpF,SAASkmB,GAAalmB,GAClB,OAAc,KAAPA,GAAgC,IAAPA,EAKpC,SAAS0mB,GAAgB1mB,GACrB,OAAQ8mB,MAAM9mB,IAAc,KAAPA,IAA2BkmB,GAAalmB,KAAQ8lB,GAAQ9lB,GAEjF,SAASymB,GAAczmB,GACnB,OAAc,MAAPA,GAAkC,KAAPA,GAAiC,KAAPA,EAEhE,SAASwmB,GAAexmB,GACpB,OAAc,MAAPA,GAAkC,KAAPA,GAAiC,KAAPA,EAGhE,IAAMhB,GAAO,SAACgB,GAAD,OAAQA,EAAGF,WAAW,IAC7BinB,GAAe,iBAAiBnV,MAAM,IAAIkC,IAAI9U,IAC9CgoB,GAAmB,CACrBtlB,KAAM,SACNulB,WAAW,EACXhQ,OAAQ,IA4EZ,SAASiQ,GAAqB5V,EAAMzR,EAAK0B,GAMrC,IAJIukB,GAAQxU,EAAKxR,WAAWD,KACxBA,IAGGsnB,GAAa7V,EAAKxR,WAAWD,GAAM0B,EAAQG,OAC9C7B,IAEJ,OAAOA,EAMX,SAASunB,GAAe9V,EAAMzR,EAAKoX,GAC/B,IAAKA,EACD,OAAO,EAEX,IAGIxV,EAHEV,EAAUykB,GAAgBlU,GAC1B+V,EAAiBpQ,EAAOrF,MAAM,IAAIkC,IAAI9U,IAG5C,IAFA+B,EAAQlB,IAAMA,GAEN4lB,GAAI1kB,IACR,IAAIumB,GAAYvmB,EAAS,GAAkB,MAAqBumB,GAAYvmB,EAAS,IAAkB,KAAvG,CAIA,GADAU,EAASV,EAAQlB,IACb0nB,GAAaxmB,EAASsmB,GACtB,OAAO5lB,EAEXV,EAAQlB,MAEZ,OAAQ,EAKZ,SAASynB,GAAYvmB,EAASsG,EAAO3C,GACjC,IAAMjF,EAAQsB,EAAQlB,IACtB,GAAI+lB,GAAQ7kB,EAASsG,GACjB,MAAQoe,GAAI1kB,IAAU,CAClB,GAAI6kB,GAAQ7kB,EAAS2D,GACjB,OAAO,EAEX3D,EAAQlB,MAIhB,OADAkB,EAAQlB,IAAMJ,GACP,EAKX,SAAS8nB,GAAaxmB,EAAS2J,GAG3B,IAFA,IAAMjL,EAAQsB,EAAQlB,IAClB2nB,GAAW,EACNhpB,EAAIkM,EAAIpM,OAAS,EAAGE,GAAK,IAAMinB,GAAI1kB,IACnC6kB,GAAQ7kB,EAAS2J,EAAIlM,IADwBA,IAIlDgpB,EAAiB,IAANhpB,EAKf,OAHKgpB,IACDzmB,EAAQlB,IAAMJ,GAEX+nB,EAEX,SAASC,GAAeznB,GACpB,OAAQA,EAAK,IAAMA,EAAK,IAChBA,EAAK,IAAMA,EAAK,KAChBA,EAAK,IAAMA,EAAK,IACjB+mB,GAAarU,SAAS1S,GAEjC,SAAS0nB,GAAY1nB,EAAIyd,GACrB,OAAc,KAAPzd,GAAsC,WAAXyd,IAA+B,KAAPzd,GAAkC,MAAPA,GAEzF,SAASmnB,GAAannB,EAAIyd,GACtB,OAAc,KAAPzd,GAAsC,WAAXyd,IAA+B,KAAPzd,GAAkC,MAAPA,GAGzF,SAAS2nB,GAAqBzc,EAAM0F,GAChC,IAAMgX,EAAiB3C,GAAcrU,GACrC,MAA+B,eAAxBgX,EAAelmB,KAiB1B,SAAoBwJ,EAAM0F,GACtB,OAAOkQ,GAAIa,GAAQzW,EAAM0F,GAASA,GAjB5B0T,CAAWpZ,EAAM0c,GAQ3B,SAAgB1c,EAAM0F,GAClB,OAAO4M,GAAUZ,GAAM1R,EAAM0F,GAASA,GARhCyT,CAAOnZ,EAAM0c,GAmBvB,IAiBIC,GAjBAC,GAAU,CACV,WAAc,CAAC,mBAAoB,gBAAiB,cAAe,gBAAiB,eAAgB,gBAAiB,aAAc,MAAO,MAAO,YAAa,kBAAmB,sBAAuB,qBAAsB,sBAAuB,4BAA6B,iBAAkB,uBAAwB,4BAA6B,sBAAuB,aAAc,wBAAyB,wBAAyB,kBAAmB,mBAAoB,mBAAoB,oBAAqB,sBAAuB,wBAAyB,wBAAyB,oBAAqB,kBAAmB,WAAY,aAAc,SAAU,mBAAoB,qBAAsB,yBAA0B,2BAA4B,yBAA0B,2BAA4B,yBAA0B,2BAA4B,gBAAiB,sBAAuB,4BAA6B,6BAA8B,sBAAuB,sBAAuB,kBAAmB,eAAgB,eAAgB,sBAAuB,sBAAuB,qBAAsB,sBAAuB,qBAAsB,oBAAqB,sBAAuB,0BAA2B,4BAA6B,0BAA2B,4BAA6B,0BAA2B,4BAA6B,cAAe,oBAAqB,oBAAqB,oBAAqB,gBAAiB,eAAgB,qBAAsB,qBAAsB,qBAAsB,iBAAkB,eAAgB,aAAc,mBAAoB,yBAA0B,0BAA2B,mBAAoB,mBAAoB,eAAgB,SAAU,uBAAwB,aAAc,aAAc,cAAe,eAAgB,eAAgB,eAAgB,cAAe,QAAS,OAAQ,YAAa,YAAa,QAAS,8BAA+B,eAAgB,cAAe,aAAc,cAAe,oBAAqB,oBAAqB,oBAAqB,UAAW,cAAe,eAAgB,UAAW,UAAW,oBAAqB,gBAAiB,SAAU,YAAa,UAAW,cAAe,oBAAqB,WAAY,OAAQ,eAAgB,YAAa,SAAU,OAAQ,aAAc,iBAAkB,YAAa,YAAa,cAAe,YAAa,QAAS,cAAe,gBAAiB,OAAQ,cAAe,wBAAyB,eAAgB,yBAA0B,YAAa,mBAAoB,eAAgB,aAAc,iBAAkB,eAAgB,0BAA2B,oBAAqB,0BAA2B,yBAA0B,uBAAwB,wBAAyB,cAAe,+BAAgC,6BAA8B,YAAa,oBAAqB,iBAAkB,iBAAkB,cAAe,kBAAmB,kBAAmB,oBAAqB,WAAY,WAAY,eAAgB,eAAgB,iBAAkB,gBAAiB,sBAAuB,wBAAyB,qBAAsB,SAAU,UAAW,oBAAqB,kBAAmB,WAAY,cAAe,YAAa,kBAAmB,UAAW,OAAQ,iBAAkB,iBAAkB,aAAc,cAAe,aAAc,mBAAoB,sBAAuB,kBAAmB,SAAU,mBAAoB,qBAAsB,gBAAiB,oBAAqB,sBAAuB,cAAe,eAAgB,aAAc,SAAU,aAAc,aAAc,eAAgB,YAAa,iBAAkB,aAAc,kBAAmB,YAAa,iBAAkB,aAAc,kBAAmB,YAAa,iBAAkB,SAAU,gBAAiB,cAAe,kBAAmB,iBAAkB,uBAAwB,2BAA4B,0BAA2B,iCAAkC,sBAAuB,4BAA6B,iCAAkC,kBAAmB,2BAA4B,uBAAwB,gCAAiC,yBAA0B,4BAA6B,oBAAqB,0BAA2B,2BAA4B,yBAA0B,iBAAkB,qBAAsB,gBAAiB,qBAAsB,yBAA0B,kBAAmB,gBAAiB,kBAAmB,oBAAqB,kBAAmB,mBAAoB,yBAA0B,yBAA0B,yBAA0B,eAAgB,oBAAqB,6BAA8B,eAAgB,mBAAoB,0BAA2B,uBAAwB,6BAA8B,4BAA6B,6BAA8B,wBAAyB,iBAAkB,wBAAyB,kBAAmB,wBAAyB,2BAA4B,2BAA4B,kCAAmC,kBAAmB,mBAAoB,kBAAmB,eAAgB,wBAAyB,4BAA6B,sBAAuB,yBAA0B,6BAA8B,6BAA8B,wBAAyB,+BAAgC,6BAA8B,aAAc,WAAY,iBAAkB,qBAAsB,gBAAiB,sBAAuB,qBAAsB,iBAAkB,gBAAiB,gBAAiB,gBAAiB,gBAAiB,kBAAmB,wBAAyB,mBAAoB,uBAAwB,iBAAkB,eAAgB,qBAAsB,gBAAiB,oBAAqB,2BAA4B,4BAA6B,4BAA6B,2BAA4B,cAAe,eAAgB,yBAA0B,kBAAmB,uBAAwB,uBAAwB,uBAAwB,uBAAwB,iBAAkB,qBAAsB,kBAAmB,yBAA0B,2BAA4B,2BAA4B,0BAA2B,8BAA+B,4BAA6B,2BAA4B,iCAAkC,2BAA4B,gCAAiC,6BAA8B,4BAA6B,sBAAuB,mBAAoB,yBAA0B,yBAA0B,yBAA0B,yBAA0B,mBAAoB,2BAA4B,2BAA4B,uBAAwB,oBAAqB,oBAAqB,yBAA0B,sBAAuB,qBAAsB,8BAA+B,mBAAoB,yBAA0B,oBAAqB,uBAAwB,8BAA+B,mBAAoB,mBAAoB,gBAAiB,uBAAwB,yBAA0B,yBAA0B,yBAA0B,kBAAmB,iBAAkB,gBAAiB,gBAAiB,kBAAmB,mBAAoB,mBAAoB,WAAY,qBAAsB,WAAY,YAAa,WAAY,YAAa,SAAU,WAAY,eAAgB,qBAAsB,yBAA0B,wBAAyB,yBAA0B,+BAAgC,oBAAqB,0BAA2B,+BAAgC,aAAc,kBAAmB,kBAAmB,gBAAiB,qBAAsB,UAAW,QAAS,UAAW,oBAAqB,cAAe,mBAAoB,eAAgB,sBAAuB,gBAAiB,sBAAuB,yBAA0B,yBAA0B,gCAAiC,mBAAoB,qBAAsB,oBAAqB,sBAAuB,UAAW,gBAAiB,iBAAkB,gBAAiB,gBAAiB,WAAY,gBAAiB,aAAc,aAAc,MAAO,UAAW,iBAAkB,oBAAqB,sBAAuB,qBAAsB,uBAAwB,eAAgB,gBAAiB,cAAe,mBAAoB,oBAAqB,oBAAqB,cAAe,cAAe,qBAAsB,iBAAkB,WAAY,SAAU,SAAU,QAAS,SAAU,QAAS,aAAc,gBAAiB,gBAAiB,YAAa,0BAA2B,wBAAyB,uBAAwB,6BAA8B,uBAAwB,4BAA6B,yBAA0B,wBAAyB,kBAAmB,yBAA0B,0BAA2B,uBAAwB,uBAAwB,mBAAoB,wBAAyB,eAAgB,gBAAiB,kBAAmB,OAAQ,MAAO,aAAc,eAAgB,SAAU,mBAAoB,oBAAqB,iBAAkB,kBAAmB,oBAAqB,iBAAkB,eAAgB,SAAU,SAAU,UAAW,eAAgB,WAAY,aAAc,kBAAmB,cAAe,kBAAmB,wBAAyB,uBAAwB,wBAAyB,cAAe,eAAgB,mBAAoB,gBAAiB,iBAAkB,cAAe,iBAAkB,0BAA2B,MAAO,eAAgB,YAAa,mBAAoB,kBAAmB,aAAc,mBAAoB,sBAAuB,sBAAuB,6BAA8B,eAAgB,gBAAiB,cAAe,iBAAkB,aAAc,oBAAqB,0BAA2B,8BAA+B,6BAA8B,8BAA+B,oCAAqC,yBAA0B,+BAAgC,oCAAqC,qBAAsB,0BAA2B,8BAA+B,0BAA2B,+BAAgC,4BAA6B,uBAAwB,oBAAqB,wBAAyB,mBAAoB,yBAA0B,4BAA6B,qBAAsB,mBAAoB,sBAAuB,qBAAsB,sBAAuB,uBAAwB,uBAAwB,6BAA8B,8BAA+B,8BAA+B,uBAAwB,qBAAsB,sBAAuB,4BAA6B,4BAA6B,4BAA6B,kBAAmB,sBAAuB,uBAAwB,iBAAkB,oBAAqB,oBAAqB,gCAAiC,kBAAmB,qBAAsB,iCAAkC,0BAA2B,uBAAwB,8BAA+B,oBAAqB,qBAAsB,sBAAuB,sBAAuB,oBAAqB,oBAAqB,6BAA8B,wBAAyB,sBAAuB,6BAA8B,0BAA2B,8BAA+B,0BAA2B,2BAA4B,sBAAuB,4BAA6B,4BAA6B,wBAAyB,oBAAqB,2BAA4B,6BAA8B,6BAA8B,6BAA8B,0BAA2B,qBAAsB,2BAA4B,8BAA+B,8BAA+B,qCAAsC,oBAAqB,sBAAuB,sBAAuB,cAAe,SAAU,QAAS,cAAe,aAAc,eAAgB,YAAa,eAAgB,UAAW,SAE72XC,GAAW,CACX,KAAQ,CACJ,OAAQ,OAAQ,OAChB,UAAW,aAAc,KAAM,MAAO,UAAW,UAAW,QAAS,SAAU,SAAU,MAAO,OAAQ,KAAM,KAAM,WAAY,OAAQ,QAAS,WAAY,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,SAAU,WAAY,SAAU,KAAM,IAAK,KAAM,SAAU,SAAU,MAAO,KAAM,MACnR,IAAK,OAAQ,UAAW,OAAQ,IAAK,OAAQ,WAAY,MAAO,MAAO,KAAM,SAAU,UAAW,OAAQ,OAAQ,MAAO,WAAY,MAAO,MAAO,KAAM,OAAQ,IAAK,MAAO,QAAS,MAAO,UAAW,MAAO,QAAS,SAAU,KAAM,OAAQ,MAAO,OAAQ,WAAY,WAAY,SAAU,QAAS,IAAK,IAAK,OAAQ,SAAU,SAAU,QAAS,OAAQ,SAAU,SAAU,QAAS,MAAO,MAAO,QAAS,QAAS,KAAM,WAAY,QAAS,KAAM,QAAS,QAAS,KAAM,KAAM,IAAK,MACle,SAAU,OAAQ,SAAU,YAAa,aAAc,SAAU,UAAW,YAQhFC,GAAkB,IAAIC,IAEtBC,GAAmC,IAAID,IACvCE,GAA6B,0BAE7BC,GAA4B,wBAC5BC,GAAuB,qBACvBC,GAAwB,cACxBC,GAAmBtqB,EAAcA,EAAc,GAAI8pB,GAASS,MAAM,GAAO,CAAC,UAAU,GACpFC,GAAkB,MAClBC,GAAkB,IAClBC,GAAmB,IACnBC,GAAsB,IAS1B,SAASC,GAAWC,EAAQC,EAAOC,EAAUvL,EAAQwL,GACjD,IAAIre,EACAse,EAAkBC,GAAa1L,GAGnC,IAAKyL,EAAiB,CAClB,IAAKlB,GAAgBoB,IAAI3L,GAAS,CAC9B,IAAI4L,EAuPhB,SAA4B5L,GACxB,IAEImK,EAAiB3C,GADC,CAAEvjB,KADP4nB,GAAc7L,GACWA,OAAQA,IAIlD,MAAkB,QAAXA,EAAmB,GAAKmK,EAAe3K,SA7PvBsM,CAAmB9L,GAClCuK,GAAgBwB,IAAI/L,EAAQzU,OAAO8Y,KAAKuH,IAE5CxB,GAA2D,QAAtCjd,EAAKod,GAAgByB,IAAIhM,UAA4B,IAAP7S,EAAgBA,EAAK,GAE5F,IAAI8e,EAAiB,CACjBzC,WAAYiC,EACZxnB,KAAM4nB,GAAc7L,IAEpBkM,EAoRR,SAA6Bb,EAAQC,EAAOC,EAAUznB,GAClD,IAAIqoB,EAAcb,EAAMc,eAAeb,EAASc,YAC5CC,EAA0BH,EAAYI,OAAO,EAAGhB,EAASzX,OAAS,GAClE3G,EAjCR,SAAoBvH,EAAMxD,GAEtB,IADA,IAAIuL,EACK5M,EAAI,EAAGA,EAhRH,EAgRmBA,IAC5B,GAAI6E,EAAK4mB,SAAS,GAAGnrB,OAAO4pB,IAAiB5pB,OAAO2pB,IAAkB5oB,GAClEA,GAAO4oB,GAAgBnqB,OAAS,EAChC8M,EAASA,EAASqd,OAAwBrd,EAASqd,QAElD,GAAIplB,EAAK4mB,SAAS,GAAGnrB,OAAO4pB,IAAiB5pB,OAAO8pB,IAAsB/oB,GAC3EA,GAAO+oB,GAAoBtqB,OAAS,EACpC8M,EAASA,EAASwd,KAA4Bxd,EAASwd,OAEtD,KAAIvlB,EAAK4mB,SAAS,GAAGnrB,OAAO4pB,IAAiB5pB,OAAO6pB,IAAmB9oB,GAKxE,MAJAA,GAAO8oB,GAAiBrqB,OAAS,EACjC8M,EAASA,EAASud,KAAyBvd,EAASud,GAM5D,MAAO,CACH9oB,IAAKA,EACLuL,OAAQA,GAYH8e,CAAWH,EAAyBf,EAASzX,OAAS,GAAI1R,EAAM+K,EAAG/K,IAAKuL,EAASR,EAAGQ,OACzF+e,EAAyB/e,EAASA,EAAO9M,OAAS,EAAI,EACtDmD,EAvfR,SAA+B6P,GAAuC,IAO9DtR,EAP6BH,EAAiC,uDAA3ByR,EAAKhT,OAAQiD,EAAc,uDAAJ,GAExD4c,EAAMnV,OAAOC,OAAOD,OAAOC,OAAO,GAAI+d,IAAmBzlB,GAC/D1B,EAAMwI,KAAK0M,IAAIzD,EAAKhT,OAAQ+J,KAAKC,IAAI,EAAU,MAAPzI,EAAcyR,EAAKhT,OAASuB,IAChEse,EAAI8I,YACJpnB,EAAMqnB,GAAqB5V,EAAMzR,EAAKse,IAG1C,IAAM1e,EAAQ2nB,GAAe9V,EAAMzR,EAAKse,EAAIlH,QAAU,IACtD,IAAe,IAAXxX,EAAJ,CAGA,IAAMsB,EAAUykB,GAAgBlU,EAAM7R,GACtCsB,EAAQlB,IAAMA,EAEd,IADA,IAAMgC,EAAQ,IACN4jB,GAAI1kB,IAAU,CAElB,GADAf,EAAK0lB,GAAO3kB,GACRc,EAAM6Q,SAAS,KAAmB,CAClC,GAAW,MAAP1S,EAAyB,CACzB6B,EAAMG,KAAKhC,GACXe,EAAQlB,MACR,SAEJ,GAAW,MAAPG,EAAyB,CACzBe,EAAQlB,MACR,UAGR,GAAIsnB,GAAannB,EAAIme,EAAIzc,MACrBG,EAAMG,KAAKhC,QAEV,GAAI0nB,GAAY1nB,EAAIme,EAAIzc,OACzB,GAAIG,EAAMO,QAAU4jB,GAAWhmB,GAE3B,UAGH,IAAI6B,EAAM6Q,SAAS,KAAqB7Q,EAAM6Q,SAAS,KAAmB,CAE3E3R,EAAQlB,MACR,SAEC,GAAIomB,GAAOllB,KAAa0mB,GAAeznB,GACxC,MAEJe,EAAQlB,MAEZ,IAAKgC,EAAMvD,QAAUyC,EAAQlB,MAAQA,EAAK,CAGtC,IAAMiM,EAAewF,EAAK1S,MAAMmC,EAAQlB,IAAKA,GAAK6b,QAAQ,WAAY,IACtE,MAAO,CACH5P,aAAAA,EACAse,SAAUvqB,EAAMiM,EAAaxN,OAC7BmB,MAAO8B,EAAQ0V,OACTxX,EAAQ8B,EAAQ0V,OAAO3Y,OACvBuB,EAAMiM,EAAaxN,OACzBoB,IAAKG,KA8bAwqB,CAAsBT,EAAa/pB,EAAK0B,GACrD,IAAKE,EACD,OAEJ,MAAO,CACH6oB,kBAFiB,IAAIxB,EAAOyB,MAAMvB,EAASc,WAAYroB,EAAO2oB,SAAW,EAAGpB,EAASc,WAAYroB,EAAO2oB,SAAW3oB,EAAOqK,aAAaxN,OAAS6rB,EAAyB,GAGzKre,aAAcrK,EAAOqK,aACrBie,wBAAyBA,EACzB3e,OAAQA,GAjSSof,CAAoB1B,EAAQC,EAAOC,EAAUU,GAClE,GAAKC,EAAL,CAEA,IAAIW,EAAoBX,EAAeW,kBAAmBxe,EAAe6d,EAAe7d,aAAcie,EAA0BJ,EAAeI,wBAAyB3e,EAASue,EAAeve,OAC5Lqf,EA6IR,SAAwBV,GACpB,GAAIA,EAAyB,CACzB,IAAIxP,EAAUwP,EAAwBhqB,MAAM,iBAC5C,GAAIwa,EACA,OAAOA,EAAQ,IAjJLmQ,CAAeX,GAEjC,GAAIU,IAAgB3e,IAAgBie,EAAwBE,SAAS,IAAInrB,OAAOgN,KAAmBod,EAAnG,CAGA,IAEIyB,EAFAC,EAyXR,SAA0BnN,EAAQrS,GAC9B,IAAI1J,EAAO4nB,GAAc7L,GACrBoN,EAAUzf,EAASA,EAAOwG,MAAM,KAAKkC,KAAI,SAAU2Q,GAAK,OAAOA,EAAEnZ,UAAa,GAC9Ewf,EAAaD,EAAQnY,SAAS,OAC9BqY,EAAiBF,EAAQnY,SAAS,KAgCtC,MAAO,CACHhR,KAAMA,EACNH,QAjCkB,CAClB,oBAAqB,CAAC,QACtB,qBAAsB,CAAC,QACvB,eAAgBypB,GAChB,qBAAsB,EACtB,yBAAyB,EACzB,4BAA4B,EAC5B,eAAe,EACf,kBAAmBD,EACnB,kBAAmB,CAAC,KAAM,SAC1B,iBAAkB,GAClB,gBAAiB,kCACjB,cAAeD,EACf,cAAe,KACf,eAAgB,IAChB,cAA0B,QAAXrN,EACf,uBAAuB,EACvB,qBAAiC,WAAXA,EAAsB,IAAM,KAClD,mBAA+B,SAAXA,GAAgC,WAAXA,EAAsB,GAAK,IACpE,qBAAsB,KACtB,uBAAwB,KACxB,yBAA0B,CACtB+G,EAAG,KACHxR,EAAG,IACHyR,EAAG,KACHvX,EAAG,OAEP,iCAAkC,GAClC,iBAAiB,EACjB,0BAA2B,QAK3BtB,UAAW,GACXqR,SAAU,GACVQ,OAAQA,EAERpa,UAAMoI,EACNF,UAAW,KAraK0f,CAAiBxN,EAAQrS,GACzC8f,EAAe,GAEfC,EAAkB,GA6BtB,GA1ByB,SAAU1N,EAAQvS,GACvC,GA0RR,SAA6BuS,EAAQ3R,GACjC,IAAKA,EACD,OAAO,EAEX,GAAIqd,GAAa1L,GAAS,CACtB,GAAI3R,EAAa4G,SAAS,KAAM,CAC5B,GAAI5G,EAAahB,WAAW,KAExB,MADoB,uBACC5J,KAAK4K,GAEzB,GAAIyc,GAAiB7V,SAAS5G,EAAavL,UAAU,EAAGuL,EAAa4K,QAAQ,OAC9E,OAAO,EAGf,OAAO2R,GAAqBnnB,KAAK4K,GAErC,GAAIA,EAAahB,WAAW,KACxB,OAAQ,OAAO5J,KAAK4K,GAKxB,IAAK,KAAK5K,KAAK4K,IAAiB,KAAK5K,KAAK4K,MACrC,6CAA6C5K,KAAK4K,KAClD,kBAAkB5K,KAAK4K,KACvB,wBAAwB5K,KAAK4K,KAC7B,kBAAkB5K,KAAK4K,GACxB,OAAO,EAEX,GAAe,QAAX2R,EACA,OAAO2K,GAA0BlnB,KAAK4K,IAAiBwc,GAAsBpnB,KAAK4K,GAEtF,OAAOqc,GAA2BjnB,KAAK4K,IAAiBwc,GAAsBpnB,KAAK4K,GA1T1Esf,CAAoB3N,EAAQ3R,GAAjC,CAEA,IACIof,EAAevD,GAAqBzc,EAAM0f,GAEtC1B,GAAmB,aAAape,WAAWI,KAC3CggB,EAAe,cAGvB,MAAO1G,IACF0G,IAkTb,SAA6BzN,EAAQ3R,EAAcof,EAAc3pB,GAC7D,IAAIqJ,EAAIygB,EAGR,GAAIlC,GAAa1L,IAAWlc,EAAS,CACjC,IAAI+pB,EAAmD,QAAxC1gB,EAAKrJ,EAAQ,6BAA0C,IAAPqJ,EAAgBA,EAAK,KAChFuO,EAA+C,QAAtCkS,EAAK9pB,EAAQ,2BAAwC,IAAP8pB,EAAgBA,EAAK,IAE5EE,EAAiBzf,EAAa4K,QAAQ4U,EAAQ,GAAIjjB,KAAKC,IAAIwD,EAAaxN,OAASgtB,EAAQhtB,OAAQ,IACrGitB,EAAiBA,GAAkB,EAAIA,EAAiBzf,EAAaxN,OACrE,IAAI4M,EAAOY,EAAavL,UAAU,EAAGgrB,GACrC,OAAQL,IAAiB,GAAGpsB,OAAOoM,GAAMpM,OAAOwsB,EAAS,QAAQxsB,OAAOqa,IACpE+R,EAAaxP,QAAQ,MAAO,MAAQ5P,EAAa4P,QAAQ,MAAO,IAAMvC,EAG9E,GAAe,QAAXsE,GAAoB8K,GAAiBte,MAAK,SAAUuhB,GAAO,OAAOA,EAAI1gB,WAAWgB,EAAa6G,kBAC9F,OAAO,EAEX,GAAI4V,GAAiB7V,SAAS5G,EAAa6G,gBAAkBkV,GAAkBnV,SAAS5G,GACpF,OAAO,EAGX,GAAI,QAAQ5K,KAAK4K,KAAkB,QAAQ5K,KAAK4K,KAAkBA,EAAame,SAAS,KACpF,OAAO,EAOX,GAAqB,MAAjBne,EACA,OAAO,EAEX,IAAI2f,EAAa3f,EAAa/L,MAAM,uBACpC,GAAI0rB,EAEA,OAAIA,EAAW,KAAM1D,GAASS,KAAK9V,SAAS+Y,EAAW,IAQ3D,GAAe,QAAXhO,GAAoB,yBAAyBvc,KAAK4K,GAClD,OAAO,EAIX,OAAOof,EAAavY,gBAAkB,IAAI7T,OAAOgN,EAAa6G,cAAe,WAAW7T,OAAOgN,EAAa6G,cAAe,KAnWlG+Y,CAAoBjO,EAAQvS,EAAMggB,EAAcN,EAAcrpB,WAGnFopB,EAAe,CACXgB,KAAM7C,EAAO8C,UAAUC,mBAAmBC,SAC1CC,MAAOjgB,GAAgBV,EAAS,IAAMA,EAAOsQ,QAAQ,IAAK,KAAO,IACjEsQ,cAAeC,GAA2Bf,GAC1CgB,OAAQ,qBACRC,gBAAiBrD,EAAO8C,UAAUQ,6BAA6BC,gBAC/DC,MAAOhC,EACP5gB,WAAY6iB,GAAuBC,GAAgBtB,KAEvDC,EAAkB,CAACR,KAEvB8B,CAAmBhP,EAAQ3R,GACvBod,EAAiB,CAEjB,GAAIpd,EAAaxN,OAAS,GAAKwpB,GAAQ4E,WAAWziB,MAAK,SAAUwa,GAAK,OAAOA,EAAE3Z,WAAWgB,MACtF,MAAO,CAAE6gB,YAAa,GAAIC,YAAY,GAE1C,GAAIjC,GAAgBO,EAAa5sB,OAAQ,CACrCqsB,EAAa2B,MAAQhC,EACrBK,EAAajhB,WAAa6iB,GAAuBC,GAAgBtB,IACjEP,EAAaqB,cAAgBC,GAA2Bf,GACxDP,EAAaoB,MAAuBb,EA2GxBxP,QAAQ,oBAAqB,MAAMA,QAAQ,sBAAuB,MA1G9EiP,EAAakC,WAAa/gB,EAE1B,IAAIghB,EAA+B5E,GAAiCkB,IAAI3L,GAClEyK,GAAiCuB,IAAIhM,GACrCyK,GAAiCuB,IAAI,OAE3C,KADA0B,EAAkB4B,GAAsBjE,EAAyC,OAAjCgE,QAA0E,IAAjCA,EAA0CA,EAA+B,GAAIhhB,EAAcA,EAAcwe,EAAmBM,EAAe,wBAAwB,IACvO5f,MAAK,SAAUyZ,GAAK,OAAOA,EAAE/a,cAAiC,OAAjBihB,QAA0C,IAAjBA,OAA0B,EAASA,EAAajhB,eAAiB,CAIxJ,IAAIsjB,EAAY,IAAIC,OAAO,KACvBnhB,EACK8F,MAAM,IACNkC,KAAI,SAAU2Q,GAAK,MAAc,MAANA,GAAmB,MAANA,EAAY,KAAOA,EAAIA,KAC/D/Y,KAAK,MACV,KAAM,MACN,KAAKxK,KAAK4K,IAAiBkhB,EAAU9rB,KAAKypB,EAAaoB,SACvDZ,EAAgBnpB,KAAK2oB,SAKhC,CACD,IAAIuC,EAA8BphB,EAC9BqhB,EAAgBrhB,EAAa/L,MAAM,oBAIvC,GAHIotB,GAA0C,IAAzBA,EAAc7uB,SAC/B4uB,EAA8BC,EAAc,IAEjC,QAAX1P,EAAkB,CAClB,IAAI2P,EAA6BL,GAAsBjE,EAAQP,GAAkB2E,EAA6BphB,EAAcwe,EAAmBM,EAAe,sBAC9JO,EAAkBA,EAAgBrsB,OAAOsuB,GAE7C,IAAgD,IAA5CnE,EAAYoE,4BAAsC,CAClD,IAAIC,EAA0BP,GAAsBjE,EAAQjB,GAAkBzc,QAAO,SAAUqZ,GAAK,OAAQ8D,GAAiB7V,SAAS+R,MAAQyI,EAA6BphB,EAAcwe,EAAmBM,EAAe,sBAEvND,GAAgB2C,EAAwBhvB,OAAS,GAAK4uB,IAAgCphB,IACtF6e,EAAa4C,SAAW,IAAM5C,EAAaoB,MAC3CuB,EAAwBpV,SAAQ,SAAU/N,GAEtCA,EAAK0iB,WAAa/gB,EAElB3B,EAAKojB,SAAW,IAAMzhB,MAG9Bqf,EAAkBA,EAAgBrsB,OAAOwuB,GAG9B,SAAX7P,GACA0N,EAAgB7sB,QAAU,GAC1BwN,EAAa4G,SAAS,OACJ,OAAjBiY,QAA0C,IAAjBA,OAA0B,EAASA,EAAajhB,cAAgB,IAAI5K,OAAOgN,EAAc,WAAWhN,OAAOgN,EAAc,OACnJqf,EAAkBA,EAAgB/f,QAAO,SAAUjB,GAAQ,OAAOA,EAAK4hB,QAAUjgB,MAMzF,OAH8C,IAA1Cmd,EAAYuE,2BACZrC,EAAgBjT,SAAQ,SAAUuM,GAAK,OAAQA,EAAEkH,KAAO7C,EAAO8C,UAAUC,mBAAmB4B,WAEzFtC,EAAgB7sB,OAAS,CAAEquB,YAAaxB,EAAiByB,YAAY,QAASnhB,IAKzF,SAASshB,GAAsBjE,EAAQ4E,EAAazW,EAAQnL,EAAcwe,EAAmBM,EAAe+C,EAAeC,GAEvH,QADsB,IAAlBA,IAA4BA,GAAgB,IAC3C3W,IAAWyW,EACZ,MAAO,GAEX,IAAIG,EAAqB,GAyBzB,OAxBAH,EAAYxV,SAAQ,SAAU4V,GAC1B,GAAKA,EAAWhjB,WAAWmM,EAAOtE,kBAAmBib,GAAiBE,IAAe7W,EAAOtE,eAA5F,CAGA,IACIgY,EADAoD,EAAcjiB,EAAegiB,EAAW9D,OAAO/S,EAAO3Y,QAE1D,IACIqsB,EAAehD,GAAqBoG,EAAanD,GAErD,MAAOpG,IACP,GAAKmG,EAAL,CAGA,IAAIxgB,EAAO,CACPwhB,KAAM7C,EAAO8C,UAAUC,mBAAmBC,SAC1CC,MAAO9U,EAAS6W,EAAW9D,OAAO/S,EAAO3Y,QACzC0tB,cAAeC,GAA2BtB,GAC1CuB,OAAQyB,EACRxB,gBAAiBrD,EAAO8C,UAAUQ,6BAA6BC,gBAC/DC,MAAOhC,EACP5gB,WAAY6iB,GAAuBC,GAAgB7B,KAEvDkD,EAAmB7rB,KAAKmI,QAErB0jB,EAUX,SAAS5B,GAA2B+B,GAChC,OAAOA,EAAatS,QAAQ,oBAAqB,OAAOA,QAAQ,sBAAuB,MAK3F,SAAS6Q,GAAuBlpB,GAC5B,OAAOA,EAAOA,EAAKqY,QAAQ,sBAAuB,YAAcrY,EAEpE,SAASmpB,GAAgBnpB,GACrB,IAAKA,IAASA,EAAKiI,OACf,OAAOjI,EAEX,IAAI4qB,GAAc,EACdC,EAAmB,GACnBC,GAAgB,EAChBC,GAAsB,EACtB5vB,EAAI,EACJ8B,EAAI+C,EAAK/E,OACb,IACI,KAAOE,EAAI8B,IAAM6tB,GAEb,GAAiB,KAAb9qB,EAAK7E,MAA4B,KAAb6E,EAAK7E,KAA7B,CAMA,IAFA,IAAI6vB,GAAe,EACfC,GAAa,EACV9vB,EAAI8B,GAAK,KAAKY,KAAKmC,EAAK7E,KAC3B6vB,EAAcA,EAAc,EAAI7vB,EAAI6vB,EACpCC,EAAY9vB,EAAI,EAChBA,IAGJ,MAAqB,IAAjB6vB,IAAqC,IAAfC,GAAoB9vB,GAAK8B,GAAiB,KAAX+C,EAAK7E,IAAwB,KAAX6E,EAAK7E,IAAhF,CAIA,IAAI+vB,EAAiBlrB,EAAK9C,UAAU8tB,EAAaC,GAEjD,GADAH,EAAmC,MAAnBI,EAEZ,MAEJ,IAAIC,GAAmB,EACvB,GAAiB,KAAbnrB,EAAK7E,KAEL,KAAOA,EAAI8B,GAAG,CACV,GAAe,KAAX+C,EAAK7E,GAAW,CAChBgwB,GAAmB,EACnB,MAEJhwB,IAIJ6G,OAAOkpB,GAAkBlpB,OAAO4oB,IAChCA,EAAa5oB,OAAOkpB,GACpBL,EAAmB,CAAC,CAAEG,YAAaA,EAAaC,UAAWA,IAC3DF,GAAuBI,GAElBnpB,OAAOkpB,KAAoBN,GAChCC,EAAiBlsB,KAAK,CAAEqsB,YAAaA,EAAaC,UAAWA,MAIzE,MAAO9J,IACP,GAAI4J,IAAwBD,EACxB,IAAK,IAAIM,EAAM,EAAGA,EAAMP,EAAiB5vB,OAAQmwB,IAAO,CACpD,IAAIC,EAAaR,EAAiBO,GAAKJ,YACnCM,EAAWT,EAAiBO,GAAKH,UACrCjrB,EAAOA,EAAK2mB,OAAO,EAAG0E,GAAc,IAAMrrB,EAAK2mB,OAAO2E,GAG9D,OAAOtrB,EAEX,IAAI2nB,GAAoB,SAAU7lB,EAAOiN,GAAe,MAAO,KAAKtT,OAAOqG,GAAOrG,OAAOsT,EAAc,IAAMA,EAAc,GAAI,MAE/H,SAAS+W,GAAa1L,GAClB,MAAkB,QAAXA,EAGX,SAAS6L,GAAc7L,GACnB,OAAO0L,GAAa1L,GAAU,aAAe,SAkOjD,SAASmR,GAAkBhuB,EAAQuE,EAAOsY,EAAQoR,GAC9C,IAAIC,EAAmBluB,EAAOuE,GAAOzD,KACrC,MAAe,SAAX+b,EAE8B,KAArBqR,IAAsC,IAAV3pB,GAA0C,mBAA3BvE,EAAOuE,EAAQ,GAAGzD,OAE/C,oBAAnBd,EAAO,GAAGc,KAEH,QAAX+b,EACyB,KAArBqR,GAGGA,IAAqB,OAASD,EAE1B,QAAXpR,MAEUtY,GACN,CAAC,gBAAiB,qBAAsB,gBAAiB,sBAAsBuN,SAASoc,IA4BpG,IAAIC,GAAiB,CACjBpV,KAAM,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KACjGqV,KAAM,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KACjGtS,KAAM,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KACjGD,KAAM,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KACjGoI,IAAK,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KACtF5G,IAAK,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAC3F6C,IAAK,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAClEmO,KAAM,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KACnEnK,KAAM,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAC9DoK,KAAM,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KACnEnK,OAAQ,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAChEoK,WAAY,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAClGC,WAAY,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,MAGlGC,GAAe,CACfC,WAAY,OACZC,IAAK,OACLC,KAAM,QAENC,GAAiB,CACjBC,yBAA0B,SAC1BrC,6BAA6B,EAC7BG,2BAA2B,GAU/B,SAASmC,GAAiB7G,EAAQ8C,EAAWnO,GACzC,GAAKqL,EAAL,CAIA,IAAI8G,EAAYhE,EAAU9X,KAAI,SAAU+a,GACpC,OAAO/F,EAAO8C,UAAUiE,+BAA+BhB,EAAU,CAC7DiB,kBAAmBf,GAAeM,GAAaR,IAAaA,GAC5DkB,uBAAwB,SAAUhH,EAAOC,GACrC,OAjEhB,SAA6CD,EAAOC,EAAUvL,EAAQoR,GAYlE,IAXA,IAAItd,EAASyX,EAASzX,OAAQuY,EAAad,EAASc,WAEhDkG,EAAgBjH,EAAMiH,cACtBC,EAA0BD,EAAcC,wBAExCC,EAAuBD,EAAwBE,qBAAuBH,EAAcE,qBACpFroB,EAAQooB,EAAwBG,cAActG,EAAa,GAAGuG,QAE9DzvB,EADqBsvB,EAAqBhgB,SAAS6Y,EAAMc,eAAeC,IAAa,EAAMjiB,EAAO,GACtEjH,OAC5B0vB,GAAQ,EAEH9xB,EAAIoC,EAAOtC,OAAS,EAAGE,GAAK,EAAGA,IACpC,GAAI+S,EAAS,EAAI3Q,EAAOpC,GAAG6S,OAAQ,CAC/Bif,EAAQ1B,GAAkBhuB,EAAQpC,EAAGif,EAAQoR,GAC7C,MAGR,OAAOyB,EA+CYC,CAAoCxH,EAAOC,EAAUvL,EAAQoR,GAC9DhG,GAAWC,EAAQC,EAAOC,EAAUvL,EAAQgS,SAC5ChkB,QAIlB,OAAO,WACHmkB,EAAU1X,SAAQ,SAAUsY,GAAY,OAAOA,EAASC,cAdxDC,QAAQlrB,MAAM,8FAiBtB,SAASmrB,GAAU7H,EAAQ8C,GAGvB,YAFe,IAAX9C,IAAqBA,EAAS8H,OAAO9H,aACvB,IAAd8C,IAAwBA,EAAY,CAAC,SAClC+D,GAAiB7G,EAAQ8C,EAAW,QAE/C,SAASiF,GAAS/H,EAAQ8C,GAGtB,YAFe,IAAX9C,IAAqBA,EAAS8H,OAAO9H,aACvB,IAAd8C,IAAwBA,EAAY,CAAC,QAClC+D,GAAiB7G,EAAQ8C,EAAW,OAE/C,SAASkF,GAAShI,EAAQ8C,GAGtB,YAFe,IAAX9C,IAAqBA,EAAS8H,OAAO9H,aACvB,IAAd8C,IAAwBA,EAAY,CAAC,eAClC+D,GAAiB7G,EAAQ8C,EAAW,kGCxlL3CmF,EAA2B,qBAAXH,OAAyBA,OAAS,KAClDI,EAAiB,OAAXD,EACNE,EAAYD,OAAwBvlB,EAAlBslB,EAAOE,SAUzBC,EAAa,aACbC,EAAO,WAAc,OAAO,GAO5BC,EAAOJ,EACL,OACE,CAAC,GAAI,WAAY,QAAS,OACvB5lB,QAAO,SAAU6L,GACd,IAAIoa,EAAKJ,EAASK,cAAc,OAGhC,OAFAD,EAAGE,MAAMC,QAAU,SAAWva,EAAS,cAE9Boa,EAAGE,MAAMjzB,UAErBkM,QAAW,OAGlBinB,EAAW,SAAU3S,GAAK,MAAoB,kBAANA,GAAkBA,aAAatW,QAKvEkpB,EAAoB,SAAUL,GAC9B,GAAII,EAASJ,GAAK,CACd,IAAIM,EAAMV,EAASW,cAAcP,GACjC,IAAKM,EACD,MAAM,IAAIjxB,MAAO,YAAc2wB,EAAK,gCAExC,OAAOM,EAGX,OAAON,GAIPQ,EAAY,SAAUtwB,EAASmhB,EAAUoP,GACzC,IAAIhvB,EAAQvB,EAAQmhB,GACpB,YAAcjX,IAAV3I,EACOA,EAEJgvB,GAGPC,EAAgB,SAAUC,EAAYC,EAASC,EAAQC,GACvD,GAAIF,EAAS,CACT,GAAoB,QAAhBE,EACA,OAAO,EAEX,GAAoB,WAAhBA,EACA,OAAOH,EAAa,OAErB,GAAIE,EAAQ,CACf,GAAoB,UAAhBC,EACA,OAAO,EAEX,GAAoB,WAAhBA,EACA,OAAOH,EAAa,EAI5B,OAAOA,GAIPI,EAAkB,SAAU5zB,EAAG6zB,GAC/B,IAAIC,EAAMrB,EAASK,cAAc,OAEjC,OADAgB,EAAIpc,UAAY,iBAAmBmc,EAC5BC,GAGPC,EAAwB,SAAUC,EAAK3xB,EAAM4xB,GAC7C,IAAIlB,EAAQ,GAQZ,OANKE,EAAS5wB,GAGV0wB,EAAMiB,GAAO3xB,EAFb0wB,EAAMiB,GAAOpB,EAAO,IAAMvwB,EAAO,OAAS4xB,EAAU,MAKjDlB,GAGPmB,EAAuB,SAAUF,EAAKC,GACtC,IAAIE,EAEJ,OAAUA,EAAM,IAAQH,GAAQC,EAAU,KAAOE,GA4pBrD,EA9nBY,SAAUC,EAAWrxB,GAG7B,QAFiB,IAAZA,IAAqBA,EAAU,IAEhCyvB,EAAO,MAAO,GAElB,IACI6B,EACAC,EACA9J,EACA+J,EACAC,EACArxB,EANAsxB,EAAML,EASNl0B,MAAMP,OACN80B,EAAMv0B,MAAMP,KAAK80B,IAMrB,IACIptB,EADe6rB,EAAkBuB,EAAI,IACfC,WACtBC,EAAcC,iBAAmBA,iBAAiBvtB,GAAU,KAC5DwtB,EAAsBF,EAAcA,EAAYG,cAAgB,KAGhEC,EAAQ1B,EAAUtwB,EAAS,UAAY0xB,EAAInf,KAAI,WAAc,OAAO,IAAMmf,EAAI30B,UAI9Ek1B,EAAU3B,EAAUtwB,EAAS,UAAW,KACxCkyB,EAAW/0B,MAAMgF,QAAQ8vB,GAAWA,EAAUP,EAAInf,KAAI,WAAc,OAAO0f,KAC3EE,EAAU7B,EAAUtwB,EAAS,UAAWoyB,EAAAA,GACxCC,EAAWl1B,MAAMgF,QAAQgwB,GAAWA,EAAUT,EAAInf,KAAI,WAAc,OAAO4f,KAG3EG,EAAchC,EAAUtwB,EAAS,eAAe,GAChDywB,EAAaH,EAAUtwB,EAAS,aAAc,IAC9C4wB,EAAcN,EAAUtwB,EAAS,cAAe,UAChDuyB,EAAajC,EAAUtwB,EAAS,aAAc,IAC9CwyB,EAAcr1B,MAAMgF,QAAQowB,GAAcA,EAAab,EAAInf,KAAI,WAAc,OAAOggB,KACpFE,EAAenC,EAAUtwB,EAAS,eAAgB,GAClD0yB,EAAYpC,EAAUtwB,EAAS,YAAa2vB,GAC5CgD,EAASrC,EACTtwB,EACA,SACA0yB,IAAc/C,EAAa,aAAe,cAE1CiD,EAAStC,EAAUtwB,EAAS,SAAU6wB,GACtCgC,EAAevC,EACftwB,EACA,eACAgxB,GAEA8B,EAAcxC,EAAUtwB,EAAS,cAAemxB,GA8BpD,SAAS4B,EAAejD,EAAIxwB,EAAM4xB,EAASj0B,GAKvC,IAAI+yB,EAAQ6C,EAAavB,EAAWhyB,EAAM4xB,EAASj0B,GAEnDwK,OAAO8Y,KAAKyP,GAAOrZ,SAAQ,SAAUqc,GAEjClD,EAAGE,MAAMgD,GAAQhD,EAAMgD,MAa/B,SAASC,IACL,OAAO7yB,EAASmS,KAAI,SAAU+F,GAAW,OAAOA,EAAQhZ,QAK5D,SAAS4zB,EAAiBjQ,GACtB,MAAI,YAAaA,EAAYA,EAAEkQ,QAAQ,GAAG5B,GACnCtO,EAAEsO,GASb,SAAS6B,EAAOtjB,GACZ,IAAIhE,EAAI1L,EAAShC,KAAK0N,GAClBD,EAAIzL,EAAShC,KAAKyN,GAClBwnB,EAAavnB,EAAExM,KAAOuM,EAAEvM,KAE5BwM,EAAExM,KAAQwQ,EAAS1R,KAAKkB,KAAQ+zB,EAChCxnB,EAAEvM,KAAO+zB,EAAcvjB,EAAS1R,KAAKkB,KAAQ+zB,EAE7CN,EAAejnB,EAAEwM,QAASxM,EAAExM,KAAMlB,KAAA,GAAmB0N,EAAE7O,GACvD81B,EAAelnB,EAAEyM,QAASzM,EAAEvM,KAAMlB,KAAA,GAAmByN,EAAE5O,GAiB3D,SAASq2B,EAAKrQ,GACV,IAAInT,EACAhE,EAAI1L,EAAShC,KAAK0N,GAClBD,EAAIzL,EAAShC,KAAKyN,GAEjBzN,KAAKm1B,WAKVzjB,EACIojB,EAAiBjQ,GACjB7kB,KAAKF,OACJE,KAAA,GAAoBA,KAAKo1B,YAE1Bf,EAAe,IACf3iB,EAAShJ,KAAK2sB,MAAM3jB,EAAS2iB,GAAgBA,GAM7C3iB,GAAUhE,EAAEmmB,QAAUnmB,EAAEymB,WAAan0B,KAAA,GACrC0R,EAAShE,EAAEmmB,QAAU7zB,KAAA,GAErB0R,GACA1R,KAAKkB,MAAQuM,EAAEomB,QAAUpmB,EAAE0mB,WAAan0B,KAAA,MAExC0R,EAAS1R,KAAKkB,MAAQuM,EAAEomB,QAAU7zB,KAAA,KAGlC0R,GAAUhE,EAAEqmB,QAAUrmB,EAAEymB,WAAan0B,KAAA,GACrC0R,EAAShE,EAAEqmB,QAAU/zB,KAAA,GAErB0R,GACA1R,KAAKkB,MAAQuM,EAAEsmB,QAAUtmB,EAAE0mB,WAAan0B,KAAA,MAExC0R,EAAS1R,KAAKkB,MAAQuM,EAAEsmB,QAAU/zB,KAAA,KAItCg1B,EAAO91B,KAAKc,KAAM0R,GAIlBwgB,EAAUtwB,EAAS,SAAU4vB,EAA7BU,CAAmC2C,MAgBvC,SAASS,IAEL,IAAI5nB,EAAI1L,EAAShC,KAAK0N,GAAGwM,QACrBzM,EAAIzL,EAAShC,KAAKyN,GAAGyM,QAErBqb,EAAU7nB,EAAC,wBACX8nB,EAAU/nB,EAAC,wBAEfzN,KAAKkB,KACDq0B,EAAQrC,GACRsC,EAAQtC,GACRlzB,KAAA,GACAA,KAAA,GACJA,KAAKF,MAAQy1B,EAAQlM,GACrBrpB,KAAKD,IAAMw1B,EAAQnC,GAiCvB,SAASqC,EAAUC,GAGf,IAAIC,EAjCR,SAAmBzb,GAGf,IAAKuZ,iBAAoB,OAAO,KAEhC,IAAImC,EAAgBnC,iBAAiBvZ,GAErC,IAAK0b,EAAiB,OAAO,KAE7B,IAAI10B,EAAOgZ,EAAQmZ,GAEnB,OAAa,IAATnyB,EAAqB,KAGrBA,GADAozB,IAAc/C,EAEVsE,WAAWD,EAAcE,aACzBD,WAAWD,EAAcG,cAGzBF,WAAWD,EAAcI,YACzBH,WAAWD,EAAcK,eAahBC,CAAUhwB,GAC3B,GAAmB,OAAfyvB,EACA,OAAOD,EAGX,GAAI5B,EAASqC,QAAO,SAAUzoB,EAAGD,GAAK,OAAOC,EAAID,IAAM,GAAKkoB,EACxD,OAAOD,EAKX,IAAIU,EAAe,EACfC,EAAU,GAEVC,EAAaZ,EAAYvhB,KAAI,SAAUjT,EAAMrC,GAE7C,IAAI03B,EAAaZ,EAAaz0B,EAAQ,IAClCs1B,EAAoBpE,EACpBC,EACM,IAANxzB,EACAA,IAAM62B,EAAY/2B,OAAS,EAC3B6zB,GAEAiE,EAAiB3C,EAASj1B,GAAK23B,EAInC,OAAID,EAAYE,GACZL,GAAgBK,EAAiBF,EACjCF,EAAQh0B,KAAK,GACNo0B,IAIXJ,EAAQh0B,KAAKk0B,EAAYE,GAClBF,MAIX,OAAqB,IAAjBH,EACOV,EAGJY,EAAWniB,KAAI,SAAUoiB,EAAW13B,GACvC,IAAI63B,EAAeH,EAInB,GAAIH,EAAe,GAAKC,EAAQx3B,GAAKu3B,EAAe,EAAG,CACnD,IAAIO,EAAcjuB,KAAK0M,IACnBghB,EACAC,EAAQx3B,GAAKu3B,GAIjBA,GAAgBO,EAChBD,EAAeH,EAAYI,EAI/B,OAAQD,EAAef,EAAc,OAK7C,SAASiB,IACL,IAAIC,EAAO72B,KACP0N,EAAI1L,EAAS60B,EAAKnpB,GAAGwM,QACrBzM,EAAIzL,EAAS60B,EAAKppB,GAAGyM,QAErB2c,EAAK1B,UACLjD,EAAUtwB,EAAS,YAAa4vB,EAAhCU,CAAsC2C,KAG1CgC,EAAK1B,UAAW,EAGhB/D,EAAM,oBAAsB,UAAWyF,EAAKC,MAC5C1F,EAAM,oBAAsB,WAAYyF,EAAKC,MAC7C1F,EAAM,oBAAsB,cAAeyF,EAAKC,MAChD1F,EAAM,oBAAsB,YAAayF,EAAKE,MAC9C3F,EAAM,oBAAsB,YAAayF,EAAKE,MAG9CF,EAAKC,KAAO,KACZD,EAAKE,KAAO,KAEZrpB,EAAC,oBAAsB,cAAe8jB,GACtC9jB,EAAC,oBAAsB,YAAa8jB,GACpC/jB,EAAC,oBAAsB,cAAe+jB,GACtC/jB,EAAC,oBAAsB,YAAa+jB,GAEpC9jB,EAAEkkB,MAAMoF,WAAa,GACrBtpB,EAAEkkB,MAAMqF,iBAAmB,GAC3BvpB,EAAEkkB,MAAMsF,cAAgB,GACxBxpB,EAAEkkB,MAAMuF,cAAgB,GAExB1pB,EAAEmkB,MAAMoF,WAAa,GACrBvpB,EAAEmkB,MAAMqF,iBAAmB,GAC3BxpB,EAAEmkB,MAAMsF,cAAgB,GACxBzpB,EAAEmkB,MAAMuF,cAAgB,GAExBN,EAAKrC,OAAO5C,MAAM2C,OAAS,GAC3BsC,EAAK3wB,OAAO0rB,MAAM2C,OAAS,GAC3BjD,EAAS8F,KAAKxF,MAAM2C,OAAS,GAMjC,SAAS8C,EAAcxS,GAEnB,KAAI,WAAYA,IAAkB,IAAbA,EAAEyS,OAAvB,CAKA,IAAIT,EAAO72B,KACP0N,EAAI1L,EAAS60B,EAAKnpB,GAAGwM,QACrBzM,EAAIzL,EAAS60B,EAAKppB,GAAGyM,QAGpB2c,EAAK1B,UACNjD,EAAUtwB,EAAS,cAAe4vB,EAAlCU,CAAwC2C,KAI5ChQ,EAAE0S,iBAGFV,EAAK1B,UAAW,EAIhB0B,EAAKE,KAAO7B,EAAKsC,KAAKX,GACtBA,EAAKC,KAAOF,EAAaY,KAAKX,GAG9BzF,EAAM,iBAAmB,UAAWyF,EAAKC,MACzC1F,EAAM,iBAAmB,WAAYyF,EAAKC,MAC1C1F,EAAM,iBAAmB,cAAeyF,EAAKC,MAC7C1F,EAAM,iBAAmB,YAAayF,EAAKE,MAC3C3F,EAAM,iBAAmB,YAAayF,EAAKE,MAG3CrpB,EAAC,iBAAmB,cAAe8jB,GACnC9jB,EAAC,iBAAmB,YAAa8jB,GACjC/jB,EAAC,iBAAmB,cAAe+jB,GACnC/jB,EAAC,iBAAmB,YAAa+jB,GAEjC9jB,EAAEkkB,MAAMoF,WAAa,OACrBtpB,EAAEkkB,MAAMqF,iBAAmB,OAC3BvpB,EAAEkkB,MAAMsF,cAAgB,OACxBxpB,EAAEkkB,MAAMuF,cAAgB,OAExB1pB,EAAEmkB,MAAMoF,WAAa,OACrBvpB,EAAEmkB,MAAMqF,iBAAmB,OAC3BxpB,EAAEmkB,MAAMsF,cAAgB,OACxBzpB,EAAEmkB,MAAMuF,cAAgB,OAGxBN,EAAKrC,OAAO5C,MAAM2C,OAASA,EAC3BsC,EAAK3wB,OAAO0rB,MAAM2C,OAASA,EAC3BjD,EAAS8F,KAAKxF,MAAM2C,OAASA,EAG7Be,EAAep2B,KAAK23B,GAGpBA,EAAKzB,WAAaN,EAAiBjQ,GAAKgS,EAAK92B,KAlX7Cu0B,IAAc/C,GACd2B,EAAY,QACZC,EAAa,UACb9J,EAAW,OACX+J,EAAc,QACdC,EAAa,eACQ,aAAdiB,IACPpB,EAAY,SACZC,EAAa,UACb9J,EAAW,MACX+J,EAAc,SACdC,EAAa,gBA2WjBO,EAAQ6B,EAAU7B,GAsBlB,IAAI6D,EAAQ,GAgGZ,SAASC,EAAYxd,GACjB,IAAIqY,EAASrY,EAAQrb,IAAM44B,EAAM94B,OAC7Bg5B,EAAOpF,EAASkF,EAAMvd,EAAQrb,EAAI,GAAK44B,EAAMvd,EAAQrb,GAEzDy2B,EAAep2B,KAAKy4B,GAEpB,IAAIz2B,EAAOqxB,EACLoF,EAAKz2B,KAAOgZ,EAAQ2Z,QAAU8D,EAAI,GAClCzd,EAAQ2Z,QAAU8D,EAAI,GAE5B3C,EAAO91B,KAAKy4B,EAAMz2B,GAgEtB,OAzKAc,EAAWsxB,EAAInf,KAAI,SAAU3M,EAAI3I,GAE7B,IASI84B,EATAzd,EAAU,CACVA,QAAS6X,EAAkBvqB,GAC3BtG,KAAM0yB,EAAM/0B,GACZg1B,QAASC,EAASj1B,GAClBk1B,QAASE,EAASp1B,GAClBs1B,WAAYC,EAAYv1B,GACxBA,EAAGA,GAKP,GAAIA,EAAI,KAEJ84B,EAAO,CACHjqB,EAAG7O,EAAI,EACP4O,EAAG5O,EACHs2B,UAAU,EACVb,UAAWA,EACXpuB,OAAQA,IAGR,GAAgBksB,EAChBC,EACAxzB,EAAI,IAAM,GACV,EACA2zB,GAEJmF,EAAI,GAAgBvF,EAChBC,GACA,EACAxzB,IAAMy0B,EAAI30B,OAAS,EACnB6zB,GAKwB,gBAAxBkB,GACwB,mBAAxBA,GACF,CACE,IAAIkE,EAAOD,EAAKjqB,EAChBiqB,EAAKjqB,EAAIiqB,EAAKlqB,EACdkqB,EAAKlqB,EAAImqB,EASjB,GAAI/4B,EAAI,EAAG,CACP,IAAIg5B,EAAgBrD,EAAO31B,EAAGy1B,EAAWpa,EAAQA,UA5ZzD,SAAuB2d,EAAe/E,EAASj0B,GAC3C,IAAI+yB,EAAQ8C,EAAYxB,EAAWJ,EAASj0B,GAE5CwK,OAAO8Y,KAAKyP,GAAOrZ,SAAQ,SAAUqc,GAEjCiD,EAAcjG,MAAMgD,GAAQhD,EAAMgD,MAwZlCkD,CAAcD,EAAexF,EAAYxzB,GAGzC84B,EAAI,GAAwBN,EAAcG,KAAKG,GAG/CE,EAAa,iBACT,YACAF,EAAI,IAERE,EAAa,iBACT,aACAF,EAAI,IAGRzxB,EAAO6xB,aAAaF,EAAe3d,EAAQA,SAE3Cyd,EAAKnD,OAASqD,EAqBlB,OAlBAlD,EACIza,EAAQA,QACRA,EAAQhZ,KACRkxB,EACIC,EACM,IAANxzB,EACAA,IAAMy0B,EAAI30B,OAAS,EACnB6zB,GAEJ3zB,GAKAA,EAAI,GACJ44B,EAAMp1B,KAAKs1B,GAGRzd,MAgBF3B,SAAQ,SAAU2B,GACvB,IAAI8d,EAAe9d,EAAQA,QAAR,wBAAyCgZ,GAExD8E,EAAe9d,EAAQ2Z,UACnBK,EACAwD,EAAYxd,GAGZA,EAAQ2Z,QAAUmE,MAqDvB,CACHC,SAjDJ,SAAkBC,GACd,IAAIC,EAAU1C,EAAUyC,GACxBC,EAAQ5f,SAAQ,SAAU6f,EAASv5B,GAC/B,GAAIA,EAAI,EAAG,CACP,IAAI84B,EAAOF,EAAM54B,EAAI,GAEjB6O,EAAI1L,EAAS21B,EAAKjqB,GAClBD,EAAIzL,EAAS21B,EAAKlqB,GAEtBC,EAAExM,KAAOi3B,EAAQt5B,EAAI,GACrB4O,EAAEvM,KAAOk3B,EAETzD,EAAejnB,EAAEwM,QAASxM,EAAExM,KAAMy2B,EAAI,GAAejqB,EAAE7O,GACvD81B,EAAelnB,EAAEyM,QAASzM,EAAEvM,KAAMy2B,EAAI,GAAelqB,EAAE5O,QAqC/Dg2B,SAAUA,EACVwD,SAAU,SAAkBx5B,GACxB64B,EAAY11B,EAASnD,KAEzBy5B,QApCJ,SAAiBC,EAAgBC,GAC7Bf,EAAMlf,SAAQ,SAAUof,GAcpB,IAbuB,IAAnBa,EACAb,EAAKzxB,OAAOuyB,YAAYd,EAAKnD,SAE7BmD,EAAKnD,OAAL,oBACI,YACAmD,EAAI,IAERA,EAAKnD,OAAL,oBACI,aACAmD,EAAI,MAIW,IAAnBY,EAAyB,CACzB,IAAI3G,EAAQ6C,EACRvB,EACAyE,EAAKjqB,EAAExM,KACPy2B,EAAI,IAGRtuB,OAAO8Y,KAAKyP,GAAOrZ,SAAQ,SAAUqc,GACjC5yB,EAAS21B,EAAKjqB,GAAGwM,QAAQ0X,MAAMgD,GAAQ,GACvC5yB,EAAS21B,EAAKlqB,GAAGyM,QAAQ0X,MAAMgD,GAAQ,WAanD1uB,OAAQA,EACRuxB,MAAOA,IC5vBf,SAASiB,EAAyB1F,EAAK2F,GAAW,IAAIhvB,EAAS,GAAI,IAAK,IAAI0b,KAAK2N,EAAS3pB,OAAOrK,UAAU45B,eAAe15B,KAAK8zB,EAAK3N,KAA8B,IAAxBsT,EAAQ5hB,QAAQsO,KAAW1b,EAAO0b,GAAK2N,EAAI3N,IAAI,OAAO1b,EAEhM,IAAIkvB,EAA6B,SAAUC,GACvC,SAASD,IACLC,EAAWC,MAAM/4B,KAAMtB,WAwJ3B,OArJKo6B,IAAaD,EAAaG,UAAYF,GAC3CD,EAAa75B,UAAYqK,OAAO4vB,OAAQH,GAAcA,EAAW95B,WACjE65B,EAAa75B,UAAUk6B,YAAcL,EAErCA,EAAa75B,UAAUm6B,kBAAoB,WACvC,IAAI7U,EAAMtkB,KAAKo5B,MACf9U,EAAIra,SACJ,IAAIuqB,EAASlQ,EAAIkQ,OAEb5yB,EADO82B,EAAyBpU,EAAK,CAAC,WAAY,WAGtD1iB,EAAQ4yB,OAAS,SAAUhvB,EAAO8uB,GAC9B,IAAIuD,EAWJ,OATIrD,EACAqD,EAAgBrD,EAAOhvB,EAAO8uB,IAE9BuD,EAAgBvG,SAASK,cAAc,QACzBpb,UAAY,iBAAmB+d,EAIjDuD,EAAcwB,iBAAkB,EACzBxB,GAGX73B,KAAKiS,MAAQqnB,EAAMt5B,KAAKkG,OAAO+D,SAAUrI,IAG7Ci3B,EAAa75B,UAAUu6B,mBAAqB,SAA6BC,GACrE,IAAIC,EAASz5B,KAETskB,EAAMtkB,KAAKo5B,MACf9U,EAAIra,SACJ,IAAI4pB,EAAUvP,EAAIuP,QACdD,EAAQtP,EAAIsP,MACZ8F,EAAYpV,EAAIoV,UAEhB93B,EADO82B,EAAyBpU,EAAK,CAAC,WAAY,UAAW,QAAS,cAEtEqV,EAAcH,EAAU3F,QACxB+F,EAAYJ,EAAU5F,MACtBiG,EAAgBL,EAAUE,UAY1BI,EAVa,CACb,UACA,cACA,aACA,cACA,aACA,eACA,YACA,UAIC3lB,KAAI,SAAUygB,GAAQ,OAAO6E,EAAOL,MAAMxE,KAAU4E,EAAU5E,MAC9DuB,QAAO,SAAU4D,EAAOC,GAAQ,OAAOD,GAASC,KAAS,GAG9D,GAAIj7B,MAAMgF,QAAQ8vB,IAAY90B,MAAMgF,QAAQ41B,GAAc,CACtD,IAAIM,GAAiB,EAErBpG,EAAQtb,SAAQ,SAAU2hB,EAAUr7B,GAChCo7B,EAAiBA,GAAkBC,IAAaP,EAAY96B,MAGhEi7B,EAAgBA,GAAiBG,OAEjCH,KADO/6B,MAAMgF,QAAQ8vB,KAAY90B,MAAMgF,QAAQ41B,MAG/BG,GAAiBjG,IAAY8F,GAIjD,GAAIG,EACAl4B,EAAQiyB,QAAUA,EAClBjyB,EAAQgyB,MAAQA,GAAS5zB,KAAKiS,MAAM4iB,WACpC70B,KAAKiS,MAAMqmB,SAAQ,GAAM,GACzB12B,EAAQ4yB,OAAS,SAAUhvB,EAAO8uB,EAAW6F,GAAS,OAAOA,EAAMC,iBACnEp6B,KAAKiS,MAAQqnB,EACTv6B,MAAMP,KAAKwB,KAAKkG,OAAO+D,UAAUwB,QAE7B,SAAUyO,GAAW,OAAQA,EAAQmf,mBAEzCz3B,QAED,GAAIgyB,EAAO,CAEd,IAAIyG,GAAc,EAElBzG,EAAMrb,SAAQ,SAAU+hB,EAAOz7B,GAC3Bw7B,EAAcA,GAAeC,IAAUV,EAAU/6B,MAGjDw7B,GAEAr6B,KAAKiS,MAAMgmB,SAASj4B,KAAKo5B,MAAMxF,OAMnCluB,OAAO60B,UAAUb,KAChBA,IAAcG,GAAiBC,IAEhC95B,KAAKiS,MAAMomB,SAASqB,IAI5Bb,EAAa75B,UAAUw7B,qBAAuB,WAC1Cx6B,KAAKiS,MAAMqmB,iBACJt4B,KAAKiS,OAGhB4mB,EAAa75B,UAAUy7B,OAAS,WAC5B,IAAIhB,EAASz5B,KAETskB,EAAMtkB,KAAKo5B,MACf9U,EAAIsP,MACJtP,EAAIuP,QACJvP,EAAIyP,QACJzP,EAAI4P,YACJ5P,EAAI+N,WACJ/N,EAAIkO,YACJlO,EAAI6P,WACJ7P,EAAI+P,aACJ/P,EAAIgQ,UACJhQ,EAAIiQ,OACJjQ,EAAIkQ,OACJlQ,EAAImQ,aACJnQ,EAAIoQ,YACJpQ,EAAIoW,OACJpW,EAAIqW,YACJrW,EAAIsW,UACJtW,EAAIoV,UACJ,IAAIzvB,EAAWqa,EAAIra,SAEf4wB,EADSnC,EAAyBpU,EAAK,CAAC,QAAS,UAAW,UAAW,cAAe,aAAc,cAAe,aAAc,eAAgB,YAAa,SAAU,SAAU,eAAgB,cAAe,SAAU,cAAe,YAAa,YAAa,aAGxQ,OACIwW,EAAAA,cAAqB,MAAOzxB,OAAOC,OAAO,GACtC,CAAEgb,IAAK,SAAUpe,GACbuzB,EAAOvzB,OAASA,IACf20B,GACL5wB,IAKL4uB,EA1JsB,CA2J/BiC,EAAAA,WAEFjC,EAAakC,UAAY,CACrBnH,MAAOoH,IAAAA,QAAkBA,IAAAA,QACzBnH,QAASmH,IAAAA,UAAoB,CACzBA,IAAAA,OACAA,IAAAA,QAAkBA,IAAAA,UACtBjH,QAASiH,IAAAA,UAAoB,CACzBA,IAAAA,OACAA,IAAAA,QAAkBA,IAAAA,UACtB9G,YAAa8G,IAAAA,KACb3I,WAAY2I,IAAAA,OACZxI,YAAawI,IAAAA,OACb7G,WAAY6G,IAAAA,UAAoB,CAC5BA,IAAAA,OACAA,IAAAA,QAAkBA,IAAAA,UACtB3G,aAAc2G,IAAAA,OACd1G,UAAW0G,IAAAA,OACXzG,OAAQyG,IAAAA,OACRxG,OAAQwG,IAAAA,KACRvG,aAAcuG,IAAAA,KACdtG,YAAasG,IAAAA,KACbN,OAAQM,IAAAA,KACRL,YAAaK,IAAAA,KACbJ,UAAWI,IAAAA,KACXtB,UAAWsB,IAAAA,OACX/wB,SAAU+wB,IAAAA,QAAkBA,IAAAA,UAGhCnC,EAAaoC,aAAe,CACxBrH,WAAO9nB,EACP+nB,aAAS/nB,EACTioB,aAASjoB,EACTooB,iBAAapoB,EACbumB,gBAAYvmB,EACZ0mB,iBAAa1mB,EACbqoB,gBAAYroB,EACZuoB,kBAAcvoB,EACdwoB,eAAWxoB,EACXyoB,YAAQzoB,EACR0oB,YAAQ1oB,EACR2oB,kBAAc3oB,EACd4oB,iBAAa5oB,EACb4uB,YAAQ5uB,EACR6uB,iBAAa7uB,EACb8uB,eAAW9uB,EACX4tB,eAAW5tB,EACX7B,cAAU6B,GAGd,+BChNA,IAAIovB,kCACJ,IAAIC,EAAQ,IAAIC,WAAW,IACZ,SAASC,IAEtB,IAAKH,KAGHA,EAAoC,qBAAXI,QAA0BA,OAAOJ,iBAAmBI,OAAOJ,gBAAgB1D,KAAK8D,SAA+B,qBAAbC,UAAgE,oBAA7BA,SAASL,iBAAkCK,SAASL,gBAAgB1D,KAAK+D,WAGrO,MAAM,IAAIx6B,MAAM,4GAIpB,OAAOm6B,EAAgBC,GCjBzB,4HCQA,ICFA,MAJA,SAAkBK,GAChB,MAAuB,kBAATA,GAAqBC,EAAAA,KAAWD,IDG5CE,EAAY,GAEP78B,EAAI,EAAGA,EAAI,MAAOA,EACzB68B,EAAUr5B,MAAMxD,EAAI,KAAOoiB,SAAS,IAAIoJ,OAAO,IAoBjD,MAjBA,SAAmBtf,GACjB,IAAI2G,EAAShT,UAAUC,OAAS,QAAsBmN,IAAjBpN,UAAU,GAAmBA,UAAU,GAAK,EAG7E88B,GAAQE,EAAU3wB,EAAI2G,EAAS,IAAMgqB,EAAU3wB,EAAI2G,EAAS,IAAMgqB,EAAU3wB,EAAI2G,EAAS,IAAMgqB,EAAU3wB,EAAI2G,EAAS,IAAM,IAAMgqB,EAAU3wB,EAAI2G,EAAS,IAAMgqB,EAAU3wB,EAAI2G,EAAS,IAAM,IAAMgqB,EAAU3wB,EAAI2G,EAAS,IAAMgqB,EAAU3wB,EAAI2G,EAAS,IAAM,IAAMgqB,EAAU3wB,EAAI2G,EAAS,IAAMgqB,EAAU3wB,EAAI2G,EAAS,IAAM,IAAMgqB,EAAU3wB,EAAI2G,EAAS,KAAOgqB,EAAU3wB,EAAI2G,EAAS,KAAOgqB,EAAU3wB,EAAI2G,EAAS,KAAOgqB,EAAU3wB,EAAI2G,EAAS,KAAOgqB,EAAU3wB,EAAI2G,EAAS,KAAOgqB,EAAU3wB,EAAI2G,EAAS,MAAMsB,cAMzf,IAAK2oB,EAASH,GACZ,MAAMI,UAAU,+BAGlB,OAAOJ,GEHT,MApBA,SAAY55B,EAASi6B,EAAKnqB,GAExB,IAAIoqB,GADJl6B,EAAUA,GAAW,IACFoT,SAAWpT,EAAQy5B,KAAOA,KAK7C,GAHAS,EAAK,GAAe,GAAVA,EAAK,GAAY,GAC3BA,EAAK,GAAe,GAAVA,EAAK,GAAY,IAEvBD,EAAK,CACPnqB,EAASA,GAAU,EAEnB,IAAK,IAAI7S,EAAI,EAAGA,EAAI,KAAMA,EACxBg9B,EAAInqB,EAAS7S,GAAKi9B,EAAKj9B,GAGzB,OAAOg9B,EAGT,OAAOhe,EAAUie,0ECnBJ,SAASC,EAA2BC,EAAGC,GACpD,IAAIC,EAAuB,qBAAXC,QAA0BH,EAAEG,OAAOC,WAAaJ,EAAE,cAElE,IAAKE,EAAI,CACP,GAAIn9B,MAAMgF,QAAQi4B,KAAOE,GAAK,OAA2BF,KAAOC,GAAkBD,GAAyB,kBAAbA,EAAEr9B,OAAqB,CAC/Gu9B,IAAIF,EAAIE,GACZ,IAAIr9B,EAAI,EAEJw9B,EAAI,aAER,MAAO,CACL3wB,EAAG2wB,EACH17B,EAAG,WACD,OAAI9B,GAAKm9B,EAAEr9B,OAAe,CACxB29B,MAAM,GAED,CACLA,MAAM,EACNn5B,MAAO64B,EAAEn9B,OAGbgmB,EAAG,SAAW0X,GACZ,MAAMA,GAERC,EAAGH,GAIP,MAAM,IAAIT,UAAU,yIAGtB,IAEIl6B,EAFA+6B,GAAmB,EACnBC,GAAS,EAEb,MAAO,CACLhxB,EAAG,WACDwwB,EAAKA,EAAGh9B,KAAK88B,IAEfr7B,EAAG,WACD,IAAIg8B,EAAOT,EAAG17B,OAEd,OADAi8B,EAAmBE,EAAKL,KACjBK,GAET9X,EAAG,SAAW+X,GACZF,GAAS,EACTh7B,EAAMk7B,GAERJ,EAAG,WACD,IACOC,GAAoC,MAAhBP,EAAW,QAAWA,EAAW,SAC1D,QACA,GAAIQ,EAAQ,MAAMh7B,sGClDX,SAASm7B,EAAWC,EAAQjtB,EAAMktB,GAc/C,OAZEF,GADE,EAAAG,EAAA,KACWC,QAAQC,UAER,SAAoBJ,EAAQjtB,EAAMktB,GAC7C,IAAIrvB,EAAI,CAAC,MACTA,EAAErL,KAAK02B,MAAMrrB,EAAGmC,GAChB,IACIstB,EAAW,IADGC,SAAS5F,KAAKuB,MAAM+D,EAAQpvB,IAG9C,OADIqvB,IAAO,EAAAM,EAAA,GAAeF,EAAUJ,EAAM/9B,WACnCm+B,GAIJN,EAAW9D,MAAM,KAAMr6B,WCZjB,SAAS4+B,EAAiBP,GACvC,IAAIQ,EAAwB,oBAARjV,IAAqB,IAAIA,SAAQxc,EA8BrD,OA5BAwxB,EAAmB,SAA0BP,GAC3C,GAAc,OAAVA,ICRkCrf,EDQEqf,GCPsB,IAAzDK,SAASnc,SAAS/hB,KAAKwe,GAAI3G,QAAQ,kBDOQ,OAAOgmB,ECR5C,IAA2Brf,EDUtC,GAAqB,oBAAVqf,EACT,MAAM,IAAInB,UAAU,sDAGtB,GAAsB,qBAAX2B,EAAwB,CACjC,GAAIA,EAAO9T,IAAIsT,GAAQ,OAAOQ,EAAOzT,IAAIiT,GAEzCQ,EAAO1T,IAAIkT,EAAOS,GAGpB,SAASA,IACP,OAAO,EAAUT,EAAOr+B,WAAW,EAAA++B,EAAA,GAAez9B,MAAMk5B,aAW1D,OARAsE,EAAQx+B,UAAYqK,OAAO4vB,OAAO8D,EAAM/9B,UAAW,CACjDk6B,YAAa,CACX/1B,MAAOq6B,EACPE,YAAY,EACZC,UAAU,EACVC,cAAc,MAGX,EAAAP,EAAA,GAAeG,EAAST,IAG1BO,EAAiBP","sources":["../node_modules/@mui/icons-material/Css.js","../node_modules/@mui/icons-material/Html.js","../node_modules/@mui/icons-material/Javascript.js","../node_modules/@mui/icons-material/esm/Code.js","../node_modules/@mui/icons-material/esm/VerticalSplit.js","../node_modules/@mui/icons-material/esm/ViewHeadline.js","../node_modules/emmet-monaco-es/dist/emmet-monaco.esm.js","../node_modules/split.js/dist/split.es.js","../node_modules/react-split/dist/react-split.es.js","../node_modules/uuid/dist/esm-browser/rng.js","../node_modules/uuid/dist/esm-browser/regex.js","../node_modules/uuid/dist/esm-browser/stringify.js","../node_modules/uuid/dist/esm-browser/validate.js","../node_modules/uuid/dist/esm-browser/v4.js","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../node_modules/@babel/runtime/helpers/esm/construct.js","../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js","../node_modules/@babel/runtime/helpers/esm/isNativeFunction.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\n\nvar _jsxRuntime = require(\"react/jsx-runtime\");\n\nvar _default = (0, _createSvgIcon.default)( /*#__PURE__*/(0, _jsxRuntime.jsx)(\"path\", {\n  d: \"M9.5 14v-1H11v.5h2v-1h-2.5c-.55 0-1-.45-1-1V10c0-.55.45-1 1-1h3c.55 0 1 .45 1 1v1H13v-.5h-2v1h2.5c.55 0 1 .45 1 1V14c0 .55-.45 1-1 1h-3c-.55 0-1-.45-1-1zm7.5 1h3c.55 0 1-.45 1-1v-1.5c0-.55-.45-1-1-1h-2.5v-1h2v.5H21v-1c0-.55-.45-1-1-1h-3c-.55 0-1 .45-1 1v1.5c0 .55.45 1 1 1h2.5v1h-2V13H16v1c0 .55.45 1 1 1zm-9-5c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-1H6.5v.5h-2v-3h2v.5H8v-1z\"\n}), 'Css');\n\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\n\nvar _jsxRuntime = require(\"react/jsx-runtime\");\n\nvar _default = (0, _createSvgIcon.default)( /*#__PURE__*/(0, _jsxRuntime.jsx)(\"path\", {\n  d: \"M3.5 9H5v6H3.5v-2.5h-2V15H0V9h1.5v2h2V9zm14 0H13c-.55 0-1 .45-1 1v5h1.5v-4.5h1V14H16v-3.51h1V15h1.5v-5c0-.55-.45-1-1-1zM11 9H6v1.5h1.75V15h1.5v-4.5H11V9zm13 6v-1.5h-2.5V9H20v6h4z\"\n}), 'Html');\n\nexports.default = _default;","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\n\nvar _jsxRuntime = require(\"react/jsx-runtime\");\n\nvar _default = (0, _createSvgIcon.default)( /*#__PURE__*/(0, _jsxRuntime.jsx)(\"path\", {\n  d: \"M12 14v-1h1.5v.5h2v-1H13c-.55 0-1-.45-1-1V10c0-.55.45-1 1-1h3c.55 0 1 .45 1 1v1h-1.5v-.5h-2v1H16c.55 0 1 .45 1 1V14c0 .55-.45 1-1 1h-3c-.55 0-1-.45-1-1zM9 9v4.5H7.5v-1H6v1c0 .83.67 1.5 1.5 1.5H9c.83 0 1.5-.67 1.5-1.5V9H9z\"\n}), 'Javascript');\n\nexports.default = _default;","import createSvgIcon from './utils/createSvgIcon';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"M9.4 16.6 4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0 4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z\"\n}), 'Code');","import createSvgIcon from './utils/createSvgIcon';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"M3 15h8v-2H3v2zm0 4h8v-2H3v2zm0-8h8V9H3v2zm0-6v2h8V5H3zm10 0h8v14h-8V5z\"\n}), 'VerticalSplit');","import createSvgIcon from './utils/createSvgIcon';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon( /*#__PURE__*/_jsx(\"path\", {\n  d: \"M4 15h16v-2H4v2zm0 4h16v-2H4v2zm0-8h16V9H4v2zm0-6v2h16V5H4z\"\n}), 'ViewHeadline');","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\n\n/**\n * Check if given code is a number\n */\nfunction isNumber$1(code) {\n    return code > 47 && code < 58;\n}\n/**\n * Check if given character code is alpha code (letter through A to Z)\n */\nfunction isAlpha$1(code, from, to) {\n    from = from || 65; // A\n    to = to || 90; // Z\n    code &= ~32; // quick hack to convert any char code to uppercase char code\n    return code >= from && code <= to;\n}\nfunction isAlphaNumericWord(code) {\n    return isNumber$1(code) || isAlphaWord(code);\n}\nfunction isAlphaWord(code) {\n    return code === 95 /* _ */ || isAlpha$1(code);\n}\n/**\n * Check if given character code is a white-space character: a space character\n * or line breaks\n */\nfunction isWhiteSpace$3(code) {\n    return code === 32 /* space */\n        || code === 9 /* tab */\n        || code === 160; /* non-breaking space */\n}\n/**\n * Check if given character code is a space character\n */\nfunction isSpace(code) {\n    return isWhiteSpace$3(code)\n        || code === 10 /* LF */\n        || code === 13; /* CR */\n}\n/**\n * Check if given character code is a quote character\n */\nfunction isQuote$2(code) {\n    return code === 39 /* ' */ || code === 34 /* \" */;\n}\n\n/**\n * A streaming, character code-based string reader\n */\nclass Scanner {\n    constructor(str, start, end) {\n        if (end == null && typeof str === 'string') {\n            end = str.length;\n        }\n        this.string = str;\n        this.pos = this.start = start || 0;\n        this.end = end || 0;\n    }\n    /**\n     * Returns true only if the stream is at the end of the file.\n     */\n    eof() {\n        return this.pos >= this.end;\n    }\n    /**\n     * Creates a new stream instance which is limited to given `start` and `end`\n     * range. E.g. its `eof()` method will look at `end` property, not actual\n     * stream end\n     */\n    limit(start, end) {\n        return new Scanner(this.string, start, end);\n    }\n    /**\n     * Returns the next character code in the stream without advancing it.\n     * Will return NaN at the end of the file.\n     */\n    peek() {\n        return this.string.charCodeAt(this.pos);\n    }\n    /**\n     * Returns the next character in the stream and advances it.\n     * Also returns <code>undefined</code> when no more characters are available.\n     */\n    next() {\n        if (this.pos < this.string.length) {\n            return this.string.charCodeAt(this.pos++);\n        }\n    }\n    /**\n     * `match` can be a character code or a function that takes a character code\n     * and returns a boolean. If the next character in the stream 'matches'\n     * the given argument, it is consumed and returned.\n     * Otherwise, `false` is returned.\n     */\n    eat(match) {\n        const ch = this.peek();\n        const ok = typeof match === 'function' ? match(ch) : ch === match;\n        if (ok) {\n            this.next();\n        }\n        return ok;\n    }\n    /**\n     * Repeatedly calls <code>eat</code> with the given argument, until it\n     * fails. Returns <code>true</code> if any characters were eaten.\n     */\n    eatWhile(match) {\n        const start = this.pos;\n        while (!this.eof() && this.eat(match)) { /* */ }\n        return this.pos !== start;\n    }\n    /**\n     * Backs up the stream n characters. Backing it up further than the\n     * start of the current token will cause things to break, so be careful.\n     */\n    backUp(n) {\n        this.pos -= (n || 1);\n    }\n    /**\n     * Get the string between the start of the current token and the\n     * current stream position.\n     */\n    current() {\n        return this.substring(this.start, this.pos);\n    }\n    /**\n     * Returns substring for given range\n     */\n    substring(start, end) {\n        return this.string.slice(start, end);\n    }\n    /**\n     * Creates error object with current stream state\n     */\n    error(message, pos = this.pos) {\n        return new ScannerError(`${message} at ${pos + 1}`, pos, this.string);\n    }\n}\nclass ScannerError extends Error {\n    constructor(message, pos, str) {\n        super(message);\n        this.pos = pos;\n        this.string = str;\n    }\n}\n\nfunction tokenScanner$1(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek$3(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction next(scanner) {\n    return scanner.tokens[scanner.pos++];\n}\nfunction slice(scanner, from = scanner.start, to = scanner.pos) {\n    return scanner.tokens.slice(from, to);\n}\nfunction readable$1(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume$2(scanner, test) {\n    const token = peek$3(scanner);\n    if (token && test(token)) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error$1(scanner, message, token = peek$3(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction abbreviation(abbr, options = {}) {\n    const scanner = tokenScanner$1(abbr);\n    const result = statements(scanner, options);\n    if (readable$1(scanner)) {\n        throw error$1(scanner, 'Unexpected character');\n    }\n    return result;\n}\nfunction statements(scanner, options) {\n    const result = {\n        type: 'TokenGroup',\n        elements: []\n    };\n    let ctx = result;\n    let node;\n    const stack = [];\n    while (readable$1(scanner)) {\n        if (node = element$2(scanner, options) || group(scanner, options)) {\n            ctx.elements.push(node);\n            if (consume$2(scanner, isChildOperator)) {\n                stack.push(ctx);\n                ctx = node;\n            }\n            else if (consume$2(scanner, isSiblingOperator$1)) {\n                continue;\n            }\n            else if (consume$2(scanner, isClimbOperator)) {\n                do {\n                    if (stack.length) {\n                        ctx = stack.pop();\n                    }\n                } while (consume$2(scanner, isClimbOperator));\n            }\n        }\n        else {\n            break;\n        }\n    }\n    return result;\n}\n/**\n * Consumes group from given scanner\n */\nfunction group(scanner, options) {\n    if (consume$2(scanner, isGroupStart)) {\n        const result = statements(scanner, options);\n        const token = next(scanner);\n        if (isBracket$2(token, 'group', false)) {\n            result.repeat = repeater(scanner);\n        }\n        return result;\n    }\n}\n/**\n * Consumes single element from given scanner\n */\nfunction element$2(scanner, options) {\n    let attr;\n    const elem = {\n        type: 'TokenElement',\n        name: void 0,\n        attributes: void 0,\n        value: void 0,\n        repeat: void 0,\n        selfClose: false,\n        elements: []\n    };\n    if (elementName(scanner, options)) {\n        elem.name = slice(scanner);\n    }\n    while (readable$1(scanner)) {\n        scanner.start = scanner.pos;\n        if (!elem.repeat && !isEmpty(elem) && consume$2(scanner, isRepeater)) {\n            elem.repeat = scanner.tokens[scanner.pos - 1];\n        }\n        else if (!elem.value && text(scanner)) {\n            elem.value = getText(scanner);\n        }\n        else if (attr = shortAttribute(scanner, 'id', options) || shortAttribute(scanner, 'class', options) || attributeSet(scanner)) {\n            if (!elem.attributes) {\n                elem.attributes = Array.isArray(attr) ? attr.slice() : [attr];\n            }\n            else {\n                elem.attributes = elem.attributes.concat(attr);\n            }\n        }\n        else {\n            if (!isEmpty(elem) && consume$2(scanner, isCloseOperator)) {\n                elem.selfClose = true;\n                if (!elem.repeat && consume$2(scanner, isRepeater)) {\n                    elem.repeat = scanner.tokens[scanner.pos - 1];\n                }\n            }\n            break;\n        }\n    }\n    return !isEmpty(elem) ? elem : void 0;\n}\n/**\n * Consumes attribute set from given scanner\n */\nfunction attributeSet(scanner) {\n    if (consume$2(scanner, isAttributeSetStart)) {\n        const attributes = [];\n        let attr;\n        while (readable$1(scanner)) {\n            if (attr = attribute(scanner)) {\n                attributes.push(attr);\n            }\n            else if (consume$2(scanner, isAttributeSetEnd)) {\n                break;\n            }\n            else if (!consume$2(scanner, isWhiteSpace$2)) {\n                throw error$1(scanner, `Unexpected \"${peek$3(scanner).type}\" token`);\n            }\n        }\n        return attributes;\n    }\n}\n/**\n * Consumes attribute shorthand (class or id) from given scanner\n */\nfunction shortAttribute(scanner, type, options) {\n    if (isOperator$1(peek$3(scanner), type)) {\n        scanner.pos++;\n        const attr = {\n            name: [createLiteral$1(type)]\n        };\n        // Consume expression after shorthand start for React-like components\n        if (options.jsx && text(scanner)) {\n            attr.value = getText(scanner);\n            attr.expression = true;\n        }\n        else {\n            attr.value = literal$2(scanner) ? slice(scanner) : void 0;\n        }\n        return attr;\n    }\n}\n/**\n * Consumes single attribute from given scanner\n */\nfunction attribute(scanner) {\n    if (quoted(scanner)) {\n        // Consumed quoted value: it’s a value for default attribute\n        return {\n            value: slice(scanner)\n        };\n    }\n    if (literal$2(scanner, true)) {\n        return {\n            name: slice(scanner),\n            value: consume$2(scanner, isEquals) && (quoted(scanner) || literal$2(scanner, true))\n                ? slice(scanner)\n                : void 0\n        };\n    }\n}\nfunction repeater(scanner) {\n    return isRepeater(peek$3(scanner))\n        ? scanner.tokens[scanner.pos++]\n        : void 0;\n}\n/**\n * Consumes quoted value from given scanner, if possible\n */\nfunction quoted(scanner) {\n    const start = scanner.pos;\n    const quote = peek$3(scanner);\n    if (isQuote$1(quote)) {\n        scanner.pos++;\n        while (readable$1(scanner)) {\n            if (isQuote$1(next(scanner), quote.single)) {\n                scanner.start = start;\n                return true;\n            }\n        }\n        throw error$1(scanner, 'Unclosed quote', quote);\n    }\n    return false;\n}\n/**\n * Consumes literal (unquoted value) from given scanner\n */\nfunction literal$2(scanner, allowBrackets) {\n    const start = scanner.pos;\n    const brackets = {\n        attribute: 0,\n        expression: 0,\n        group: 0\n    };\n    while (readable$1(scanner)) {\n        const token = peek$3(scanner);\n        if (brackets.expression) {\n            // If we’re inside expression, we should consume all content in it\n            if (isBracket$2(token, 'expression')) {\n                brackets[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else if (isQuote$1(token) || isOperator$1(token) || isWhiteSpace$2(token) || isRepeater(token)) {\n            break;\n        }\n        else if (isBracket$2(token)) {\n            if (!allowBrackets) {\n                break;\n            }\n            if (token.open) {\n                brackets[token.context]++;\n            }\n            else if (!brackets[token.context]) {\n                // Stop if found unmatched closing brace: it must be handled\n                // by parent consumer\n                break;\n            }\n            else {\n                brackets[token.context]--;\n            }\n        }\n        scanner.pos++;\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes element name from given scanner\n */\nfunction elementName(scanner, options) {\n    const start = scanner.pos;\n    if (options.jsx && consume$2(scanner, isCapitalizedLiteral)) {\n        // Check for edge case: consume immediate capitalized class names\n        // for React-like components, e.g. `Foo.Bar.Baz`\n        while (readable$1(scanner)) {\n            const { pos } = scanner;\n            if (!consume$2(scanner, isClassNameOperator) || !consume$2(scanner, isCapitalizedLiteral)) {\n                scanner.pos = pos;\n                break;\n            }\n        }\n    }\n    while (readable$1(scanner) && consume$2(scanner, isElementName)) {\n        // empty\n    }\n    if (scanner.pos !== start) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes text value from given scanner\n */\nfunction text(scanner) {\n    const start = scanner.pos;\n    if (consume$2(scanner, isTextStart)) {\n        let brackets = 0;\n        while (readable$1(scanner)) {\n            const token = next(scanner);\n            if (isBracket$2(token, 'expression')) {\n                if (token.open) {\n                    brackets++;\n                }\n                else if (!brackets) {\n                    break;\n                }\n                else {\n                    brackets--;\n                }\n            }\n        }\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\nfunction getText(scanner) {\n    let from = scanner.start;\n    let to = scanner.pos;\n    if (isBracket$2(scanner.tokens[from], 'expression', true)) {\n        from++;\n    }\n    if (isBracket$2(scanner.tokens[to - 1], 'expression', false)) {\n        to--;\n    }\n    return slice(scanner, from, to);\n}\nfunction isBracket$2(token, context, isOpen) {\n    return Boolean(token && token.type === 'Bracket'\n        && (!context || token.context === context)\n        && (isOpen == null || token.open === isOpen));\n}\nfunction isOperator$1(token, type) {\n    return Boolean(token && token.type === 'Operator' && (!type || token.operator === type));\n}\nfunction isQuote$1(token, isSingle) {\n    return Boolean(token && token.type === 'Quote' && (isSingle == null || token.single === isSingle));\n}\nfunction isWhiteSpace$2(token) {\n    return Boolean(token && token.type === 'WhiteSpace');\n}\nfunction isEquals(token) {\n    return isOperator$1(token, 'equal');\n}\nfunction isRepeater(token) {\n    return Boolean(token && token.type === 'Repeater');\n}\nfunction isLiteral$2(token) {\n    return token.type === 'Literal';\n}\nfunction isCapitalizedLiteral(token) {\n    if (isLiteral$2(token)) {\n        const ch = token.value.charCodeAt(0);\n        return ch >= 65 && ch <= 90;\n    }\n    return false;\n}\nfunction isElementName(token) {\n    return token.type === 'Literal' || token.type === 'RepeaterNumber' || token.type === 'RepeaterPlaceholder';\n}\nfunction isClassNameOperator(token) {\n    return isOperator$1(token, 'class');\n}\nfunction isAttributeSetStart(token) {\n    return isBracket$2(token, 'attribute', true);\n}\nfunction isAttributeSetEnd(token) {\n    return isBracket$2(token, 'attribute', false);\n}\nfunction isTextStart(token) {\n    return isBracket$2(token, 'expression', true);\n}\nfunction isGroupStart(token) {\n    return isBracket$2(token, 'group', true);\n}\nfunction createLiteral$1(value) {\n    return { type: 'Literal', value };\n}\nfunction isEmpty(elem) {\n    return !elem.name && !elem.value && !elem.attributes;\n}\nfunction isChildOperator(token) {\n    return isOperator$1(token, 'child');\n}\nfunction isSiblingOperator$1(token) {\n    return isOperator$1(token, 'sibling');\n}\nfunction isClimbOperator(token) {\n    return isOperator$1(token, 'climb');\n}\nfunction isCloseOperator(token) {\n    return isOperator$1(token, 'close');\n}\n\n/**\n * If consumes escape character, sets current stream range to escaped value\n */\nfunction escaped(scanner) {\n    if (scanner.eat(92 /* Escape */)) {\n        scanner.start = scanner.pos;\n        if (!scanner.eof()) {\n            scanner.pos++;\n        }\n        return true;\n    }\n    return false;\n}\n\nfunction tokenize$1(source) {\n    const scanner = new Scanner(source);\n    const result = [];\n    const ctx = {\n        group: 0,\n        attribute: 0,\n        expression: 0,\n        quote: 0\n    };\n    let ch = 0;\n    let token;\n    while (!scanner.eof()) {\n        ch = scanner.peek();\n        token = getToken$1(scanner, ctx);\n        if (token) {\n            result.push(token);\n            if (token.type === 'Quote') {\n                ctx.quote = ch === ctx.quote ? 0 : ch;\n            }\n            else if (token.type === 'Bracket') {\n                ctx[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else {\n            throw scanner.error('Unexpected character');\n        }\n    }\n    return result;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken$1(scanner, ctx) {\n    return field$2(scanner, ctx)\n        || repeaterPlaceholder(scanner)\n        || repeaterNumber(scanner)\n        || repeater$1(scanner)\n        || whiteSpace$1(scanner)\n        || literal$1$1(scanner, ctx)\n        || operator$1(scanner)\n        || quote(scanner)\n        || bracket$1(scanner);\n}\n/**\n * Consumes literal from given scanner\n */\nfunction literal$1$1(scanner, ctx) {\n    const start = scanner.pos;\n    let value = '';\n    while (!scanner.eof()) {\n        // Consume escaped sequence no matter of context\n        if (escaped(scanner)) {\n            value += scanner.current();\n            continue;\n        }\n        const ch = scanner.peek();\n        if (ch === ctx.quote || ch === 36 /* Dollar */ || isAllowedOperator(ch, ctx)) {\n            // 1. Found matching quote\n            // 2. The `$` character has special meaning in every context\n            // 3. Depending on context, some characters should be treated as operators\n            break;\n        }\n        if (ctx.expression && ch === 125 /* CurlyBracketClose */) {\n            break;\n        }\n        if (!ctx.quote && !ctx.expression) {\n            // Consuming element name\n            if (!ctx.attribute && !isElementName$1(ch)) {\n                break;\n            }\n            if (isAllowedSpace(ch, ctx) || isAllowedRepeater(ch, ctx) || isQuote$2(ch) || bracketType(ch)) {\n                // Stop for characters not allowed in unquoted literal\n                break;\n            }\n        }\n        value += scanner.string[scanner.pos++];\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return {\n            type: 'Literal',\n            value,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace$1(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos,\n            value: scanner.substring(start, scanner.pos)\n        };\n    }\n}\n/**\n * Consumes quote from given scanner\n */\nfunction quote(scanner) {\n    const ch = scanner.peek();\n    if (isQuote$2(ch)) {\n        return {\n            type: 'Quote',\n            single: ch === 39 /* SingleQuote */,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket$1(scanner) {\n    const ch = scanner.peek();\n    const context = bracketType(ch);\n    if (context) {\n        return {\n            type: 'Bracket',\n            open: isOpenBracket$2(ch),\n            context,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator$1(scanner) {\n    const op = operatorType$1(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes node repeat token from current stream position and returns its\n * parsed value\n */\nfunction repeater$1(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(42 /* Asterisk */)) {\n        scanner.start = scanner.pos;\n        let count = 1;\n        let implicit = false;\n        if (scanner.eatWhile(isNumber$1)) {\n            count = Number(scanner.current());\n        }\n        else {\n            implicit = true;\n        }\n        return {\n            type: 'Repeater',\n            count,\n            value: 0,\n            implicit,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes repeater placeholder `$#` from given scanner\n */\nfunction repeaterPlaceholder(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(36 /* Dollar */) && scanner.eat(35 /* Hash */)) {\n        return {\n            type: 'RepeaterPlaceholder',\n            value: void 0,\n            start,\n            end: scanner.pos\n        };\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes numbering token like `$` from given scanner state\n */\nfunction repeaterNumber(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(36 /* Dollar */)) {\n        const size = scanner.pos - start;\n        let reverse = false;\n        let base = 1;\n        let parent = 0;\n        if (scanner.eat(64 /* At */)) {\n            // Consume numbering modifiers\n            while (scanner.eat(94 /* Climb */)) {\n                parent++;\n            }\n            reverse = scanner.eat(45 /* Dash */);\n            scanner.start = scanner.pos;\n            if (scanner.eatWhile(isNumber$1)) {\n                base = Number(scanner.current());\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'RepeaterNumber',\n            size,\n            reverse,\n            base,\n            parent,\n            start,\n            end: scanner.pos\n        };\n    }\n}\nfunction field$2(scanner, ctx) {\n    const start = scanner.pos;\n    // Fields are allowed inside expressions and attributes\n    if ((ctx.expression || ctx.attribute) && scanner.eat(36 /* Dollar */) && scanner.eat(123 /* CurlyBracketOpen */)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber$1)) {\n            // It’s a field\n            index = Number(scanner.current());\n            name = scanner.eat(58 /* Colon */) ? consumePlaceholder$2(scanner) : '';\n        }\n        else if (isAlpha$1(scanner.peek())) {\n            // It’s a variable\n            name = consumePlaceholder$2(scanner);\n        }\n        if (scanner.eat(125 /* CurlyBracketClose */)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then there’s no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder$2(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(123 /* CurlyBracketOpen */)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(125 /* CurlyBracketClose */)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Check if given character code is an operator and it’s allowed in current context\n */\nfunction isAllowedOperator(ch, ctx) {\n    const op = operatorType$1(ch);\n    if (!op || ctx.quote || ctx.expression) {\n        // No operators inside quoted values or expressions\n        return false;\n    }\n    // Inside attributes, only `equals` is allowed\n    return !ctx.attribute || op === 'equal';\n}\n/**\n * Check if given character is a space character and is allowed to be consumed\n * as a space token in current context\n */\nfunction isAllowedSpace(ch, ctx) {\n    return isSpace(ch) && !ctx.expression;\n}\n/**\n * Check if given character can be consumed as repeater in current context\n */\nfunction isAllowedRepeater(ch, ctx) {\n    return ch === 42 /* Asterisk */ && !ctx.attribute && !ctx.expression;\n}\n/**\n * If given character is a bracket, returns it’s type\n */\nfunction bracketType(ch) {\n    if (ch === 40 /* RoundBracketOpen */ || ch === 41 /* RoundBracketClose */) {\n        return 'group';\n    }\n    if (ch === 91 /* SquareBracketOpen */ || ch === 93 /* SquareBracketClose */) {\n        return 'attribute';\n    }\n    if (ch === 123 /* CurlyBracketOpen */ || ch === 125 /* CurlyBracketClose */) {\n        return 'expression';\n    }\n}\n/**\n * If given character is an operator, returns it’s type\n */\nfunction operatorType$1(ch) {\n    return (ch === 62 /* Child */ && 'child')\n        || (ch === 43 /* Sibling */ && 'sibling')\n        || (ch === 94 /* Climb */ && 'climb')\n        || (ch === 46 /* Dot */ && 'class')\n        || (ch === 35 /* Hash */ && 'id')\n        || (ch === 47 /* Slash */ && 'close')\n        || (ch === 61 /* Equals */ && 'equal')\n        || void 0;\n}\n/**\n * Check if given character is an open bracket\n */\nfunction isOpenBracket$2(ch) {\n    return ch === 123 /* CurlyBracketOpen */\n        || ch === 91 /* SquareBracketOpen */\n        || ch === 40 /* RoundBracketOpen */;\n}\n/**\n * Check if given character is allowed in element name\n */\nfunction isElementName$1(ch) {\n    return isAlphaNumericWord(ch)\n        || ch === 45 /* Dash */\n        || ch === 58 /* Colon */\n        || ch === 33 /* Excl */;\n}\n\nconst operators = {\n    child: '>',\n    class: '.',\n    climb: '^',\n    id: '#',\n    equal: '=',\n    close: '/',\n    sibling: '+'\n};\nconst tokenVisitor = {\n    Literal(token) {\n        return token.value;\n    },\n    Quote(token) {\n        return token.single ? '\\'' : '\"';\n    },\n    Bracket(token) {\n        if (token.context === 'attribute') {\n            return token.open ? '[' : ']';\n        }\n        else if (token.context === 'expression') {\n            return token.open ? '{' : '}';\n        }\n        else {\n            return token.open ? '(' : '}';\n        }\n    },\n    Operator(token) {\n        return operators[token.operator];\n    },\n    Field(token, state) {\n        if (token.index != null) {\n            // It’s a field: by default, return TextMate-compatible field\n            return token.name\n                ? `\\${${token.index}:${token.name}}`\n                : `\\${${token.index}`;\n        }\n        else if (token.name) {\n            // It’s a variable\n            return state.getVariable(token.name);\n        }\n        return '';\n    },\n    RepeaterPlaceholder(token, state) {\n        // Find closest implicit repeater\n        let repeater;\n        for (let i = state.repeaters.length - 1; i >= 0; i--) {\n            if (state.repeaters[i].implicit) {\n                repeater = state.repeaters[i];\n                break;\n            }\n        }\n        state.inserted = true;\n        return state.getText(repeater && repeater.value);\n    },\n    RepeaterNumber(token, state) {\n        let value = 1;\n        const lastIx = state.repeaters.length - 1;\n        // const repeaterIx = Math.max(0, state.repeaters.length - 1 - token.parent);\n        const repeater = state.repeaters[lastIx];\n        if (repeater) {\n            value = token.reverse\n                ? token.base + repeater.count - repeater.value - 1\n                : token.base + repeater.value;\n            if (token.parent) {\n                const parentIx = Math.max(0, lastIx - token.parent);\n                if (parentIx !== lastIx) {\n                    const parentRepeater = state.repeaters[parentIx];\n                    value += repeater.count * parentRepeater.value;\n                }\n            }\n        }\n        let result = String(value);\n        while (result.length < token.size) {\n            result = '0' + result;\n        }\n        return result;\n    },\n    WhiteSpace(token) {\n        return token.value;\n    }\n};\n/**\n * Converts given value token to string\n */\nfunction stringify$1(token, state) {\n    if (!tokenVisitor[token.type]) {\n        throw new Error(`Unknown token ${token.type}`);\n    }\n    return tokenVisitor[token.type](token, state);\n}\n\nconst urlRegex = /^((https?:|ftp:|file:)?\\/\\/|(www|ftp)\\.)[^ ]*$/;\nconst emailRegex = /^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,5}$/;\n/**\n * Converts given token-based abbreviation into simplified and unrolled node-based\n * abbreviation\n */\nfunction convert(abbr, options = {}) {\n    let textInserted = false;\n    let cleanText;\n    if (options.text) {\n        if (Array.isArray(options.text)) {\n            cleanText = options.text.filter(s => s.trim());\n        }\n        else {\n            cleanText = options.text;\n        }\n    }\n    const result = {\n        type: 'Abbreviation',\n        children: convertGroup(abbr, {\n            inserted: false,\n            repeaters: [],\n            text: options.text,\n            cleanText,\n            repeatGuard: options.maxRepeat || Number.POSITIVE_INFINITY,\n            getText(pos) {\n                var _a;\n                textInserted = true;\n                let value;\n                if (Array.isArray(options.text)) {\n                    if (pos !== undefined && pos >= 0 && pos < cleanText.length) {\n                        return cleanText[pos];\n                    }\n                    value = pos !== undefined ? options.text[pos] : options.text.join('\\n');\n                }\n                else {\n                    value = (_a = options.text) !== null && _a !== void 0 ? _a : '';\n                }\n                return value;\n            },\n            getVariable(name) {\n                const varValue = options.variables && options.variables[name];\n                return varValue != null ? varValue : name;\n            }\n        })\n    };\n    if (options.text != null && !textInserted) {\n        // Text given but no implicitly repeated elements: insert it into\n        // deepest child\n        const deepest = deepestNode(last$1(result.children));\n        if (deepest) {\n            const text = Array.isArray(options.text) ? options.text.join('\\n') : options.text;\n            insertText(deepest, text);\n            if (deepest.name === 'a' && options.href) {\n                // Automatically update value of `<a>` element if inserting URL or email\n                insertHref(deepest, text);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Converts given statement to abbreviation nodes\n */\nfunction convertStatement(node, state) {\n    let result = [];\n    if (node.repeat) {\n        // Node is repeated: we should create copies of given node\n        // and supply context token with actual repeater state\n        const original = node.repeat;\n        const repeat = Object.assign({}, original);\n        repeat.count = repeat.implicit && Array.isArray(state.text)\n            ? state.cleanText.length\n            : (repeat.count || 1);\n        let items;\n        state.repeaters.push(repeat);\n        for (let i = 0; i < repeat.count; i++) {\n            repeat.value = i;\n            node.repeat = repeat;\n            items = isGroup(node)\n                ? convertGroup(node, state)\n                : convertElement(node, state);\n            if (repeat.implicit && !state.inserted) {\n                // It’s an implicit repeater but no repeater placeholders found inside,\n                // we should insert text into deepest node\n                const target = last$1(items);\n                const deepest = target && deepestNode(target);\n                if (deepest) {\n                    insertText(deepest, state.getText(repeat.value));\n                }\n            }\n            result = result.concat(items);\n            // We should output at least one repeated item even if it’s reached\n            // repeat limit\n            if (--state.repeatGuard <= 0) {\n                break;\n            }\n        }\n        state.repeaters.pop();\n        node.repeat = original;\n        if (repeat.implicit) {\n            state.inserted = true;\n        }\n    }\n    else {\n        result = result.concat(isGroup(node) ? convertGroup(node, state) : convertElement(node, state));\n    }\n    return result;\n}\nfunction convertElement(node, state) {\n    let children = [];\n    const elem = {\n        type: 'AbbreviationNode',\n        name: node.name && stringifyName(node.name, state),\n        value: node.value && stringifyValue$1(node.value, state),\n        attributes: void 0,\n        children,\n        repeat: node.repeat && Object.assign({}, node.repeat),\n        selfClosing: node.selfClose,\n    };\n    let result = [elem];\n    for (const child of node.elements) {\n        children = children.concat(convertStatement(child, state));\n    }\n    if (node.attributes) {\n        elem.attributes = [];\n        for (const attr of node.attributes) {\n            elem.attributes.push(convertAttribute(attr, state));\n        }\n    }\n    // In case if current node is a text-only snippet without fields, we should\n    // put all children as siblings\n    if (!elem.name && !elem.attributes && elem.value && !elem.value.some(isField$1)) {\n        // XXX it’s unclear that `children` is not bound to `elem`\n        // due to concat operation\n        result = result.concat(children);\n    }\n    else {\n        elem.children = children;\n    }\n    return result;\n}\nfunction convertGroup(node, state) {\n    let result = [];\n    for (const child of node.elements) {\n        result = result.concat(convertStatement(child, state));\n    }\n    if (node.repeat) {\n        result = attachRepeater(result, node.repeat);\n    }\n    return result;\n}\nfunction convertAttribute(node, state) {\n    let implied = false;\n    let isBoolean = false;\n    let valueType = node.expression ? 'expression' : 'raw';\n    let value;\n    const name = node.name && stringifyName(node.name, state);\n    if (name && name[0] === '!') {\n        implied = true;\n    }\n    if (name && name[name.length - 1] === '.') {\n        isBoolean = true;\n    }\n    if (node.value) {\n        const tokens = node.value.slice();\n        if (isQuote$1(tokens[0])) {\n            // It’s a quoted value: remove quotes from output but mark attribute\n            // value as quoted\n            const quote = tokens.shift();\n            if (tokens.length && last$1(tokens).type === quote.type) {\n                tokens.pop();\n            }\n            valueType = quote.single ? 'singleQuote' : 'doubleQuote';\n        }\n        else if (isBracket$2(tokens[0], 'expression', true)) {\n            // Value is expression: remove brackets but mark value type\n            valueType = 'expression';\n            tokens.shift();\n            if (isBracket$2(last$1(tokens), 'expression', false)) {\n                tokens.pop();\n            }\n        }\n        value = stringifyValue$1(tokens, state);\n    }\n    return {\n        name: isBoolean || implied\n            ? name.slice(implied ? 1 : 0, isBoolean ? -1 : void 0)\n            : name,\n        value,\n        boolean: isBoolean,\n        implied,\n        valueType\n    };\n}\n/**\n * Converts given token list to string\n */\nfunction stringifyName(tokens, state) {\n    let str = '';\n    for (let i = 0; i < tokens.length; i++) {\n        str += stringify$1(tokens[i], state);\n    }\n    return str;\n}\n/**\n * Converts given token list to value list\n */\nfunction stringifyValue$1(tokens, state) {\n    const result = [];\n    let str = '';\n    for (let i = 0, token; i < tokens.length; i++) {\n        token = tokens[i];\n        if (isField$1(token)) {\n            // We should keep original fields in output since some editors has their\n            // own syntax for field or doesn’t support fields at all so we should\n            // capture actual field location in output stream\n            if (str) {\n                result.push(str);\n                str = '';\n            }\n            result.push(token);\n        }\n        else {\n            str += stringify$1(token, state);\n        }\n    }\n    if (str) {\n        result.push(str);\n    }\n    return result;\n}\nfunction isGroup(node) {\n    return node.type === 'TokenGroup';\n}\nfunction isField$1(token) {\n    return typeof token === 'object' && token.type === 'Field' && token.index != null;\n}\nfunction last$1(arr) {\n    return arr[arr.length - 1];\n}\nfunction deepestNode(node) {\n    return node.children.length ? deepestNode(last$1(node.children)) : node;\n}\nfunction insertText(node, text) {\n    if (node.value) {\n        const lastToken = last$1(node.value);\n        if (typeof lastToken === 'string') {\n            node.value[node.value.length - 1] += text;\n        }\n        else {\n            node.value.push(text);\n        }\n    }\n    else {\n        node.value = [text];\n    }\n}\nfunction insertHref(node, text) {\n    var _a;\n    let href = '';\n    if (urlRegex.test(text)) {\n        href = text;\n        if (!/\\w+:/.test(href) && !href.startsWith('//')) {\n            href = `http://${href}`;\n        }\n    }\n    else if (emailRegex.test(text)) {\n        href = `mailto:${text}`;\n    }\n    const hrefAttribute = (_a = node.attributes) === null || _a === void 0 ? void 0 : _a.find(attr => attr.name === 'href');\n    if (!hrefAttribute) {\n        if (!node.attributes) {\n            node.attributes = [];\n        }\n        node.attributes.push({ name: 'href', value: [href], valueType: 'doubleQuote' });\n    }\n    else if (!hrefAttribute.value) {\n        hrefAttribute.value = [href];\n    }\n}\nfunction attachRepeater(items, repeater) {\n    for (const item of items) {\n        if (!item.repeat) {\n            item.repeat = Object.assign({}, repeater);\n        }\n    }\n    return items;\n}\n\n/**\n * Parses given abbreviation into node tree\n */\nfunction parseAbbreviation(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize$1(abbr) : abbr;\n        return convert(abbreviation(tokens, options), options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\nfunction tokenize(abbr, isValue) {\n    let brackets = 0;\n    let token;\n    const scanner = new Scanner(abbr);\n    const tokens = [];\n    while (!scanner.eof()) {\n        token = getToken(scanner, brackets === 0 && !isValue);\n        if (!token) {\n            throw scanner.error('Unexpected character');\n        }\n        if (token.type === 'Bracket') {\n            if (!brackets && token.open) {\n                mergeTokens(scanner, tokens);\n            }\n            brackets += token.open ? 1 : -1;\n            if (brackets < 0) {\n                throw scanner.error('Unexpected bracket', token.start);\n            }\n        }\n        tokens.push(token);\n        // Forcibly consume next operator after unit-less numeric value or color:\n        // next dash `-` must be used as value delimiter\n        if (shouldConsumeDashAfter(token) && (token = operator(scanner))) {\n            tokens.push(token);\n        }\n    }\n    return tokens;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken(scanner, short) {\n    return field$1(scanner)\n        || numberValue(scanner)\n        || colorValue(scanner)\n        || stringValue(scanner)\n        || bracket(scanner)\n        || operator(scanner)\n        || whiteSpace(scanner)\n        || literal$1(scanner, short);\n}\nfunction field$1(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(36 /* Dollar */) && scanner.eat(123 /* CurlyBracketOpen */)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber$1)) {\n            // It’s a field\n            index = Number(scanner.current());\n            name = scanner.eat(58 /* Colon */) ? consumePlaceholder$1(scanner) : '';\n        }\n        else if (isAlpha$1(scanner.peek())) {\n            // It’s a variable\n            name = consumePlaceholder$1(scanner);\n        }\n        if (scanner.eat(125 /* CurlyBracketClose */)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then there’s no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder$1(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(123 /* CurlyBracketOpen */)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(125 /* CurlyBracketClose */)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Consumes literal from given scanner\n * @param short Use short notation for consuming value.\n * The difference between “short” and “full” notation is that first one uses\n * alpha characters only and used for extracting keywords from abbreviation,\n * while “full” notation also supports numbers and dashes\n */\nfunction literal$1(scanner, short) {\n    const start = scanner.pos;\n    if (scanner.eat(isIdentPrefix)) {\n        // SCSS or LESS variable\n        // NB a bit dirty hack: if abbreviation starts with identifier prefix,\n        // consume alpha characters only to allow embedded variables\n        scanner.eatWhile(start ? isKeyword : isLiteral);\n    }\n    else if (scanner.eat(isAlphaWord)) {\n        scanner.eatWhile(short ? isLiteral : isKeyword);\n    }\n    else {\n        // Allow dots only at the beginning of literal\n        scanner.eat(46 /* Dot */);\n        scanner.eatWhile(isLiteral);\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return createLiteral(scanner, scanner.start = start);\n    }\n}\nfunction createLiteral(scanner, start = scanner.start, end = scanner.pos) {\n    return {\n        type: 'Literal',\n        value: scanner.substring(start, end),\n        start,\n        end\n    };\n}\n/**\n * Consumes numeric CSS value (number with optional unit) from current stream,\n * if possible\n */\nfunction numberValue(scanner) {\n    const start = scanner.pos;\n    if (consumeNumber(scanner)) {\n        scanner.start = start;\n        const rawValue = scanner.current();\n        // eat unit, which can be a % or alpha word\n        scanner.start = scanner.pos;\n        scanner.eat(37 /* Percent */) || scanner.eatWhile(isAlphaWord);\n        return {\n            type: 'NumberValue',\n            value: Number(rawValue),\n            rawValue,\n            unit: scanner.current(),\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes quoted string value from given scanner\n */\nfunction stringValue(scanner) {\n    const ch = scanner.peek();\n    const start = scanner.pos;\n    let finished = false;\n    if (isQuote$2(ch)) {\n        scanner.pos++;\n        while (!scanner.eof()) {\n            // Do not throw error on malformed string\n            if (scanner.eat(ch)) {\n                finished = true;\n                break;\n            }\n            else {\n                scanner.pos++;\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'StringValue',\n            value: scanner.substring(start + 1, scanner.pos - (finished ? 1 : 0)),\n            quote: ch === 39 /* SingleQuote */ ? 'single' : 'double',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes a color token from given string\n */\nfunction colorValue(scanner) {\n    // supported color variations:\n    // #abc   → #aabbccc\n    // #0     → #000000\n    // #fff.5 → rgba(255, 255, 255, 0.5)\n    // #t     → transparent\n    const start = scanner.pos;\n    if (scanner.eat(35 /* Hash */)) {\n        const valueStart = scanner.pos;\n        let color = '';\n        let alpha = '';\n        if (scanner.eatWhile(isHex)) {\n            color = scanner.substring(valueStart, scanner.pos);\n            alpha = colorAlpha(scanner);\n        }\n        else if (scanner.eat(116 /* Transparent */)) {\n            color = '0';\n            alpha = colorAlpha(scanner) || '0';\n        }\n        else {\n            alpha = colorAlpha(scanner);\n        }\n        if (color || alpha || scanner.eof()) {\n            const { r, g, b, a } = parseColor(color, alpha);\n            return {\n                type: 'ColorValue',\n                r, g, b, a,\n                raw: scanner.substring(start + 1, scanner.pos),\n                start,\n                end: scanner.pos\n            };\n        }\n        else {\n            // Consumed # but no actual value: invalid color value, treat it as literal\n            return createLiteral(scanner, start);\n        }\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes alpha value of color: `.1`\n */\nfunction colorAlpha(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(46 /* Dot */)) {\n        scanner.start = start;\n        if (scanner.eatWhile(isNumber$1)) {\n            return scanner.current();\n        }\n        return '1';\n    }\n    return '';\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket(scanner) {\n    const ch = scanner.peek();\n    if (isBracket(ch)) {\n        return {\n            type: 'Bracket',\n            open: ch === 40 /* RoundBracketOpen */,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator(scanner) {\n    const op = operatorType(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Eats number value from given stream\n * @return Returns `true` if number was consumed\n */\nfunction consumeNumber(stream) {\n    const start = stream.pos;\n    stream.eat(45 /* Dash */);\n    const afterNegative = stream.pos;\n    const hasDecimal = stream.eatWhile(isNumber$1);\n    const prevPos = stream.pos;\n    if (stream.eat(46 /* Dot */)) {\n        // It’s perfectly valid to have numbers like `1.`, which enforces\n        // value to float unit type\n        const hasFloat = stream.eatWhile(isNumber$1);\n        if (!hasDecimal && !hasFloat) {\n            // Lone dot\n            stream.pos = prevPos;\n        }\n    }\n    // Edge case: consumed dash only: not a number, bail-out\n    if (stream.pos === afterNegative) {\n        stream.pos = start;\n    }\n    return stream.pos !== start;\n}\nfunction isIdentPrefix(code) {\n    return code === 64 /* At */ || code === 36 /* Dollar */;\n}\n/**\n * If given character is an operator, returns it’s type\n */\nfunction operatorType(ch) {\n    return (ch === 43 /* Sibling */ && \"+\" /* Sibling */)\n        || (ch === 33 /* Excl */ && \"!\" /* Important */)\n        || (ch === 44 /* Comma */ && \",\" /* ArgumentDelimiter */)\n        || (ch === 58 /* Colon */ && \":\" /* PropertyDelimiter */)\n        || (ch === 45 /* Dash */ && \"-\" /* ValueDelimiter */)\n        || void 0;\n}\n/**\n * Check if given code is a hex value (/0-9a-f/)\n */\nfunction isHex(code) {\n    return isNumber$1(code) || isAlpha$1(code, 65, 70); // A-F\n}\nfunction isKeyword(code) {\n    return isAlphaNumericWord(code) || code === 45 /* Dash */;\n}\nfunction isBracket(code) {\n    return code === 40 /* RoundBracketOpen */ || code === 41 /* RoundBracketClose */;\n}\nfunction isLiteral(code) {\n    return isAlphaWord(code) || code === 37 /* Percent */ || code === 47 /* Slash */;\n}\n/**\n * Parses given color value from abbreviation into RGBA format\n */\nfunction parseColor(value, alpha) {\n    let r = '0';\n    let g = '0';\n    let b = '0';\n    let a = Number(alpha != null && alpha !== '' ? alpha : 1);\n    if (value === 't') {\n        a = 0;\n    }\n    else {\n        switch (value.length) {\n            case 0:\n                break;\n            case 1:\n                r = g = b = value + value;\n                break;\n            case 2:\n                r = g = b = value;\n                break;\n            case 3:\n                r = value[0] + value[0];\n                g = value[1] + value[1];\n                b = value[2] + value[2];\n                break;\n            default:\n                value += value;\n                r = value.slice(0, 2);\n                g = value.slice(2, 4);\n                b = value.slice(4, 6);\n        }\n    }\n    return {\n        r: parseInt(r, 16),\n        g: parseInt(g, 16),\n        b: parseInt(b, 16),\n        a\n    };\n}\n/**\n * Check if scanner reader must consume dash after given token.\n * Used in cases where user must explicitly separate numeric values\n */\nfunction shouldConsumeDashAfter(token) {\n    return token.type === 'ColorValue' || (token.type === 'NumberValue' && !token.unit);\n}\n/**\n * Merges last adjacent tokens into a single literal.\n * This function is used to overcome edge case when function name was parsed\n * as a list of separate tokens. For example, a `scale3d()` value will be\n * parsed as literal and number tokens (`scale` and `3d`) which is a perfectly\n * valid abbreviation but undesired result. This function will detect last adjacent\n * literal and number values and combine them into single literal\n */\nfunction mergeTokens(scanner, tokens) {\n    let start = 0;\n    let end = 0;\n    while (tokens.length) {\n        const token = last(tokens);\n        if (token.type === 'Literal' || token.type === 'NumberValue') {\n            start = token.start;\n            if (!end) {\n                end = token.end;\n            }\n            tokens.pop();\n        }\n        else {\n            break;\n        }\n    }\n    if (start !== end) {\n        tokens.push(createLiteral(scanner, start, end));\n    }\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\nfunction tokenScanner(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek$2(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction readable(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume$1(scanner, test) {\n    if (test(peek$2(scanner))) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error(scanner, message, token = peek$2(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction parser(tokens, options = {}) {\n    const scanner = tokenScanner(tokens);\n    const result = [];\n    let property;\n    while (readable(scanner)) {\n        if (property = consumeProperty(scanner, options)) {\n            result.push(property);\n        }\n        else if (!consume$1(scanner, isSiblingOperator)) {\n            throw error(scanner, 'Unexpected token');\n        }\n    }\n    return result;\n}\n/**\n * Consumes single CSS property\n */\nfunction consumeProperty(scanner, options) {\n    let name;\n    let important = false;\n    let valueFragment;\n    const value = [];\n    const token = peek$2(scanner);\n    const valueMode = !!options.value;\n    if (!valueMode && isLiteral$1(token) && !isFunctionStart(scanner)) {\n        scanner.pos++;\n        name = token.value;\n        // Consume any following value delimiter after property name\n        consume$1(scanner, isValueDelimiter);\n    }\n    // Skip whitespace right after property name, if any\n    if (valueMode) {\n        consume$1(scanner, isWhiteSpace$1);\n    }\n    while (readable(scanner)) {\n        if (consume$1(scanner, isImportant)) {\n            important = true;\n        }\n        else if (valueFragment = consumeValue(scanner, valueMode)) {\n            value.push(valueFragment);\n        }\n        else if (!consume$1(scanner, isFragmentDelimiter)) {\n            break;\n        }\n    }\n    if (name || value.length || important) {\n        return { name, value, important };\n    }\n}\n/**\n * Consumes single value fragment, e.g. all value tokens before comma\n */\nfunction consumeValue(scanner, inArgument) {\n    const result = [];\n    let token;\n    let args;\n    while (readable(scanner)) {\n        token = peek$2(scanner);\n        if (isValue(token)) {\n            scanner.pos++;\n            if (isLiteral$1(token) && (args = consumeArguments(scanner))) {\n                result.push({\n                    type: 'FunctionCall',\n                    name: token.value,\n                    arguments: args\n                });\n            }\n            else {\n                result.push(token);\n            }\n        }\n        else if (isValueDelimiter(token) || (inArgument && isWhiteSpace$1(token))) {\n            scanner.pos++;\n        }\n        else {\n            break;\n        }\n    }\n    return result.length\n        ? { type: 'CSSValue', value: result }\n        : void 0;\n}\nfunction consumeArguments(scanner) {\n    const start = scanner.pos;\n    if (consume$1(scanner, isOpenBracket$1)) {\n        const args = [];\n        let value;\n        while (readable(scanner) && !consume$1(scanner, isCloseBracket$1)) {\n            if (value = consumeValue(scanner, true)) {\n                args.push(value);\n            }\n            else if (!consume$1(scanner, isWhiteSpace$1) && !consume$1(scanner, isArgumentDelimiter)) {\n                throw error(scanner, 'Unexpected token');\n            }\n        }\n        scanner.start = start;\n        return args;\n    }\n}\nfunction isLiteral$1(token) {\n    return token && token.type === 'Literal';\n}\nfunction isBracket$1(token, open) {\n    return token && token.type === 'Bracket' && (open == null || token.open === open);\n}\nfunction isOpenBracket$1(token) {\n    return isBracket$1(token, true);\n}\nfunction isCloseBracket$1(token) {\n    return isBracket$1(token, false);\n}\nfunction isWhiteSpace$1(token) {\n    return token && token.type === 'WhiteSpace';\n}\nfunction isOperator(token, operator) {\n    return token && token.type === 'Operator' && (!operator || token.operator === operator);\n}\nfunction isSiblingOperator(token) {\n    return isOperator(token, \"+\" /* Sibling */);\n}\nfunction isArgumentDelimiter(token) {\n    return isOperator(token, \",\" /* ArgumentDelimiter */);\n}\nfunction isFragmentDelimiter(token) {\n    return isArgumentDelimiter(token);\n}\nfunction isImportant(token) {\n    return isOperator(token, \"!\" /* Important */);\n}\nfunction isValue(token) {\n    return token.type === 'StringValue'\n        || token.type === 'ColorValue'\n        || token.type === 'NumberValue'\n        || token.type === 'Literal'\n        || token.type === 'Field';\n}\nfunction isValueDelimiter(token) {\n    return isOperator(token, \":\" /* PropertyDelimiter */)\n        || isOperator(token, \"-\" /* ValueDelimiter */);\n}\nfunction isFunctionStart(scanner) {\n    const t1 = scanner.tokens[scanner.pos];\n    const t2 = scanner.tokens[scanner.pos + 1];\n    return t1 && t2 && isLiteral$1(t1) && t2.type === 'Bracket';\n}\n\n/**\n * Parses given abbreviation into property set\n */\nfunction parse$2(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize(abbr, options && options.value) : abbr;\n        return parser(tokens, options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\n/**\n * Merges attributes in current node: de-duplicates attributes with the same name\n * and merges class names\n */\nfunction mergeAttributes(node, config) {\n    if (!node.attributes) {\n        return;\n    }\n    const attributes = [];\n    const lookup = {};\n    for (const attr of node.attributes) {\n        if (attr.name) {\n            const attrName = attr.name;\n            if (attrName in lookup) {\n                const prev = lookup[attrName];\n                if (attrName === 'class') {\n                    prev.value = mergeValue(prev.value, attr.value, ' ');\n                }\n                else {\n                    mergeDeclarations(prev, attr, config);\n                }\n            }\n            else {\n                // Create new attribute instance so we can safely modify it later\n                attributes.push(lookup[attrName] = Object.assign({}, attr));\n            }\n        }\n        else {\n            attributes.push(attr);\n        }\n    }\n    node.attributes = attributes;\n}\n/**\n * Merges two token lists into single list. Adjacent strings are merged together\n */\nfunction mergeValue(prev, next, glue) {\n    if (prev && next) {\n        if (prev.length && glue) {\n            append(prev, glue);\n        }\n        for (const t of next) {\n            append(prev, t);\n        }\n        return prev;\n    }\n    const result = prev || next;\n    return result && result.slice();\n}\n/**\n * Merges data from `src` attribute into `dest` and returns it\n */\nfunction mergeDeclarations(dest, src, config) {\n    dest.name = src.name;\n    if (!config.options['output.reverseAttributes']) {\n        dest.value = src.value;\n    }\n    // Keep high-priority properties\n    if (!dest.implied) {\n        dest.implied = src.implied;\n    }\n    if (!dest.boolean) {\n        dest.boolean = src.boolean;\n    }\n    if (dest.valueType !== 'expression') {\n        dest.valueType = src.valueType;\n    }\n    return dest;\n}\nfunction append(tokens, value) {\n    const lastIx = tokens.length - 1;\n    if (typeof tokens[lastIx] === 'string' && typeof value === 'string') {\n        tokens[lastIx] += value;\n    }\n    else {\n        tokens.push(value);\n    }\n}\n\n/**\n * Walks over each child node of given markup abbreviation AST node (not including\n * given one) and invokes `fn` on each node.\n * The `fn` callback accepts context node, list of ancestor nodes and optional\n * state object\n */\nfunction walk(node, fn, state) {\n    const ancestors = [node];\n    const callback = (ctx) => {\n        fn(ctx, ancestors, state);\n        ancestors.push(ctx);\n        ctx.children.forEach(callback);\n        ancestors.pop();\n    };\n    node.children.forEach(callback);\n}\n/**\n * Finds node which is the deepest for in current node or node itself.\n */\nfunction findDeepest(node) {\n    let parent;\n    while (node.children.length) {\n        parent = node;\n        node = node.children[node.children.length - 1];\n    }\n    return { parent, node };\n}\nfunction isNode(node) {\n    return node.type === 'AbbreviationNode';\n}\n\n/**\n * Finds matching snippet from `registry` and resolves it into a parsed abbreviation.\n * Resolved node is then updated or replaced with matched abbreviation tree.\n *\n * A HTML registry basically contains aliases to another Emmet abbreviations,\n * e.g. a predefined set of name, attributes and so on, possibly a complex\n * abbreviation with multiple elements. So we have to get snippet, parse it\n * and recursively resolve it.\n */\nfunction resolveSnippets(abbr, config) {\n    const stack = [];\n    const reversed = config.options['output.reverseAttributes'];\n    const resolve = (child) => {\n        const snippet = child.name && config.snippets[child.name];\n        // A snippet in stack means circular reference.\n        // It can be either a user error or a perfectly valid snippet like\n        // \"img\": \"img[src alt]/\", e.g. an element with predefined shape.\n        // In any case, simply stop parsing and keep element as is\n        if (!snippet || stack.includes(snippet)) {\n            return null;\n        }\n        const snippetAbbr = parseAbbreviation(snippet, config);\n        stack.push(snippet);\n        walkResolve(snippetAbbr, resolve);\n        stack.pop();\n        // Add attributes from current node into every top-level node of parsed abbreviation\n        for (const topNode of snippetAbbr.children) {\n            if (child.attributes) {\n                const from = topNode.attributes || [];\n                const to = child.attributes || [];\n                topNode.attributes = reversed ? to.concat(from) : from.concat(to);\n            }\n            mergeNodes(child, topNode);\n        }\n        return snippetAbbr;\n    };\n    walkResolve(abbr, resolve);\n    return abbr;\n}\nfunction walkResolve(node, resolve, config) {\n    let children = [];\n    for (const child of node.children) {\n        const resolved = resolve(child);\n        if (resolved) {\n            children = children.concat(resolved.children);\n            const deepest = findDeepest(resolved);\n            if (isNode(deepest.node)) {\n                deepest.node.children = deepest.node.children.concat(walkResolve(child, resolve));\n            }\n        }\n        else {\n            children.push(child);\n            child.children = walkResolve(child, resolve);\n        }\n    }\n    return node.children = children;\n}\n/**\n * Adds data from first node into second node\n */\nfunction mergeNodes(from, to) {\n    if (from.selfClosing) {\n        to.selfClosing = true;\n    }\n    if (from.value != null) {\n        to.value = from.value;\n    }\n    if (from.repeat) {\n        to.repeat = from.repeat;\n    }\n}\n\nfunction createOutputStream(options, level = 0) {\n    return {\n        options,\n        value: '',\n        level,\n        offset: 0,\n        line: 0,\n        column: 0\n    };\n}\n/**\n * Pushes plain string into output stream without newline processing\n */\nfunction push(stream, text) {\n    const processText = stream.options['output.text'];\n    _push(stream, processText(text, stream.offset, stream.line, stream.column));\n}\n/**\n * Pushes given string with possible newline formatting into output\n */\nfunction pushString(stream, value) {\n    // If given value contains newlines, we should push content line-by-line and\n    // use `pushNewline()` to maintain proper line/column state\n    const lines = splitByLines(value);\n    for (let i = 0, il = lines.length - 1; i <= il; i++) {\n        push(stream, lines[i]);\n        if (i !== il) {\n            pushNewline(stream, true);\n        }\n    }\n}\n/**\n * Pushes new line into given output stream\n */\nfunction pushNewline(stream, indent) {\n    const baseIndent = stream.options['output.baseIndent'];\n    const newline = stream.options['output.newline'];\n    push(stream, newline + baseIndent);\n    stream.line++;\n    stream.column = baseIndent.length;\n    if (indent) {\n        pushIndent(stream, indent === true ? stream.level : indent);\n    }\n}\n/**\n * Adds indentation of `size` to current output stream\n */\nfunction pushIndent(stream, size = stream.level) {\n    const indent = stream.options['output.indent'];\n    push(stream, indent.repeat(Math.max(size, 0)));\n}\n/**\n * Pushes field/tabstop into output stream\n */\nfunction pushField(stream, index, placeholder) {\n    const field = stream.options['output.field'];\n    // NB: use `_push` instead of `push` to skip text processing\n    _push(stream, field(index, placeholder, stream.offset, stream.line, stream.column));\n}\n/**\n * Returns given tag name formatted according to given config\n */\nfunction tagName(name, config) {\n    return strCase(name, config.options['output.tagCase']);\n}\n/**\n * Returns given attribute name formatted according to given config\n */\nfunction attrName(name, config) {\n    return strCase(name, config.options['output.attributeCase']);\n}\n/**\n * Returns character for quoting value of given attribute\n */\nfunction attrQuote(attr, config, isOpen) {\n    if (attr.valueType === 'expression') {\n        return isOpen ? '{' : '}';\n    }\n    return config.options['output.attributeQuotes'] === 'single' ? '\\'' : '\"';\n}\n/**\n * Check if given attribute is boolean\n */\nfunction isBooleanAttribute(attr, config) {\n    return attr.boolean\n        || config.options['output.booleanAttributes'].includes((attr.name || '').toLowerCase());\n}\n/**\n * Returns a token for self-closing tag, depending on current options\n */\nfunction selfClose(config) {\n    switch (config.options['output.selfClosingStyle']) {\n        case 'xhtml': return ' /';\n        case 'xml': return '/';\n        default: return '';\n    }\n}\n/**\n * Check if given tag name belongs to inline-level element\n * @param node Parsed node or tag name\n */\nfunction isInline(node, config) {\n    if (typeof node === 'string') {\n        return config.options.inlineElements.includes(node.toLowerCase());\n    }\n    // inline node is a node either with inline-level name or text-only node\n    return node.name ? isInline(node.name, config) : Boolean(node.value && !node.attributes);\n}\n/**\n * Splits given text by lines\n */\nfunction splitByLines(text) {\n    return text.split(/\\r\\n|\\r|\\n/g);\n}\n/**\n * Pushes raw string into output stream without any processing\n */\nfunction _push(stream, text) {\n    stream.value += text;\n    stream.offset += text.length;\n    stream.column += text.length;\n}\nfunction strCase(str, type) {\n    if (type) {\n        return type === 'upper' ? str.toUpperCase() : str.toLowerCase();\n    }\n    return str;\n}\n\nconst elementMap = {\n    p: 'span',\n    ul: 'li',\n    ol: 'li',\n    table: 'tr',\n    tr: 'td',\n    tbody: 'tr',\n    thead: 'tr',\n    tfoot: 'tr',\n    colgroup: 'col',\n    select: 'option',\n    optgroup: 'option',\n    audio: 'source',\n    video: 'source',\n    object: 'param',\n    map: 'area'\n};\nfunction implicitTag(node, ancestors, config) {\n    if (!node.name && node.attributes) {\n        resolveImplicitTag(node, ancestors, config);\n    }\n}\nfunction resolveImplicitTag(node, ancestors, config) {\n    const parent = getParentElement(ancestors);\n    const contextName = config.context ? config.context.name : '';\n    const parentName = lowercase(parent ? parent.name : contextName);\n    node.name = elementMap[parentName]\n        || (isInline(parentName, config) ? 'span' : 'div');\n}\nfunction lowercase(str) {\n    return (str || '').toLowerCase();\n}\n/**\n * Returns closest element node from given ancestors list\n */\nfunction getParentElement(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const elem = ancestors[i];\n        if (isNode(elem)) {\n            return elem;\n        }\n    }\n}\n\nvar latin = {\n\t\"common\": [\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\", \"consectetur\", \"adipisicing\", \"elit\"],\n\t\"words\": [\"exercitationem\", \"perferendis\", \"perspiciatis\", \"laborum\", \"eveniet\",\n\t\t\"sunt\", \"iure\", \"nam\", \"nobis\", \"eum\", \"cum\", \"officiis\", \"excepturi\",\n\t\t\"odio\", \"consectetur\", \"quasi\", \"aut\", \"quisquam\", \"vel\", \"eligendi\",\n\t\t\"itaque\", \"non\", \"odit\", \"tempore\", \"quaerat\", \"dignissimos\",\n\t\t\"facilis\", \"neque\", \"nihil\", \"expedita\", \"vitae\", \"vero\", \"ipsum\",\n\t\t\"nisi\", \"animi\", \"cumque\", \"pariatur\", \"velit\", \"modi\", \"natus\",\n\t\t\"iusto\", \"eaque\", \"sequi\", \"illo\", \"sed\", \"ex\", \"et\", \"voluptatibus\",\n\t\t\"tempora\", \"veritatis\", \"ratione\", \"assumenda\", \"incidunt\", \"nostrum\",\n\t\t\"placeat\", \"aliquid\", \"fuga\", \"provident\", \"praesentium\", \"rem\",\n\t\t\"necessitatibus\", \"suscipit\", \"adipisci\", \"quidem\", \"possimus\",\n\t\t\"voluptas\", \"debitis\", \"sint\", \"accusantium\", \"unde\", \"sapiente\",\n\t\t\"voluptate\", \"qui\", \"aspernatur\", \"laudantium\", \"soluta\", \"amet\",\n\t\t\"quo\", \"aliquam\", \"saepe\", \"culpa\", \"libero\", \"ipsa\", \"dicta\",\n\t\t\"reiciendis\", \"nesciunt\", \"doloribus\", \"autem\", \"impedit\", \"minima\",\n\t\t\"maiores\", \"repudiandae\", \"ipsam\", \"obcaecati\", \"ullam\", \"enim\",\n\t\t\"totam\", \"delectus\", \"ducimus\", \"quis\", \"voluptates\", \"dolores\",\n\t\t\"molestiae\", \"harum\", \"dolorem\", \"quia\", \"voluptatem\", \"molestias\",\n\t\t\"magni\", \"distinctio\", \"omnis\", \"illum\", \"dolorum\", \"voluptatum\", \"ea\",\n\t\t\"quas\", \"quam\", \"corporis\", \"quae\", \"blanditiis\", \"atque\", \"deserunt\",\n\t\t\"laboriosam\", \"earum\", \"consequuntur\", \"hic\", \"cupiditate\",\n\t\t\"quibusdam\", \"accusamus\", \"ut\", \"rerum\", \"error\", \"minus\", \"eius\",\n\t\t\"ab\", \"ad\", \"nemo\", \"fugit\", \"officia\", \"at\", \"in\", \"id\", \"quos\",\n\t\t\"reprehenderit\", \"numquam\", \"iste\", \"fugiat\", \"sit\", \"inventore\",\n\t\t\"beatae\", \"repellendus\", \"magnam\", \"recusandae\", \"quod\", \"explicabo\",\n\t\t\"doloremque\", \"aperiam\", \"consequatur\", \"asperiores\", \"commodi\",\n\t\t\"optio\", \"dolor\", \"labore\", \"temporibus\", \"repellat\", \"veniam\",\n\t\t\"architecto\", \"est\", \"esse\", \"mollitia\", \"nulla\", \"a\", \"similique\",\n\t\t\"eos\", \"alias\", \"dolore\", \"tenetur\", \"deleniti\", \"porro\", \"facere\",\n\t\t\"maxime\", \"corrupti\"]\n};\n\nvar ru = {\n\t\"common\": [\"далеко-далеко\", \"за\", \"словесными\", \"горами\", \"в стране\", \"гласных\", \"и согласных\", \"живут\", \"рыбные\", \"тексты\"],\n\t\"words\": [\"вдали\", \"от всех\", \"они\", \"буквенных\", \"домах\", \"на берегу\", \"семантика\",\n\t\t\"большого\", \"языкового\", \"океана\", \"маленький\", \"ручеек\", \"даль\",\n\t\t\"журчит\", \"по всей\", \"обеспечивает\", \"ее\",\"всеми\", \"необходимыми\",\n\t\t\"правилами\", \"эта\", \"парадигматическая\", \"страна\", \"которой\", \"жаренные\",\n\t\t\"предложения\", \"залетают\", \"прямо\", \"рот\", \"даже\", \"всемогущая\",\n\t\t\"пунктуация\", \"не\", \"имеет\", \"власти\", \"над\", \"рыбными\", \"текстами\",\n\t\t\"ведущими\", \"безорфографичный\", \"образ\", \"жизни\", \"однажды\", \"одна\",\n\t\t\"маленькая\", \"строчка\",\"рыбного\", \"текста\", \"имени\", \"lorem\", \"ipsum\",\n\t\t\"решила\", \"выйти\", \"большой\", \"мир\", \"грамматики\", \"великий\", \"оксмокс\",\n\t\t\"предупреждал\", \"о\", \"злых\", \"запятых\", \"диких\", \"знаках\", \"вопроса\",\n\t\t\"коварных\", \"точках\", \"запятой\", \"но\", \"текст\", \"дал\", \"сбить\",\n\t\t\"себя\", \"толку\", \"он\", \"собрал\", \"семь\", \"своих\", \"заглавных\", \"букв\",\n\t\t\"подпоясал\", \"инициал\", \"за\", \"пояс\", \"пустился\", \"дорогу\",\n\t\t\"взобравшись\", \"первую\", \"вершину\", \"курсивных\", \"гор\", \"бросил\",\n\t\t\"последний\", \"взгляд\", \"назад\", \"силуэт\", \"своего\", \"родного\", \"города\",\n\t\t\"буквоград\", \"заголовок\", \"деревни\", \"алфавит\", \"подзаголовок\", \"своего\",\n\t\t\"переулка\", \"грустный\", \"реторический\", \"вопрос\", \"скатился\", \"его\",\n\t\t\"щеке\", \"продолжил\", \"свой\", \"путь\", \"дороге\", \"встретил\", \"рукопись\",\n\t\t\"она\", \"предупредила\",  \"моей\", \"все\", \"переписывается\", \"несколько\",\n\t\t\"раз\", \"единственное\", \"что\", \"меня\", \"осталось\", \"это\", \"приставка\",\n\t\t\"возвращайся\", \"ты\", \"лучше\", \"свою\", \"безопасную\", \"страну\", \"послушавшись\",\n\t\t\"рукописи\", \"наш\", \"продолжил\", \"свой\", \"путь\", \"вскоре\", \"ему\",\n\t\t\"повстречался\", \"коварный\", \"составитель\", \"рекламных\", \"текстов\",\n\t\t\"напоивший\", \"языком\", \"речью\", \"заманивший\", \"свое\", \"агентство\",\n\t\t\"которое\", \"использовало\", \"снова\", \"снова\", \"своих\", \"проектах\",\n\t\t\"если\", \"переписали\", \"то\", \"живет\", \"там\", \"до\", \"сих\", \"пор\"]\n};\n\nvar sp = {\n\t\"common\": [\"mujer\", \"uno\", \"dolor\", \"más\", \"de\", \"poder\", \"mismo\", \"si\"],\n\t\"words\": [\"ejercicio\", \"preferencia\", \"perspicacia\", \"laboral\", \"paño\",\n\t\t\"suntuoso\", \"molde\", \"namibia\", \"planeador\", \"mirar\", \"demás\", \"oficinista\", \"excepción\",\n\t\t\"odio\", \"consecuencia\", \"casi\", \"auto\", \"chicharra\", \"velo\", \"elixir\",\n\t\t\"ataque\", \"no\", \"odio\", \"temporal\", \"cuórum\", \"dignísimo\",\n\t\t\"facilismo\", \"letra\", \"nihilista\", \"expedición\", \"alma\", \"alveolar\", \"aparte\",\n\t\t\"león\", \"animal\", \"como\", \"paria\", \"belleza\", \"modo\", \"natividad\",\n\t\t\"justo\", \"ataque\", \"séquito\", \"pillo\", \"sed\", \"ex\", \"y\", \"voluminoso\",\n\t\t\"temporalidad\", \"verdades\", \"racional\", \"asunción\", \"incidente\", \"marejada\",\n\t\t\"placenta\", \"amanecer\", \"fuga\", \"previsor\", \"presentación\", \"lejos\",\n\t\t\"necesariamente\", \"sospechoso\", \"adiposidad\", \"quindío\", \"pócima\",\n\t\t\"voluble\", \"débito\", \"sintió\", \"accesorio\", \"falda\", \"sapiencia\",\n\t\t\"volutas\", \"queso\", \"permacultura\", \"laudo\", \"soluciones\", \"entero\",\n\t\t\"pan\", \"litro\", \"tonelada\", \"culpa\", \"libertario\", \"mosca\", \"dictado\",\n\t\t\"reincidente\", \"nascimiento\", \"dolor\", \"escolar\", \"impedimento\", \"mínima\",\n\t\t\"mayores\", \"repugnante\", \"dulce\", \"obcecado\", \"montaña\", \"enigma\",\n\t\t\"total\", \"deletéreo\", \"décima\", \"cábala\", \"fotografía\", \"dolores\",\n\t\t\"molesto\", \"olvido\", \"paciencia\", \"resiliencia\", \"voluntad\", \"molestias\",\n\t\t\"magnífico\", \"distinción\", \"ovni\", \"marejada\", \"cerro\", \"torre\", \"y\",\n\t\t\"abogada\", \"manantial\", \"corporal\", \"agua\", \"crepúsculo\", \"ataque\", \"desierto\",\n\t\t\"laboriosamente\", \"angustia\", \"afortunado\", \"alma\", \"encefalograma\",\n\t\t\"materialidad\", \"cosas\", \"o\", \"renuncia\", \"error\", \"menos\", \"conejo\",\n\t\t\"abadía\", \"analfabeto\", \"remo\", \"fugacidad\", \"oficio\", \"en\", \"almácigo\", \"vos\", \"pan\",\n\t\t\"represión\", \"números\", \"triste\", \"refugiado\", \"trote\", \"inventor\",\n\t\t\"corchea\", \"repelente\", \"magma\", \"recusado\", \"patrón\", \"explícito\",\n\t\t\"paloma\", \"síndrome\", \"inmune\", \"autoinmune\", \"comodidad\",\n\t\t\"ley\", \"vietnamita\", \"demonio\", \"tasmania\", \"repeler\", \"apéndice\",\n\t\t\"arquitecto\", \"columna\", \"yugo\", \"computador\", \"mula\", \"a\", \"propósito\",\n\t\t\"fantasía\", \"alias\", \"rayo\", \"tenedor\", \"deleznable\", \"ventana\", \"cara\",\n\t\t\"anemia\", \"corrupto\"]\n};\n\nconst vocabularies = { ru, sp, latin };\nconst reLorem = /^lorem([a-z]*)(\\d*)(-\\d*)?$/i;\nfunction lorem(node, ancestors, config) {\n    let m;\n    if (node.name && (m = node.name.match(reLorem))) {\n        const db = vocabularies[m[1]] || vocabularies.latin;\n        const minWordCount = m[2] ? Math.max(1, Number(m[2])) : 30;\n        const maxWordCount = m[3] ? Math.max(minWordCount, Number(m[3].slice(1))) : minWordCount;\n        const wordCount = rand(minWordCount, maxWordCount);\n        const repeat = node.repeat || findRepeater(ancestors);\n        node.name = node.attributes = void 0;\n        node.value = [paragraph(db, wordCount, !repeat || repeat.value === 0)];\n        if (node.repeat && ancestors.length > 1) {\n            resolveImplicitTag(node, ancestors, config);\n        }\n    }\n}\n/**\n * Returns random integer between <code>from</code> and <code>to</code> values\n */\nfunction rand(from, to) {\n    return Math.floor(Math.random() * (to - from) + from);\n}\nfunction sample(arr, count) {\n    const len = arr.length;\n    const iterations = Math.min(len, count);\n    const result = [];\n    while (result.length < iterations) {\n        const str = arr[rand(0, len)];\n        if (!result.includes(str)) {\n            result.push(str);\n        }\n    }\n    return result;\n}\nfunction choice(val) {\n    return val[rand(0, val.length - 1)];\n}\nfunction sentence(words, end) {\n    if (words.length) {\n        words = [capitalize(words[0])].concat(words.slice(1));\n    }\n    return words.join(' ') + (end || choice('?!...')); // more dots than question marks\n}\nfunction capitalize(word) {\n    return word[0].toUpperCase() + word.slice(1);\n}\n/**\n * Insert commas at randomly selected words. This function modifies values\n * inside `words` array\n */\nfunction insertCommas(words) {\n    if (words.length < 2) {\n        return words;\n    }\n    words = words.slice();\n    const len = words.length;\n    const hasComma = /,$/;\n    let totalCommas = 0;\n    if (len > 3 && len <= 6) {\n        totalCommas = rand(0, 1);\n    }\n    else if (len > 6 && len <= 12) {\n        totalCommas = rand(0, 2);\n    }\n    else {\n        totalCommas = rand(1, 4);\n    }\n    for (let i = 0, pos; i < totalCommas; i++) {\n        pos = rand(0, len - 2);\n        if (!hasComma.test(words[pos])) {\n            words[pos] += ',';\n        }\n    }\n    return words;\n}\n/**\n * Generate a paragraph of \"Lorem ipsum\" text\n * @param dict Words dictionary\n * @param wordCount Words count in paragraph\n * @param startWithCommon Should paragraph start with common \"lorem ipsum\" sentence.\n */\nfunction paragraph(dict, wordCount, startWithCommon) {\n    const result = [];\n    let totalWords = 0;\n    let words;\n    if (startWithCommon && dict.common) {\n        words = dict.common.slice(0, wordCount);\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words), '.'));\n    }\n    while (totalWords < wordCount) {\n        words = sample(dict.words, Math.min(rand(2, 30), wordCount - totalWords));\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words)));\n    }\n    return result.join(' ');\n}\nfunction findRepeater(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const element = ancestors[i];\n        if (element.type === 'AbbreviationNode' && element.repeat) {\n            return element.repeat;\n        }\n    }\n}\n\n/**\n * JSX transformer: replaces `class` and `for` attributes with `className` and\n * `htmlFor` attributes respectively\n */\nfunction jsx(node) {\n    if (node.attributes) {\n        node.attributes.forEach(rename);\n    }\n}\nfunction rename(attr) {\n    if (attr.name === 'class') {\n        attr.name = 'className';\n    }\n    else if (attr.name === 'for') {\n        attr.name = 'htmlFor';\n    }\n}\n\n/**\n * XSL transformer: removes `select` attributes from certain nodes that contain\n * children\n */\nfunction xsl(node) {\n    if (matchesName(node.name) && node.attributes && (node.children.length || node.value)) {\n        node.attributes = node.attributes.filter(isAllowed);\n    }\n}\nfunction isAllowed(attr) {\n    return attr.name !== 'select';\n}\nfunction matchesName(name) {\n    return name === 'xsl:variable' || name === 'xsl:with-param';\n}\n\nconst reElement = /^(-+)([a-z0-9]+[a-z0-9-]*)/i;\nconst reModifier = /^(_+)([a-z0-9]+[a-z0-9-_]*)/i;\nconst blockCandidates1 = (className) => /^[a-z]\\-/i.test(className);\nconst blockCandidates2 = (className) => /^[a-z]/i.test(className);\nfunction bem(node, ancestors, config) {\n    expandClassNames(node);\n    expandShortNotation(node, ancestors, config);\n}\n/**\n * Expands existing class names in BEM notation in given `node`.\n * For example, if node contains `b__el_mod` class name, this method ensures\n * that element contains `b__el` class as well\n */\nfunction expandClassNames(node) {\n    const data = getBEMData(node);\n    const classNames = [];\n    for (const cl of data.classNames) {\n        // remove all modifiers and element prefixes from class name to get a base element name\n        const ix = cl.indexOf('_');\n        if (ix > 0 && !cl.startsWith('-')) {\n            classNames.push(cl.slice(0, ix));\n            classNames.push(cl.slice(ix));\n        }\n        else {\n            classNames.push(cl);\n        }\n    }\n    if (classNames.length) {\n        data.classNames = classNames.filter(uniqueClass);\n        data.block = findBlockName(data.classNames);\n        updateClass(node, data.classNames.join(' '));\n    }\n}\n/**\n * Expands short BEM notation, e.g. `-element` and `_modifier`\n */\nfunction expandShortNotation(node, ancestors, config) {\n    const data = getBEMData(node);\n    const classNames = [];\n    const { options } = config;\n    const path = ancestors.slice(1).concat(node);\n    for (let cl of data.classNames) {\n        let prefix = '';\n        let m;\n        const originalClass = cl;\n        // parse element definition (could be only one)\n        if (m = cl.match(reElement)) {\n            prefix = getBlockName(path, m[1].length, config.context) + options['bem.element'] + m[2];\n            classNames.push(prefix);\n            cl = cl.slice(m[0].length);\n        }\n        // parse modifiers definitions\n        if (m = cl.match(reModifier)) {\n            if (!prefix) {\n                prefix = getBlockName(path, m[1].length);\n                classNames.push(prefix);\n            }\n            classNames.push(`${prefix}${options['bem.modifier']}${m[2]}`);\n            cl = cl.slice(m[0].length);\n        }\n        if (cl === originalClass) {\n            // class name wasn’t modified: it’s not a BEM-specific class,\n            // add it as-is into output\n            classNames.push(originalClass);\n        }\n    }\n    const arrClassNames = classNames.filter(uniqueClass);\n    if (arrClassNames.length) {\n        updateClass(node, arrClassNames.join(' '));\n    }\n}\n/**\n * Returns BEM data from given abbreviation node\n */\nfunction getBEMData(node) {\n    if (!node._bem) {\n        let classValue = '';\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (attr.name === 'class' && attr.value) {\n                    classValue = stringifyValue(attr.value);\n                    break;\n                }\n            }\n        }\n        node._bem = parseBEM(classValue);\n    }\n    return node._bem;\n}\nfunction getBEMDataFromContext(context) {\n    if (!context._bem) {\n        context._bem = parseBEM(context.attributes && context.attributes.class || '');\n    }\n    return context._bem;\n}\n/**\n * Parses BEM data from given class name\n */\nfunction parseBEM(classValue) {\n    const classNames = classValue ? classValue.split(/\\s+/) : [];\n    return {\n        classNames,\n        block: findBlockName(classNames)\n    };\n}\n/**\n * Returns block name for given `node` by `prefix`, which tells the depth of\n * of parent node lookup\n */\nfunction getBlockName(ancestors, depth = 0, context) {\n    const maxParentIx = 0;\n    let parentIx = Math.max(ancestors.length - depth, maxParentIx);\n    do {\n        const parent = ancestors[parentIx];\n        if (parent) {\n            const data = getBEMData(parent);\n            if (data.block) {\n                return data.block;\n            }\n        }\n    } while (maxParentIx < parentIx--);\n    if (context) {\n        const data = getBEMDataFromContext(context);\n        if (data.block) {\n            return data.block;\n        }\n    }\n    return '';\n}\nfunction findBlockName(classNames) {\n    return find(classNames, blockCandidates1)\n        || find(classNames, blockCandidates2)\n        || void 0;\n}\n/**\n * Finds class name from given list which may be used as block name\n */\nfunction find(classNames, filter) {\n    for (const cl of classNames) {\n        if (reElement.test(cl) || reModifier.test(cl)) {\n            break;\n        }\n        if (filter(cl)) {\n            return cl;\n        }\n    }\n}\nfunction updateClass(node, value) {\n    for (const attr of node.attributes) {\n        if (attr.name === 'class') {\n            attr.value = [value];\n            break;\n        }\n    }\n}\nfunction stringifyValue(value) {\n    let result = '';\n    for (const t of value) {\n        result += typeof t === 'string' ? t : t.name;\n    }\n    return result;\n}\nfunction uniqueClass(item, ix, arr) {\n    return !!item && arr.indexOf(item) === ix;\n}\n\nfunction walk$1(abbr, visitor, state) {\n    const callback = (ctx, index, items) => {\n        const { parent, current } = state;\n        state.parent = current;\n        state.current = ctx;\n        visitor(ctx, index, items, state, next);\n        state.current = current;\n        state.parent = parent;\n    };\n    const next = (node, index, items) => {\n        state.ancestors.push(state.current);\n        callback(node, index, items);\n        state.ancestors.pop();\n    };\n    abbr.children.forEach(callback);\n}\nfunction createWalkState(config) {\n    return {\n        // @ts-ignore: Will set value in iterator\n        current: null,\n        parent: void 0,\n        ancestors: [],\n        config,\n        field: 1,\n        out: createOutputStream(config.options)\n    };\n}\n\nconst caret = [{ type: 'Field', index: 0, name: '' }];\n/**\n * Check if given node is a snippet: a node without name and attributes\n */\nfunction isSnippet(node) {\n    return node ? !node.name && !node.attributes : false;\n}\n/**\n * Check if given node is inline-level element, e.g. element with explicitly\n * defined node name\n */\nfunction isInlineElement(node, config) {\n    return node ? isInline(node, config) : false;\n}\n/**\n * Check if given value token is a field\n */\nfunction isField(token) {\n    return typeof token === 'object' && token.type === 'Field';\n}\nfunction pushTokens(tokens, state) {\n    const { out } = state;\n    let largestIndex = -1;\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            pushString(out, t);\n        }\n        else {\n            pushField(out, state.field + t.index, t.name);\n            if (t.index > largestIndex) {\n                largestIndex = t.index;\n            }\n        }\n    }\n    if (largestIndex !== -1) {\n        state.field += largestIndex + 1;\n    }\n}\n/**\n * Splits given value token by lines: returns array where each entry is a token list\n * for a single line\n */\nfunction splitByLines$1(tokens) {\n    const result = [];\n    let line = [];\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            const lines = t.split(/\\r\\n?|\\n/g);\n            line.push(lines.shift() || '');\n            while (lines.length) {\n                result.push(line);\n                line = [lines.shift() || ''];\n            }\n        }\n        else {\n            line.push(t);\n        }\n    }\n    line.length && result.push(line);\n    return result;\n}\n/**\n * Check if given attribute should be outputted\n */\nfunction shouldOutputAttribute(attr) {\n    // In case if attribute is implied, check if it has a defined value:\n    // either non-empty value or quoted empty value\n    return !attr.implied || attr.valueType !== 'raw' || (!!attr.value && attr.value.length > 0);\n}\n\n/**\n * Splits given string into template tokens.\n * Template is a string which contains placeholders which are uppercase names\n * between `[` and `]`, for example: `[PLACEHOLDER]`.\n * Unlike other templates, a placeholder may contain extra characters before and\n * after name: `[%PLACEHOLDER.]`. If data for `PLACEHOLDER` is defined, it will\n * be outputted with with these extra character, otherwise will be completely omitted.\n */\nfunction template(text) {\n    const tokens = [];\n    const scanner = { pos: 0, text };\n    let placeholder;\n    let offset = scanner.pos;\n    let pos = scanner.pos;\n    while (scanner.pos < scanner.text.length) {\n        pos = scanner.pos;\n        if (placeholder = consumePlaceholder(scanner)) {\n            if (offset !== scanner.pos) {\n                tokens.push(text.slice(offset, pos));\n            }\n            tokens.push(placeholder);\n            offset = scanner.pos;\n        }\n        else {\n            scanner.pos++;\n        }\n    }\n    if (offset !== scanner.pos) {\n        tokens.push(text.slice(offset));\n    }\n    return tokens;\n}\n/**\n * Consumes placeholder like `[#ID]` from given scanner\n */\nfunction consumePlaceholder(scanner) {\n    if (peek(scanner) === 91 /* Start */) {\n        const start = ++scanner.pos;\n        let namePos = start;\n        let afterPos = start;\n        let stack = 1;\n        while (scanner.pos < scanner.text.length) {\n            const code = peek(scanner);\n            if (isTokenStart(code)) {\n                namePos = scanner.pos;\n                while (isToken(peek(scanner))) {\n                    scanner.pos++;\n                }\n                afterPos = scanner.pos;\n            }\n            else {\n                if (code === 91 /* Start */) {\n                    stack++;\n                }\n                else if (code === 93 /* End */) {\n                    if (--stack === 0) {\n                        return {\n                            before: scanner.text.slice(start, namePos),\n                            after: scanner.text.slice(afterPos, scanner.pos++),\n                            name: scanner.text.slice(namePos, afterPos)\n                        };\n                    }\n                }\n                scanner.pos++;\n            }\n        }\n    }\n}\nfunction peek(scanner, pos = scanner.pos) {\n    return scanner.text.charCodeAt(pos);\n}\nfunction isTokenStart(code) {\n    return code >= 65 && code <= 90; // A-Z\n}\nfunction isToken(code) {\n    return isTokenStart(code)\n        || (code > 47 && code < 58) /* 0-9 */\n        || code === 95 /* Underscore */\n        || code === 45 /* Dash */;\n}\n\nfunction createCommentState(config) {\n    const { options } = config;\n    return {\n        enabled: options['comment.enabled'],\n        trigger: options['comment.trigger'],\n        before: options['comment.before'] ? template(options['comment.before']) : void 0,\n        after: options['comment.after'] ? template(options['comment.after']) : void 0\n    };\n}\n/**\n * Adds comment prefix for given node, if required\n */\nfunction commentNodeBefore(node, state) {\n    if (shouldComment(node, state) && state.comment.before) {\n        output(node, state.comment.before, state);\n    }\n}\n/**\n * Adds comment suffix for given node, if required\n */\nfunction commentNodeAfter(node, state) {\n    if (shouldComment(node, state) && state.comment.after) {\n        output(node, state.comment.after, state);\n    }\n}\n/**\n * Check if given node should be commented\n */\nfunction shouldComment(node, state) {\n    const { comment } = state;\n    if (!comment.enabled || !comment.trigger || !node.name || !node.attributes) {\n        return false;\n    }\n    for (const attr of node.attributes) {\n        if (attr.name && comment.trigger.includes(attr.name)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Pushes given template tokens into output stream\n */\nfunction output(node, tokens, state) {\n    const attrs = {};\n    const { out } = state;\n    // Collect attributes payload\n    for (const attr of node.attributes) {\n        if (attr.name && attr.value) {\n            attrs[attr.name.toUpperCase()] = attr.value;\n        }\n    }\n    // Output parsed tokens\n    for (const token of tokens) {\n        if (typeof token === 'string') {\n            pushString(out, token);\n        }\n        else if (attrs[token.name]) {\n            pushString(out, token.before);\n            pushTokens(attrs[token.name], state);\n            pushString(out, token.after);\n        }\n    }\n}\n\nconst htmlTagRegex = /^<([\\w\\-:]+)[\\s>]/;\nfunction html(abbr, config) {\n    const state = createWalkState(config);\n    state.comment = createCommentState(config);\n    walk$1(abbr, element, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`’s siblings\n * @param state Current walk state\n */\nfunction element(node, index, items, state, next) {\n    const { out, config } = state;\n    const format = shouldFormat(node, index, items, state);\n    // Pick offset level for current node\n    const level = getIndent(state);\n    out.level += level;\n    format && pushNewline(out, true);\n    if (node.name) {\n        const name = tagName(node.name, config);\n        commentNodeBefore(node, state);\n        pushString(out, `<${name}`);\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (shouldOutputAttribute(attr)) {\n                    pushAttribute(attr, state);\n                }\n            }\n        }\n        if (node.selfClosing && !node.children.length && !node.value) {\n            pushString(out, `${selfClose(config)}>`);\n        }\n        else {\n            pushString(out, '>');\n            if (!pushSnippet(node, state, next)) {\n                if (node.value) {\n                    const innerFormat = node.value.some(hasNewline) || startsWithBlockTag(node.value, config);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(node.value, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n                node.children.forEach(next);\n                if (!node.value && !node.children.length) {\n                    const innerFormat = config.options['output.formatLeafNode']\n                        || config.options['output.formatForce'].includes(node.name);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(caret, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n            }\n            pushString(out, `</${name}>`);\n            commentNodeAfter(node, state);\n        }\n    }\n    else if (!pushSnippet(node, state, next) && node.value) {\n        // A text-only node (snippet)\n        pushTokens(node.value, state);\n        node.children.forEach(next);\n    }\n    if (format && index === items.length - 1 && state.parent) {\n        const offset = isSnippet(state.parent) ? 0 : 1;\n        pushNewline(out, out.level - offset);\n    }\n    out.level -= level;\n}\n/**\n * Outputs given attribute’s content into output stream\n */\nfunction pushAttribute(attr, state) {\n    const { out, config } = state;\n    if (attr.name) {\n        const name = attrName(attr.name, config);\n        const lQuote = attrQuote(attr, config, true);\n        const rQuote = attrQuote(attr, config);\n        let value = attr.value;\n        if (isBooleanAttribute(attr, config) && !value) {\n            // If attribute value is omitted and it’s a boolean value, check for\n            // `compactBoolean` option: if it’s disabled, set value to attribute name\n            // (XML style)\n            if (!config.options['output.compactBoolean']) {\n                value = [name];\n            }\n        }\n        else if (!value) {\n            value = caret;\n        }\n        pushString(out, ' ' + name);\n        if (value) {\n            pushString(out, '=' + lQuote);\n            pushTokens(value, state);\n            pushString(out, rQuote);\n        }\n        else if (config.options['output.selfClosingStyle'] !== 'html') {\n            pushString(out, '=' + lQuote + rQuote);\n        }\n    }\n}\nfunction pushSnippet(node, state, next) {\n    if (node.value && node.children.length) {\n        // We have a value and child nodes. In case if value contains fields,\n        // we should output children as a content of first field\n        const fieldIx = node.value.findIndex(isField);\n        if (fieldIx !== -1) {\n            pushTokens(node.value.slice(0, fieldIx), state);\n            const line = state.out.line;\n            let pos = fieldIx + 1;\n            node.children.forEach(next);\n            // If there was a line change, trim leading whitespace for better result\n            if (state.out.line !== line && typeof node.value[pos] === 'string') {\n                pushString(state.out, node.value[pos++].trimLeft());\n            }\n            pushTokens(node.value.slice(pos), state);\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Check if given node should be formatted in its parent context\n */\nfunction shouldFormat(node, index, items, state) {\n    const { config, parent } = state;\n    if (!config.options['output.format']) {\n        return false;\n    }\n    if (index === 0 && !parent) {\n        // Do not format very first node\n        return false;\n    }\n    // Do not format single child of snippet\n    if (parent && isSnippet(parent) && items.length === 1) {\n        return false;\n    }\n    /**\n     * Adjacent text-only/snippet nodes\n     */\n    if (isSnippet(node)) {\n        // Adjacent text-only/snippet nodes\n        const format = isSnippet(items[index - 1]) || isSnippet(items[index + 1])\n            // Has newlines: looks like wrapping code fragment\n            || node.value.some(hasNewline)\n            // Format as wrapper: contains children which will be outputted as field content\n            || (node.value.some(isField) && node.children.length);\n        if (format) {\n            return true;\n        }\n    }\n    if (isInline(node, config)) {\n        // Check if inline node is the next sibling of block-level node\n        if (index === 0) {\n            // First node in parent: format if it’s followed by a block-level element\n            for (let i = 0; i < items.length; i++) {\n                if (!isInline(items[i], config)) {\n                    return true;\n                }\n            }\n        }\n        else if (!isInline(items[index - 1], config)) {\n            // Node is right after block-level element\n            return true;\n        }\n        if (config.options['output.inlineBreak']) {\n            // check for adjacent inline elements before and after current element\n            let adjacentInline = 1;\n            let before = index;\n            let after = index;\n            while (isInlineElement(items[--before], config)) {\n                adjacentInline++;\n            }\n            while (isInlineElement(items[++after], config)) {\n                adjacentInline++;\n            }\n            if (adjacentInline >= config.options['output.inlineBreak']) {\n                return true;\n            }\n        }\n        // Edge case: inline node contains node that should receive formatting\n        for (let i = 0, il = node.children.length; i < il; i++) {\n            if (shouldFormat(node.children[i], i, node.children, state)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    return true;\n}\n/**\n * Returns indentation offset for given node\n */\nfunction getIndent(state) {\n    const { config, parent } = state;\n    if (!parent || isSnippet(parent) || (parent.name && config.options['output.formatSkip'].includes(parent.name))) {\n        return 0;\n    }\n    return 1;\n}\n/**\n * Check if given node value contains newlines\n */\nfunction hasNewline(value) {\n    return typeof value === 'string' && /\\r|\\n/.test(value);\n}\n/**\n * Check if given node value starts with block-level tag\n */\nfunction startsWithBlockTag(value, config) {\n    if (value.length && typeof value[0] === 'string') {\n        const matches = htmlTagRegex.exec(value[0]);\n        if ((matches === null || matches === void 0 ? void 0 : matches.length) && !config.options['inlineElements'].includes(matches[1].toLowerCase())) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction indentFormat(abbr, config, options) {\n    const state = createWalkState(config);\n    state.options = options || {};\n    walk$1(abbr, element$1, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`’s siblings\n * @param state Current walk state\n */\nfunction element$1(node, index, items, state, next) {\n    const { out, options } = state;\n    const { primary, secondary } = collectAttributes(node);\n    // Pick offset level for current node\n    const level = state.parent ? 1 : 0;\n    out.level += level;\n    // Do not indent top-level elements\n    if (shouldFormat$1(node, index, items, state)) {\n        pushNewline(out, true);\n    }\n    if (node.name && (node.name !== 'div' || !primary.length)) {\n        pushString(out, (options.beforeName || '') + node.name + (options.afterName || ''));\n    }\n    pushPrimaryAttributes(primary, state);\n    pushSecondaryAttributes(secondary.filter(shouldOutputAttribute), state);\n    if (node.selfClosing && !node.value && !node.children.length) {\n        if (state.options.selfClose) {\n            pushString(out, state.options.selfClose);\n        }\n    }\n    else {\n        pushValue(node, state);\n        node.children.forEach(next);\n    }\n    out.level -= level;\n}\n/**\n * From given node, collects all attributes as `primary` (id, class) and\n * `secondary` (all the rest) lists. In most indent-based syntaxes, primary attribute\n * has special syntax\n */\nfunction collectAttributes(node) {\n    const primary = [];\n    const secondary = [];\n    if (node.attributes) {\n        for (const attr of node.attributes) {\n            if (isPrimaryAttribute(attr)) {\n                primary.push(attr);\n            }\n            else {\n                secondary.push(attr);\n            }\n        }\n    }\n    return { primary, secondary };\n}\n/**\n * Outputs given attributes as primary into output stream\n */\nfunction pushPrimaryAttributes(attrs, state) {\n    for (const attr of attrs) {\n        if (attr.value) {\n            if (attr.name === 'class') {\n                pushString(state.out, '.');\n                // All whitespace characters must be replaced with dots in class names\n                const tokens = attr.value.map(t => typeof t === 'string' ? t.replace(/\\s+/g, '.') : t);\n                pushTokens(tokens, state);\n            }\n            else {\n                // ID attribute\n                pushString(state.out, '#');\n                pushTokens(attr.value, state);\n            }\n        }\n    }\n}\n/**\n * Outputs given attributes as secondary into output stream\n */\nfunction pushSecondaryAttributes(attrs, state) {\n    if (attrs.length) {\n        const { out, config, options } = state;\n        options.beforeAttribute && pushString(out, options.beforeAttribute);\n        for (let i = 0; i < attrs.length; i++) {\n            const attr = attrs[i];\n            pushString(out, attrName(attr.name || '', config));\n            if (isBooleanAttribute(attr, config) && !attr.value) {\n                if (!config.options['output.compactBoolean'] && options.booleanValue) {\n                    pushString(out, '=' + options.booleanValue);\n                }\n            }\n            else {\n                pushString(out, '=' + attrQuote(attr, config, true));\n                pushTokens(attr.value || caret, state);\n                pushString(out, attrQuote(attr, config));\n            }\n            if (i !== attrs.length - 1 && options.glueAttribute) {\n                pushString(out, options.glueAttribute);\n            }\n        }\n        options.afterAttribute && pushString(out, options.afterAttribute);\n    }\n}\n/**\n * Outputs given node value into state output stream\n */\nfunction pushValue(node, state) {\n    // We should either output value or add caret but for leaf nodes only (no children)\n    if (!node.value && node.children.length) {\n        return;\n    }\n    const value = node.value || caret;\n    const lines = splitByLines$1(value);\n    const { out, options } = state;\n    if (lines.length === 1) {\n        if (node.name || node.attributes) {\n            push(out, ' ');\n        }\n        pushTokens(value, state);\n    }\n    else {\n        // We should format multi-line value with terminating `|` character\n        // and same line length\n        const lineLengths = [];\n        let maxLength = 0;\n        // Calculate lengths of all lines and max line length\n        for (const line of lines) {\n            const len = valueLength(line);\n            lineLengths.push(len);\n            if (len > maxLength) {\n                maxLength = len;\n            }\n        }\n        // Output each line, padded to max length\n        out.level++;\n        for (let i = 0; i < lines.length; i++) {\n            pushNewline(out, true);\n            options.beforeTextLine && push(out, options.beforeTextLine);\n            pushTokens(lines[i], state);\n            if (options.afterTextLine) {\n                push(out, ' '.repeat(maxLength - lineLengths[i]));\n                push(out, options.afterTextLine);\n            }\n        }\n        out.level--;\n    }\n}\nfunction isPrimaryAttribute(attr) {\n    return attr.name === 'class' || attr.name === 'id';\n}\n/**\n * Calculates string length from given tokens\n */\nfunction valueLength(tokens) {\n    let len = 0;\n    for (const token of tokens) {\n        len += typeof token === 'string' ? token.length : token.name.length;\n    }\n    return len;\n}\nfunction shouldFormat$1(node, index, items, state) {\n    // Do not format first top-level element or snippets\n    if (!state.parent && index === 0) {\n        return false;\n    }\n    return !isSnippet(node);\n}\n\nfunction haml(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeName: '%',\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ' ',\n        afterTextLine: ' |',\n        booleanValue: 'true',\n        selfClose: '/'\n    });\n}\n\nfunction slim(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: ' ',\n        glueAttribute: ' ',\n        beforeTextLine: '| ',\n        selfClose: '/'\n    });\n}\n\nfunction pug(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ', ',\n        beforeTextLine: '| ',\n        selfClose: config.options['output.selfClosingStyle'] === 'xml' ? '/' : ''\n    });\n}\n\nconst formatters = { html, haml, slim, pug };\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse(abbr, config) {\n    let oldTextValue;\n    if (typeof abbr === 'string') {\n        let parseOpt = config;\n        if (config.options['jsx.enabled']) {\n            parseOpt = Object.assign(Object.assign({}, parseOpt), { jsx: true });\n        }\n        if (config.options['markup.href']) {\n            parseOpt = Object.assign(Object.assign({}, parseOpt), { href: true });\n        }\n        abbr = parseAbbreviation(abbr, parseOpt);\n        // remove text field before snippets(abbr, config) call\n        // as abbreviation(abbr, parseOpt) already handled it\n        oldTextValue = config.text;\n        config.text = undefined;\n    }\n    // Run abbreviation resolve in two passes:\n    // 1. Map each node to snippets, which are abbreviations as well. A single snippet\n    // may produce multiple nodes\n    // 2. Transform every resolved node\n    abbr = resolveSnippets(abbr, config);\n    walk(abbr, transform, config);\n    config.text = oldTextValue !== null && oldTextValue !== void 0 ? oldTextValue : config.text;\n    return abbr;\n}\n/**\n * Converts given abbreviation to string according to provided `config`\n */\nfunction stringify(abbr, config) {\n    const formatter = formatters[config.syntax] || html;\n    return formatter(abbr, config);\n}\n/**\n * Modifies given node and prepares it for output\n */\nfunction transform(node, ancestors, config) {\n    implicitTag(node, ancestors, config);\n    mergeAttributes(node, config);\n    lorem(node, ancestors, config);\n    if (config.syntax === 'xsl') {\n        xsl(node);\n    }\n    if (config.options['jsx.enabled']) {\n        jsx(node);\n    }\n    if (config.options['bem.enabled']) {\n        bem(node, ancestors, config);\n    }\n}\n\nconst reProperty = /^([a-z-]+)(?:\\s*:\\s*([^\\n\\r;]+?);*)?$/;\nconst opt = { value: true };\n/**\n * Creates structure for holding resolved CSS snippet\n */\nfunction createSnippet(key, value) {\n    // A snippet could be a raw text snippet (e.g. arbitrary text string) or a\n    // CSS property with possible values separated by `|`.\n    // In latter case, we have to parse snippet as CSS abbreviation\n    const m = value.match(reProperty);\n    if (m) {\n        const keywords = {};\n        const parsed = m[2] ? m[2].split('|').map(parseValue) : [];\n        for (const item of parsed) {\n            for (const cssVal of item) {\n                collectKeywords(cssVal, keywords);\n            }\n        }\n        return {\n            type: \"Property\" /* Property */,\n            key,\n            property: m[1],\n            value: parsed,\n            keywords,\n            dependencies: []\n        };\n    }\n    return { type: \"Raw\" /* Raw */, key, value };\n}\n/**\n * Nests more specific CSS properties into shorthand ones, e.g.\n * `background-position-x` -> `background-position` -> `background`\n */\nfunction nest(snippets) {\n    snippets = snippets.slice().sort(snippetsSort);\n    const stack = [];\n    let prev;\n    // For sorted list of CSS properties, create dependency graph where each\n    // shorthand property contains its more specific one, e.g.\n    // background -> background-position -> background-position-x\n    for (const cur of snippets.filter(isProperty)) {\n        // Check if current property belongs to one from parent stack.\n        // Since `snippets` array is sorted, items are perfectly aligned\n        // from shorthands to more specific variants\n        while (stack.length) {\n            prev = stack[stack.length - 1];\n            if (cur.property.startsWith(prev.property)\n                && cur.property.charCodeAt(prev.property.length) === 45 /* - */) {\n                prev.dependencies.push(cur);\n                stack.push(cur);\n                break;\n            }\n            stack.pop();\n        }\n        if (!stack.length) {\n            stack.push(cur);\n        }\n    }\n    return snippets;\n}\n/**\n * A sorting function for array of snippets\n */\nfunction snippetsSort(a, b) {\n    if (a.key === b.key) {\n        return 0;\n    }\n    return a.key < b.key ? -1 : 1;\n}\nfunction parseValue(value) {\n    return parse$2(value.trim(), opt)[0].value;\n}\nfunction isProperty(snippet) {\n    return snippet.type === \"Property\" /* Property */;\n}\nfunction collectKeywords(cssVal, dest) {\n    for (const v of cssVal.value) {\n        if (v.type === 'Literal') {\n            dest[v.value] = v;\n        }\n        else if (v.type === 'FunctionCall') {\n            dest[v.name] = v;\n        }\n        else if (v.type === 'Field') {\n            // Create literal from field, if available\n            const value = v.name.trim();\n            if (value) {\n                dest[value] = { type: 'Literal', value };\n            }\n        }\n    }\n}\n\n/**\n * Calculates how close `str1` matches `str2` using fuzzy match.\n * How matching works:\n * – first characters of both `str1` and `str2` *must* match\n * – `str1` length larger than `str2` length is allowed only when `unmatched` is true\n * – ideal match is when `str1` equals to `str2` (score: 1)\n * – next best match is `str2` starts with `str1` (score: 1 × percent of matched characters)\n * – other scores depend on how close characters of `str1` to the beginning of `str2`\n * @param partialMatch Allow length `str1` to be greater than `str2` length\n */\nfunction scoreMatch(str1, str2, partialMatch = false) {\n    str1 = str1.toLowerCase();\n    str2 = str2.toLowerCase();\n    if (str1 === str2) {\n        return 1;\n    }\n    // Both strings MUST start with the same character\n    if (!str1 || !str2 || str1.charCodeAt(0) !== str2.charCodeAt(0)) {\n        return 0;\n    }\n    const str1Len = str1.length;\n    const str2Len = str2.length;\n    if (!partialMatch && str1Len > str2Len) {\n        return 0;\n    }\n    // Characters from `str1` which are closer to the beginning of a `str2` should\n    // have higher score.\n    // For example, if `str2` is `abcde`, it’s max score is:\n    // 5 + 4 + 3 + 2 + 1 = 15 (sum of character positions in reverse order)\n    // Matching `abd` against `abcde` should produce:\n    // 5 + 4 + 2 = 11\n    // Acronym bonus for match right after `-`. Matching `abd` against `abc-de`\n    // should produce:\n    // 6 + 5 + 4 (use `d` position in `abd`, not in abc-de`)\n    const minLength = Math.min(str1Len, str2Len);\n    const maxLength = Math.max(str1Len, str2Len);\n    let i = 1;\n    let j = 1;\n    let score = maxLength;\n    let ch1 = 0;\n    let ch2 = 0;\n    let found = false;\n    let acronym = false;\n    while (i < str1Len) {\n        ch1 = str1.charCodeAt(i);\n        found = false;\n        acronym = false;\n        while (j < str2Len) {\n            ch2 = str2.charCodeAt(j);\n            if (ch1 === ch2) {\n                found = true;\n                score += maxLength - (acronym ? i : j);\n                break;\n            }\n            // add acronym bonus for exactly next match after unmatched `-`\n            acronym = ch2 === 45 /* - */;\n            j++;\n        }\n        if (!found) {\n            if (!partialMatch) {\n                return 0;\n            }\n            break;\n        }\n        i++;\n    }\n    const matchRatio = i / maxLength;\n    const delta = maxLength - minLength;\n    const maxScore = sum(maxLength) - sum(delta);\n    return (score * matchRatio) / maxScore;\n}\n/**\n * Calculates sum of first `n` numbers, e.g. 1+2+3+...n\n */\nfunction sum(n) {\n    return n * (n + 1) / 2;\n}\n\nfunction color(token, shortHex) {\n    if (!token.r && !token.g && !token.b && !token.a) {\n        return 'transparent';\n    }\n    else if (token.a === 1) {\n        return asHex(token, shortHex);\n    }\n    return asRGB(token);\n}\n/**\n * Output given color as hex value\n * @param short Produce short value (e.g. #fff instead of #ffffff), if possible\n */\nfunction asHex(token, short) {\n    const fn = (short && isShortHex(token.r) && isShortHex(token.g) && isShortHex(token.b))\n        ? toShortHex : toHex;\n    return '#' + fn(token.r) + fn(token.g) + fn(token.b);\n}\n/**\n * Output current color as `rgba?(...)` CSS color\n */\nfunction asRGB(token) {\n    const values = [token.r, token.g, token.b];\n    if (token.a !== 1) {\n        values.push(frac(token.a, 8));\n    }\n    return `${values.length === 3 ? 'rgb' : 'rgba'}(${values.join(', ')})`;\n}\nfunction frac(num, digits = 4) {\n    return num.toFixed(digits).replace(/\\.?0+$/, '');\n}\nfunction isShortHex(hex) {\n    return !(hex % 17);\n}\nfunction toShortHex(num) {\n    return (num >> 4).toString(16);\n}\nfunction toHex(num) {\n    return pad(num.toString(16), 2);\n}\nfunction pad(value, len) {\n    while (value.length < len) {\n        value = '0' + value;\n    }\n    return value;\n}\n\nfunction css(abbr, config) {\n    var _a;\n    const out = createOutputStream(config.options);\n    const format = config.options['output.format'];\n    if (((_a = config.context) === null || _a === void 0 ? void 0 : _a.name) === \"@@section\" /* Section */) {\n        // For section context, filter out unmatched snippets\n        abbr = abbr.filter(node => node.snippet);\n    }\n    for (let i = 0; i < abbr.length; i++) {\n        if (format && i !== 0) {\n            pushNewline(out, true);\n        }\n        property(abbr[i], out, config);\n    }\n    return out.value;\n}\n/**\n * Outputs given abbreviation node into output stream\n */\nfunction property(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    if (node.name) {\n        // It’s a CSS property\n        const name = isJSON ? toCamelCase(node.name) : node.name;\n        pushString(out, name + config.options['stylesheet.between']);\n        if (node.value.length) {\n            propertyValue(node, out, config);\n        }\n        else {\n            pushField(out, 0, '');\n        }\n        if (isJSON) {\n            // For CSS-in-JS, always finalize property with comma\n            // NB: seems like `important` is not available in CSS-in-JS syntaxes\n            push(out, ',');\n        }\n        else {\n            outputImportant(node, out, true);\n            push(out, config.options['stylesheet.after']);\n        }\n    }\n    else {\n        // It’s a regular snippet, output plain tokens without any additional formatting\n        for (const cssVal of node.value) {\n            for (const v of cssVal.value) {\n                outputToken(v, out, config);\n            }\n        }\n        outputImportant(node, out, node.value.length > 0);\n    }\n}\nfunction propertyValue(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    const num = isJSON ? getSingleNumeric(node) : null;\n    if (num && (!num.unit || num.unit === 'px')) {\n        // For CSS-in-JS, if property contains single numeric value, output it\n        // as JS number\n        push(out, String(num.value));\n    }\n    else {\n        const quote = getQuote(config);\n        isJSON && push(out, quote);\n        for (let i = 0; i < node.value.length; i++) {\n            if (i !== 0) {\n                push(out, ', ');\n            }\n            outputValue(node.value[i], out, config);\n        }\n        isJSON && push(out, quote);\n    }\n}\nfunction outputImportant(node, out, separator) {\n    if (node.important) {\n        if (separator) {\n            push(out, ' ');\n        }\n        push(out, '!important');\n    }\n}\nfunction outputValue(value, out, config) {\n    for (let i = 0, prevEnd = -1; i < value.value.length; i++) {\n        const token = value.value[i];\n        // Handle edge case: a field is written close to previous token like this: `foo${bar}`.\n        // We should not add delimiter here\n        if (i !== 0 && (token.type !== 'Field' || token.start !== prevEnd)) {\n            push(out, ' ');\n        }\n        outputToken(token, out, config);\n        prevEnd = token['end'];\n    }\n}\nfunction outputToken(token, out, config) {\n    if (token.type === 'ColorValue') {\n        push(out, color(token, config.options['stylesheet.shortHex']));\n    }\n    else if (token.type === 'Literal') {\n        pushString(out, token.value);\n    }\n    else if (token.type === 'NumberValue') {\n        pushString(out, frac(token.value, 4) + token.unit);\n    }\n    else if (token.type === 'StringValue') {\n        const quote = token.quote === 'double' ? '\"' : '\\'';\n        pushString(out, quote + token.value + quote);\n    }\n    else if (token.type === 'Field') {\n        pushField(out, token.index, token.name);\n    }\n    else if (token.type === 'FunctionCall') {\n        push(out, token.name + '(');\n        for (let i = 0; i < token.arguments.length; i++) {\n            if (i) {\n                push(out, ', ');\n            }\n            outputValue(token.arguments[i], out, config);\n        }\n        push(out, ')');\n    }\n}\n/**\n * If value of given property is a single numeric value, returns this token\n */\nfunction getSingleNumeric(node) {\n    if (node.value.length === 1) {\n        const cssVal = node.value[0];\n        if (cssVal.value.length === 1 && cssVal.value[0].type === 'NumberValue') {\n            return cssVal.value[0];\n        }\n    }\n}\n/**\n * Converts kebab-case string to camelCase\n */\nfunction toCamelCase(str) {\n    return str.replace(/\\-(\\w)/g, (_, letter) => letter.toUpperCase());\n}\nfunction getQuote(config) {\n    return config.options['stylesheet.jsonDoubleQuotes'] ? '\"' : '\\'';\n}\n\nconst gradientName = 'lg';\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse$1(abbr, config) {\n    var _a;\n    const snippets = ((_a = config.cache) === null || _a === void 0 ? void 0 : _a.stylesheetSnippets) || convertSnippets(config.snippets);\n    if (config.cache) {\n        config.cache.stylesheetSnippets = snippets;\n    }\n    if (typeof abbr === 'string') {\n        abbr = parse$2(abbr, { value: isValueScope(config) });\n    }\n    const filteredSnippets = getSnippetsForScope(snippets, config);\n    for (const node of abbr) {\n        resolveNode(node, filteredSnippets, config);\n    }\n    return abbr;\n}\n/**\n * Converts given raw snippets into internal snippets representation\n */\nfunction convertSnippets(snippets) {\n    const result = [];\n    for (const key of Object.keys(snippets)) {\n        result.push(createSnippet(key, snippets[key]));\n    }\n    return nest(result);\n}\n/**\n * Resolves given node: finds matched CSS snippets using fuzzy match and resolves\n * keyword aliases from node value\n */\nfunction resolveNode(node, snippets, config) {\n    if (!resolveGradient(node, config)) {\n        const score = config.options['stylesheet.fuzzySearchMinScore'];\n        if (isValueScope(config)) {\n            // Resolve as value of given CSS property\n            const propName = config.context.name;\n            const snippet = snippets.find(s => s.type === \"Property\" /* Property */ && s.property === propName);\n            resolveValueKeywords(node, config, snippet, score);\n            node.snippet = snippet;\n        }\n        else if (node.name) {\n            const snippet = findBestMatch(node.name, snippets, score, true);\n            node.snippet = snippet;\n            if (snippet) {\n                if (snippet.type === \"Property\" /* Property */) {\n                    resolveAsProperty(node, snippet, config);\n                }\n                else {\n                    resolveAsSnippet(node, snippet);\n                }\n            }\n        }\n    }\n    if (node.name || config.context) {\n        // Resolve numeric values for CSS properties only\n        resolveNumericValue(node, config);\n    }\n    return node;\n}\n/**\n * Resolves CSS gradient shortcut from given property, if possible\n */\nfunction resolveGradient(node, config) {\n    let gradientFn = null;\n    const cssVal = node.value.length === 1 ? node.value[0] : null;\n    if (cssVal && cssVal.value.length === 1) {\n        const v = cssVal.value[0];\n        if (v.type === 'FunctionCall' && v.name === gradientName) {\n            gradientFn = v;\n        }\n    }\n    if (gradientFn || node.name === gradientName) {\n        if (!gradientFn) {\n            gradientFn = {\n                type: 'FunctionCall',\n                name: 'linear-gradient',\n                arguments: [cssValue(field(0, ''))]\n            };\n        }\n        else {\n            gradientFn = Object.assign(Object.assign({}, gradientFn), { name: 'linear-gradient' });\n        }\n        if (!config.context) {\n            node.name = 'background-image';\n        }\n        node.value = [cssValue(gradientFn)];\n        return true;\n    }\n    return false;\n}\n/**\n * Resolves given parsed abbreviation node as CSS property\n */\nfunction resolveAsProperty(node, snippet, config) {\n    const abbr = node.name;\n    // Check for unmatched part of abbreviation\n    // For example, in `dib` abbreviation the matched part is `d` and `ib` should\n    // be considered as inline value. If unmatched fragment exists, we should check\n    // if it matches actual value of snippet. If either explicit value is specified\n    // or unmatched fragment did not resolve to to a keyword, we should consider\n    // matched snippet as invalid\n    const inlineValue = getUnmatchedPart(abbr, snippet.key);\n    if (inlineValue) {\n        if (node.value.length) {\n            // Already have value: unmatched part indicates matched snippet is invalid\n            return node;\n        }\n        const kw = resolveKeyword(inlineValue, config, snippet);\n        if (!kw) {\n            return node;\n        }\n        node.value.push(cssValue(kw));\n    }\n    node.name = snippet.property;\n    if (node.value.length) {\n        // Replace keyword alias from current abbreviation node with matched keyword\n        resolveValueKeywords(node, config, snippet);\n    }\n    else if (snippet.value.length) {\n        const defaultValue = snippet.value[0];\n        // https://github.com/emmetio/emmet/issues/558\n        // We should auto-select inserted value only if there’s multiple value\n        // choice\n        node.value = snippet.value.length === 1 || defaultValue.some(hasField)\n            ? defaultValue\n            : defaultValue.map(n => wrapWithField(n, config));\n    }\n    return node;\n}\nfunction resolveValueKeywords(node, config, snippet, minScore) {\n    for (const cssVal of node.value) {\n        const value = [];\n        for (const token of cssVal.value) {\n            if (token.type === 'Literal') {\n                value.push(resolveKeyword(token.value, config, snippet, minScore) || token);\n            }\n            else if (token.type === 'FunctionCall') {\n                // For function calls, we should find matching function call\n                // and merge arguments\n                const match = resolveKeyword(token.name, config, snippet, minScore);\n                if (match && match.type === 'FunctionCall') {\n                    value.push(Object.assign(Object.assign({}, match), { arguments: token.arguments.concat(match.arguments.slice(token.arguments.length)) }));\n                }\n                else {\n                    value.push(token);\n                }\n            }\n            else {\n                value.push(token);\n            }\n        }\n        cssVal.value = value;\n    }\n}\n/**\n * Resolves given parsed abbreviation node as a snippet: a plain code chunk\n */\nfunction resolveAsSnippet(node, snippet) {\n    // When resolving snippets, we have to do the following:\n    // 1. Replace field placeholders with actual field tokens.\n    // 2. If input values given, put them instead of fields\n    let offset = 0;\n    let m;\n    const reField = /\\$\\{(\\d+)(:[^}]+)?\\}/g;\n    const inputValue = node.value[0];\n    const outputValue = [];\n    while (m = reField.exec(snippet.value)) {\n        if (offset !== m.index) {\n            outputValue.push(literal(snippet.value.slice(offset, m.index)));\n        }\n        offset = m.index + m[0].length;\n        if (inputValue && inputValue.value.length) {\n            outputValue.push(inputValue.value.shift());\n        }\n        else {\n            outputValue.push(field(Number(m[1]), m[2] ? m[2].slice(1) : ''));\n        }\n    }\n    const tail = snippet.value.slice(offset);\n    if (tail) {\n        outputValue.push(literal(tail));\n    }\n    node.name = void 0;\n    node.value = [cssValue(...outputValue)];\n    return node;\n}\n/**\n * Finds best matching item from `items` array\n * @param abbr  Abbreviation to match\n * @param items List of items for match\n * @param minScore The minimum score the best matched item should have to be a valid match.\n */\nfunction findBestMatch(abbr, items, minScore = 0, partialMatch = false) {\n    let matchedItem = null;\n    let maxScore = 0;\n    for (const item of items) {\n        const score = scoreMatch(abbr, getScoringPart(item), partialMatch);\n        if (score === 1) {\n            // direct hit, no need to look further\n            return item;\n        }\n        if (score && score >= maxScore) {\n            maxScore = score;\n            matchedItem = item;\n        }\n    }\n    return maxScore >= minScore ? matchedItem : null;\n}\nfunction getScoringPart(item) {\n    return typeof item === 'string' ? item : item.key;\n}\n/**\n * Returns a part of `abbr` that wasn’t directly matched against `str`.\n * For example, if abbreviation `poas` is matched against `position`,\n * the unmatched part will be `as` since `a` wasn’t found in string stream\n */\nfunction getUnmatchedPart(abbr, str) {\n    for (let i = 0, lastPos = 0; i < abbr.length; i++) {\n        lastPos = str.indexOf(abbr[i], lastPos);\n        if (lastPos === -1) {\n            return abbr.slice(i);\n        }\n        lastPos++;\n    }\n    return '';\n}\n/**\n * Resolves given keyword shorthand into matched snippet keyword or global keyword,\n * if possible\n */\nfunction resolveKeyword(kw, config, snippet, minScore) {\n    let ref;\n    if (snippet) {\n        if (ref = findBestMatch(kw, Object.keys(snippet.keywords), minScore)) {\n            return snippet.keywords[ref];\n        }\n        for (const dep of snippet.dependencies) {\n            if (ref = findBestMatch(kw, Object.keys(dep.keywords), minScore)) {\n                return dep.keywords[ref];\n            }\n        }\n    }\n    if (ref = findBestMatch(kw, config.options['stylesheet.keywords'], minScore)) {\n        return literal(ref);\n    }\n    return null;\n}\n/**\n * Resolves numeric values in given abbreviation node\n */\nfunction resolveNumericValue(node, config) {\n    const aliases = config.options['stylesheet.unitAliases'];\n    const unitless = config.options['stylesheet.unitless'];\n    for (const v of node.value) {\n        for (const t of v.value) {\n            if (t.type === 'NumberValue') {\n                if (t.unit) {\n                    t.unit = aliases[t.unit] || t.unit;\n                }\n                else if (t.value !== 0 && !unitless.includes(node.name)) {\n                    t.unit = t.rawValue.includes('.')\n                        ? config.options['stylesheet.floatUnit']\n                        : config.options['stylesheet.intUnit'];\n                }\n            }\n        }\n    }\n}\n/**\n * Constructs CSS value token\n */\nfunction cssValue(...args) {\n    return {\n        type: 'CSSValue',\n        value: args\n    };\n}\n/**\n * Constructs literal token\n */\nfunction literal(value) {\n    return { type: 'Literal', value };\n}\n/**\n * Constructs field token\n */\nfunction field(index, name) {\n    return { type: 'Field', index, name };\n}\n/**\n * Check if given value contains fields\n */\nfunction hasField(value) {\n    for (const v of value.value) {\n        if (v.type === 'Field' || (v.type === 'FunctionCall' && v.arguments.some(hasField))) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Wraps tokens of given abbreviation with fields\n */\nfunction wrapWithField(node, config, state = { index: 1 }) {\n    let value = [];\n    for (const v of node.value) {\n        switch (v.type) {\n            case 'ColorValue':\n                value.push(field(state.index++, color(v, config.options['stylesheet.shortHex'])));\n                break;\n            case 'Literal':\n                value.push(field(state.index++, v.value));\n                break;\n            case 'NumberValue':\n                value.push(field(state.index++, `${v.value}${v.unit}`));\n                break;\n            case 'StringValue':\n                const q = v.quote === 'single' ? '\\'' : '\"';\n                value.push(field(state.index++, q + v.value + q));\n                break;\n            case 'FunctionCall':\n                value.push(field(state.index++, v.name), literal('('));\n                for (let i = 0, il = v.arguments.length; i < il; i++) {\n                    value = value.concat(wrapWithField(v.arguments[i], config, state).value);\n                    if (i !== il - 1) {\n                        value.push(literal(', '));\n                    }\n                }\n                value.push(literal(')'));\n                break;\n            default:\n                value.push(v);\n        }\n    }\n    return Object.assign(Object.assign({}, node), { value });\n}\n/**\n * Check if abbreviation should be expanded in CSS value context\n */\nfunction isValueScope(config) {\n    if (config.context) {\n        return config.context.name === \"@@value\" /* Value */ || !config.context.name.startsWith('@@');\n    }\n    return false;\n}\n/**\n * Returns snippets for given scope\n */\nfunction getSnippetsForScope(snippets, config) {\n    if (config.context) {\n        if (config.context.name === \"@@section\" /* Section */) {\n            return snippets.filter(s => s.type === \"Raw\" /* Raw */);\n        }\n        if (config.context.name === \"@@property\" /* Property */) {\n            return snippets.filter(s => s.type === \"Property\" /* Property */);\n        }\n    }\n    return snippets;\n}\n\nvar markupSnippets = {\n\t\"a\": \"a[href]\",\n\t\"a:blank\": \"a[href='http://${0}' target='_blank' rel='noopener noreferrer']\",\n\t\"a:link\": \"a[href='http://${0}']\",\n\t\"a:mail\": \"a[href='mailto:${0}']\",\n\t\"a:tel\": \"a[href='tel:+${0}']\",\n\t\"abbr\": \"abbr[title]\",\n\t\"acr|acronym\": \"acronym[title]\",\n\t\"base\": \"base[href]/\",\n\t\"basefont\": \"basefont/\",\n\t\"br\": \"br/\",\n\t\"frame\": \"frame/\",\n\t\"hr\": \"hr/\",\n\t\"bdo\": \"bdo[dir]\",\n\t\"bdo:r\": \"bdo[dir=rtl]\",\n\t\"bdo:l\": \"bdo[dir=ltr]\",\n\t\"col\": \"col/\",\n\t\"link\": \"link[rel=stylesheet href]/\",\n\t\"link:css\": \"link[href='${1:style}.css']\",\n\t\"link:print\": \"link[href='${1:print}.css' media=print]\",\n\t\"link:favicon\": \"link[rel='shortcut icon' type=image/x-icon href='${1:favicon.ico}']\",\n\t\"link:mf|link:manifest\": \"link[rel='manifest' href='${1:manifest.json}']\",\n\t\"link:touch\": \"link[rel=apple-touch-icon href='${1:favicon.png}']\",\n\t\"link:rss\": \"link[rel=alternate type=application/rss+xml title=RSS href='${1:rss.xml}']\",\n\t\"link:atom\": \"link[rel=alternate type=application/atom+xml title=Atom href='${1:atom.xml}']\",\n\t\"link:im|link:import\": \"link[rel=import href='${1:component}.html']\",\n\t\"meta\": \"meta/\",\n\t\"meta:utf\": \"meta[http-equiv=Content-Type content='text/html;charset=UTF-8']\",\n\t\"meta:vp\": \"meta[name=viewport content='width=${1:device-width}, initial-scale=${2:1.0}']\",\n\t\"meta:compat\": \"meta[http-equiv=X-UA-Compatible content='${1:IE=7}']\",\n\t\"meta:edge\": \"meta:compat[content='${1:ie=edge}']\",\n\t\"meta:redirect\": \"meta[http-equiv=refresh content='0; url=${1:http://example.com}']\",\n\t\"meta:kw\": \"meta[name=keywords content]\",\n\t\"meta:desc\": \"meta[name=description content]\",\n\t\"style\": \"style\",\n\t\"script\": \"script\",\n\t\"script:src\": \"script[src]\",\n\t\"img\": \"img[src alt]/\",\n\t\"img:s|img:srcset\": \"img[srcset src alt]\",\n\t\"img:z|img:sizes\": \"img[sizes srcset src alt]\",\n\t\"picture\": \"picture\",\n\t\"src|source\": \"source/\",\n\t\"src:sc|source:src\": \"source[src type]\",\n\t\"src:s|source:srcset\": \"source[srcset]\",\n\t\"src:t|source:type\": \"source[srcset type='${1:image/}']\",\n\t\"src:z|source:sizes\": \"source[sizes srcset]\",\n\t\"src:m|source:media\": \"source[media='(${1:min-width: })' srcset]\",\n\t\"src:mt|source:media:type\": \"source:media[type='${2:image/}']\",\n\t\"src:mz|source:media:sizes\": \"source:media[sizes srcset]\",\n\t\"src:zt|source:sizes:type\": \"source[sizes srcset type='${1:image/}']\",\n\t\"iframe\": \"iframe[src frameborder=0]\",\n\t\"embed\": \"embed[src type]/\",\n\t\"object\": \"object[data type]\",\n\t\"param\": \"param[name value]/\",\n\t\"map\": \"map[name]\",\n\t\"area\": \"area[shape coords href alt]/\",\n\t\"area:d\": \"area[shape=default]\",\n\t\"area:c\": \"area[shape=circle]\",\n\t\"area:r\": \"area[shape=rect]\",\n\t\"area:p\": \"area[shape=poly]\",\n\t\"form\": \"form[action]\",\n\t\"form:get\": \"form[method=get]\",\n\t\"form:post\": \"form[method=post]\",\n\t\"label\": \"label[for]\",\n\t\"input\": \"input[type=${1:text}]/\",\n\t\"inp\": \"input[name=${1} id=${1}]\",\n\t\"input:h|input:hidden\": \"input[type=hidden name]\",\n\t\"input:t|input:text\": \"inp[type=text]\",\n\t\"input:search\": \"inp[type=search]\",\n\t\"input:email\": \"inp[type=email]\",\n\t\"input:url\": \"inp[type=url]\",\n\t\"input:p|input:password\": \"inp[type=password]\",\n\t\"input:datetime\": \"inp[type=datetime]\",\n\t\"input:date\": \"inp[type=date]\",\n\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\"input:month\": \"inp[type=month]\",\n\t\"input:week\": \"inp[type=week]\",\n\t\"input:time\": \"inp[type=time]\",\n\t\"input:tel\": \"inp[type=tel]\",\n\t\"input:number\": \"inp[type=number]\",\n\t\"input:color\": \"inp[type=color]\",\n\t\"input:c|input:checkbox\": \"inp[type=checkbox]\",\n\t\"input:r|input:radio\": \"inp[type=radio]\",\n\t\"input:range\": \"inp[type=range]\",\n\t\"input:f|input:file\": \"inp[type=file]\",\n\t\"input:s|input:submit\": \"input[type=submit value]\",\n\t\"input:i|input:image\": \"input[type=image src alt]\",\n\t\"input:b|input:btn|input:button\": \"input[type=button value]\",\n\t\"input:reset\": \"input:button[type=reset]\",\n\t\"isindex\": \"isindex/\",\n\t\"select\": \"select[name=${1} id=${1}]\",\n\t\"select:d|select:disabled\": \"select[disabled.]\",\n\t\"opt|option\": \"option[value]\",\n\t\"textarea\": \"textarea[name=${1} id=${1} cols=${2:30} rows=${3:10}]\",\n\t\"marquee\": \"marquee[behavior direction]\",\n\t\"menu:c|menu:context\": \"menu[type=context]\",\n\t\"menu:t|menu:toolbar\": \"menu[type=toolbar]\",\n\t\"video\": \"video[src]\",\n\t\"audio\": \"audio[src]\",\n\t\"html:xml\": \"html[xmlns=http://www.w3.org/1999/xhtml]\",\n\t\"keygen\": \"keygen/\",\n\t\"command\": \"command/\",\n\t\"btn:s|button:s|button:submit\" : \"button[type=submit]\",\n\t\"btn:r|button:r|button:reset\" : \"button[type=reset]\",\n\t\"btn:d|button:d|button:disabled\" : \"button[disabled.]\",\n\t\"fst:d|fset:d|fieldset:d|fieldset:disabled\" : \"fieldset[disabled.]\",\n\n\t\"bq\": \"blockquote\",\n\t\"fig\": \"figure\",\n\t\"figc\": \"figcaption\",\n\t\"pic\": \"picture\",\n\t\"ifr\": \"iframe\",\n\t\"emb\": \"embed\",\n\t\"obj\": \"object\",\n\t\"cap\": \"caption\",\n\t\"colg\": \"colgroup\",\n\t\"fst\": \"fieldset\",\n\t\"btn\": \"button\",\n\t\"optg\": \"optgroup\",\n\t\"tarea\": \"textarea\",\n\t\"leg\": \"legend\",\n\t\"sect\": \"section\",\n\t\"art\": \"article\",\n\t\"hdr\": \"header\",\n\t\"ftr\": \"footer\",\n\t\"adr\": \"address\",\n\t\"dlg\": \"dialog\",\n\t\"str\": \"strong\",\n\t\"prog\": \"progress\",\n\t\"mn\": \"main\",\n\t\"tem\": \"template\",\n\t\"fset\": \"fieldset\",\n\t\"datag\": \"datagrid\",\n\t\"datal\": \"datalist\",\n\t\"kg\": \"keygen\",\n\t\"out\": \"output\",\n\t\"det\": \"details\",\n\t\"sum\": \"summary\",\n\t\"cmd\": \"command\",\n\n\t\"ri:d|ri:dpr\": \"img:s\",\n\t\"ri:v|ri:viewport\": \"img:z\",\n\t\"ri:a|ri:art\": \"pic>src:m+img\",\n\t\"ri:t|ri:type\": \"pic>src:t+img\",\n\n\t\"!!!\": \"{<!DOCTYPE html>}\",\n\t\"doc\": \"html[lang=${lang}]>(head>meta[charset=${charset}]+meta[http-equiv='X-UA-Compatible'][content='IE=edge']+meta:vp+title{${1:Document}})+body\",\n\t\"!|html:5\": \"!!!+doc\",\n\n\t\"c\": \"{<!-- ${0} -->}\",\n\t\"cc:ie\": \"{<!--[if IE]>${0}<![endif]-->}\",\n\t\"cc:noie\": \"{<!--[if !IE]><!-->${0}<!--<![endif]-->}\"\n};\n\nvar stylesheetSnippets = {\n\t\"@f\": \"@font-face {\\n\\tfont-family: ${1};\\n\\tsrc: url(${2});\\n}\",\n\t\"@ff\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\t\"@i|@import\": \"@import url(${0});\",\n\t\"@kf\": \"@keyframes ${1:identifier} {\\n\\t${2}\\n}\",\n\t\"@m|@media\": \"@media ${1:screen} {\\n\\t${0}\\n}\",\n\t\"ac\": \"align-content:start|end|flex-start|flex-end|center|space-between|space-around|stretch|space-evenly\",\n\t\"ai\": \"align-items:start|end|flex-start|flex-end|center|baseline|stretch\",\n\t\"anim\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode}\",\n\t\"animdel\": \"animation-delay:time\",\n\t\"animdir\": \"animation-direction:normal|reverse|alternate|alternate-reverse\",\n\t\"animdur\": \"animation-duration:${1:0}s\",\n\t\"animfm\": \"animation-fill-mode:both|forwards|backwards\",\n\t\"animic\": \"animation-iteration-count:1|infinite\",\n\t\"animn\": \"animation-name\",\n\t\"animps\": \"animation-play-state:running|paused\",\n\t\"animtf\": \"animation-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1})\",\n\t\"ap\": \"appearance:none\",\n\t\"as\": \"align-self:start|end|auto|flex-start|flex-end|center|baseline|stretch\",\n\t\"b\": \"bottom\",\n\t\"bd\": \"border:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdb\": \"border-bottom:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdbc\": \"border-bottom-color:${1:#000}\",\n\t\"bdbi\": \"border-bottom-image:url(${0})\",\n\t\"bdbk\": \"border-break:close\",\n\t\"bdbli\": \"border-bottom-left-image:url(${0})|continue\",\n\t\"bdblrs\": \"border-bottom-left-radius\",\n\t\"bdbri\": \"border-bottom-right-image:url(${0})|continue\",\n\t\"bdbrrs\": \"border-bottom-right-radius\",\n\t\"bdbs\": \"border-bottom-style\",\n\t\"bdbw\": \"border-bottom-width\",\n\t\"bdc\": \"border-color:${1:#000}\",\n\t\"bdci\": \"border-corner-image:url(${0})|continue\",\n\t\"bdcl\": \"border-collapse:collapse|separate\",\n\t\"bdf\": \"border-fit:repeat|clip|scale|stretch|overwrite|overflow|space\",\n\t\"bdi\": \"border-image:url(${0})\",\n\t\"bdl\": \"border-left:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdlc\": \"border-left-color:${1:#000}\",\n\t\"bdlen\": \"border-length\",\n\t\"bdli\": \"border-left-image:url(${0})\",\n\t\"bdls\": \"border-left-style\",\n\t\"bdlw\": \"border-left-width\",\n\t\"bdr\": \"border-right:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdrc\": \"border-right-color:${1:#000}\",\n\t\"bdri\": \"border-right-image:url(${0})\",\n\t\"bdrs\": \"border-radius\",\n\t\"bdrst\": \"border-right-style\",\n\t\"bdrw\": \"border-right-width\",\n\t\"bds\": \"border-style:none|hidden|dotted|dashed|solid|double|dot-dash|dot-dot-dash|wave|groove|ridge|inset|outset\",\n\t\"bdsp\": \"border-spacing\",\n\t\"bdt\": \"border-top:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdtc\": \"border-top-color:${1:#000}\",\n\t\"bdti\": \"border-top-image:url(${0})\",\n\t\"bdtli\": \"border-top-left-image:url(${0})|continue\",\n\t\"bdtlrs\": \"border-top-left-radius\",\n\t\"bdtri\": \"border-top-right-image:url(${0})|continue\",\n\t\"bdtrrs\": \"border-top-right-radius\",\n\t\"bdts\": \"border-top-style\",\n\t\"bdtw\": \"border-top-width\",\n\t\"bdw\": \"border-width\",\n\t\"bfv\": \"backface-visibility:hidden|visible\",\n\t\"bg\": \"background:${1:#000}\",\n\t\"bga\": \"background-attachment:fixed|scroll\",\n\t\"bgbk\": \"background-break:bounding-box|each-box|continuous\",\n\t\"bgc\": \"background-color:#${1:fff}\",\n\t\"bgcp\": \"background-clip:padding-box|border-box|content-box|no-clip\",\n\t\"bgi\": \"background-image:url(${0})\",\n\t\"bgo\": \"background-origin:padding-box|border-box|content-box\",\n\t\"bgp\": \"background-position:${1:0} ${2:0}\",\n\t\"bgpx\": \"background-position-x\",\n\t\"bgpy\": \"background-position-y\",\n\t\"bgr\": \"background-repeat:no-repeat|repeat-x|repeat-y|space|round\",\n\t\"bgsz\": \"background-size:contain|cover\",\n\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:#000}|none\",\n\t\"bxsz\": \"box-sizing:border-box|content-box|border-box\",\n\t\"c\": \"color:${1:#000}\",\n\t\"cr\": \"color:rgb(${1:0}, ${2:0}, ${3:0})\",\n\t\"cra\": \"color:rgba(${1:0}, ${2:0}, ${3:0}, ${4:.5})\",\n\t\"cl\": \"clear:both|left|right|none\",\n\t\"cm\": \"/* ${0} */\",\n\t\"cnt\": \"content:'${0}'|normal|open-quote|no-open-quote|close-quote|no-close-quote|attr(${0})|counter(${0})|counters(${0})\",\n\t\"coi\": \"counter-increment\",\n\t\"colm\": \"columns\",\n\t\"colmc\": \"column-count\",\n\t\"colmf\": \"column-fill\",\n\t\"colmg\": \"column-gap\",\n\t\"colmr\": \"column-rule\",\n\t\"colmrc\": \"column-rule-color\",\n\t\"colmrs\": \"column-rule-style\",\n\t\"colmrw\": \"column-rule-width\",\n\t\"colms\": \"column-span\",\n\t\"colmw\": \"column-width\",\n\t\"cor\": \"counter-reset\",\n\t\"cp\": \"clip:auto|rect(${1:top} ${2:right} ${3:bottom} ${4:left})\",\n\t\"cps\": \"caption-side:top|bottom\",\n\t\"cur\": \"cursor:pointer|auto|default|crosshair|hand|help|move|pointer|text\",\n\t\"d\": \"display:block|none|flex|inline-flex|inline|inline-block|grid|inline-grid|subgrid|list-item|run-in|compact|table|inline-table|table-caption|table-column|table-column-group|table-header-group|table-footer-group|table-row|table-row-group|table-cell|ruby|ruby-base|ruby-base-group|ruby-text|ruby-text-group\",\n\t\"ec\": \"empty-cells:show|hide\",\n\t\"f\": \"font:${1:1em} ${2:sans-serif}\",\n\t\"fd\": \"font-display:auto|block|swap|fallback|optional\",\n\t\"fef\": \"font-effect:none|engrave|emboss|outline\",\n\t\"fem\": \"font-emphasize\",\n\t\"femp\": \"font-emphasize-position:before|after\",\n\t\"fems\": \"font-emphasize-style:none|accent|dot|circle|disc\",\n\t\"ff\": \"font-family:serif|sans-serif|cursive|fantasy|monospace\",\n\t\"fft\": \"font-family:\\\"Times New Roman\\\", Times, Baskerville, Georgia, serif\",\n\t\"ffa\": \"font-family:Arial, \\\"Helvetica Neue\\\", Helvetica, sans-serif\",\n\t\"ffv\": \"font-family:Verdana, Geneva, sans-serif\",\n\t\"fl\": \"float:left|right|none\",\n\t\"fs\": \"font-style:italic|normal|oblique\",\n\t\"fsm\": \"font-smoothing:antialiased|subpixel-antialiased|none\",\n\t\"fst\": \"font-stretch:normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded\",\n\t\"fv\": \"font-variant:normal|small-caps\",\n\t\"fvs\": \"font-variation-settings:normal|inherit|initial|unset\",\n\t\"fw\": \"font-weight:normal|bold|bolder|lighter\",\n\t\"fx\": \"flex\",\n\t\"fxb\": \"flex-basis:fill|max-content|min-content|fit-content|content\",\n\t\"fxd\": \"flex-direction:row|row-reverse|column|column-reverse\",\n\t\"fxf\": \"flex-flow\",\n\t\"fxg\": \"flex-grow\",\n\t\"fxsh\": \"flex-shrink\",\n\t\"fxw\": \"flex-wrap:nowrap|wrap|wrap-reverse\",\n\t\"fsz\": \"font-size\",\n\t\"fsza\": \"font-size-adjust\",\n\t\"gtc\": \"grid-template-columns:repeat(${0})|minmax()\",\n\t\"gtr\": \"grid-template-rows:repeat(${0})|minmax()\",\n\t\"gta\": \"grid-template-areas\",\n\t\"gt\": \"grid-template\",\n\t\"gg\": \"grid-gap\",\n\t\"gcg\": \"grid-column-gap\",\n\t\"grg\": \"grid-row-gap\",\n\t\"gac\": \"grid-auto-columns:auto|minmax()\",\n\t\"gar\": \"grid-auto-rows:auto|minmax()\",\n\t\"gaf\": \"grid-auto-flow:row|column|dense|inherit|initial|unset\",\n\t\"gd\": \"grid\",\n\t\"gc\": \"grid-column\",\n\t\"gcs\": \"grid-column-start\",\n\t\"gce\": \"grid-column-end\",\n\t\"gr\": \"grid-row\",\n\t\"grs\": \"grid-row-start\",\n\t\"gre\": \"grid-row-end\",\n\t\"ga\": \"grid-area\",\n\t\"h\": \"height\",\n\t\"jc\": \"justify-content:start|end|stretch|flex-start|flex-end|center|space-between|space-around|space-evenly\",\n\t\"ji\": \"justify-items:start|end|center|stretch\",\n\t\"js\": \"justify-self:start|end|center|stretch\",\n\t\"l\": \"left\",\n\t\"lg\": \"background-image:linear-gradient(${1})\",\n\t\"lh\": \"line-height\",\n\t\"lis\": \"list-style\",\n\t\"lisi\": \"list-style-image\",\n\t\"lisp\": \"list-style-position:inside|outside\",\n\t\"list\": \"list-style-type:disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman\",\n\t\"lts\": \"letter-spacing:normal\",\n\t\"m\": \"margin\",\n\t\"mah\": \"max-height\",\n\t\"mar\": \"max-resolution\",\n\t\"maw\": \"max-width\",\n\t\"mb\": \"margin-bottom\",\n\t\"mih\": \"min-height\",\n\t\"mir\": \"min-resolution\",\n\t\"miw\": \"min-width\",\n\t\"ml\": \"margin-left\",\n\t\"mr\": \"margin-right\",\n\t\"mt\": \"margin-top\",\n\t\"ol\": \"outline\",\n\t\"olc\": \"outline-color:${1:#000}|invert\",\n\t\"olo\": \"outline-offset\",\n\t\"ols\": \"outline-style:none|dotted|dashed|solid|double|groove|ridge|inset|outset\",\n\t\"olw\": \"outline-width|thin|medium|thick\",\n\t\"op|opa\": \"opacity\",\n\t\"ord\": \"order\",\n\t\"ori\": \"orientation:landscape|portrait\",\n\t\"orp\": \"orphans\",\n\t\"ov\": \"overflow:hidden|visible|hidden|scroll|auto\",\n\t\"ovs\": \"overflow-style:scrollbar|auto|scrollbar|panner|move|marquee\",\n\t\"ovx\": \"overflow-x:hidden|visible|hidden|scroll|auto\",\n\t\"ovy\": \"overflow-y:hidden|visible|hidden|scroll|auto\",\n\t\"p\": \"padding\",\n\t\"pb\": \"padding-bottom\",\n\t\"pgba\": \"page-break-after:auto|always|left|right\",\n\t\"pgbb\": \"page-break-before:auto|always|left|right\",\n\t\"pgbi\": \"page-break-inside:auto|avoid\",\n\t\"pl\": \"padding-left\",\n\t\"pos\": \"position:relative|absolute|relative|fixed|static\",\n\t\"pr\": \"padding-right\",\n\t\"pt\": \"padding-top\",\n\t\"q\": \"quotes\",\n\t\"qen\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019'\",\n\t\"qru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C'\",\n\t\"r\": \"right\",\n\t\"rsz\": \"resize:none|both|horizontal|vertical\",\n\t\"t\": \"top\",\n\t\"ta\": \"text-align:left|center|right|justify\",\n\t\"tal\": \"text-align-last:left|center|right\",\n\t\"tbl\": \"table-layout:fixed\",\n\t\"td\": \"text-decoration:none|underline|overline|line-through\",\n\t\"te\": \"text-emphasis:none|accent|dot|circle|disc|before|after\",\n\t\"th\": \"text-height:auto|font-size|text-size|max-size\",\n\t\"ti\": \"text-indent\",\n\t\"tj\": \"text-justify:auto|inter-word|inter-ideograph|inter-cluster|distribute|kashida|tibetan\",\n\t\"to\": \"text-outline:${1:0} ${2:0} ${3:#000}\",\n\t\"tov\": \"text-overflow:ellipsis|clip\",\n\t\"tr\": \"text-replace\",\n\t\"trf\": \"transform:${1}|skewX(${1:angle})|skewY(${1:angle})|scale(${1:x}, ${2:y})|scaleX(${1:x})|scaleY(${1:y})|scaleZ(${1:z})|scale3d(${1:x}, ${2:y}, ${3:z})|rotate(${1:angle})|rotateX(${1:angle})|rotateY(${1:angle})|rotateZ(${1:angle})|translate(${1:x}, ${2:y})|translateX(${1:x})|translateY(${1:y})|translateZ(${1:z})|translate3d(${1:tx}, ${2:ty}, ${3:tz})\",\n\t\"trfo\": \"transform-origin\",\n\t\"trfs\": \"transform-style:preserve-3d\",\n\t\"trs\": \"transition:${1:prop} ${2:time}\",\n\t\"trsde\": \"transition-delay:${1:time}\",\n\t\"trsdu\": \"transition-duration:${1:time}\",\n\t\"trsp\": \"transition-property:${1:prop}\",\n\t\"trstf\": \"transition-timing-function:${1:fn}\",\n\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000}\",\n\t\"tt\": \"text-transform:uppercase|lowercase|capitalize|none\",\n\t\"tw\": \"text-wrap:none|normal|unrestricted|suppress\",\n\t\"us\": \"user-select:none\",\n\t\"v\": \"visibility:hidden|visible|collapse\",\n\t\"va\": \"vertical-align:top|super|text-top|middle|baseline|bottom|text-bottom|sub\",\n\t\"w\": \"width\",\n\t\"whs\": \"white-space:nowrap|pre|pre-wrap|pre-line|normal\",\n\t\"whsc\": \"white-space-collapse:normal|keep-all|loose|break-strict|break-all\",\n\t\"wid\": \"widows\",\n\t\"wm\": \"writing-mode:lr-tb|lr-tb|lr-bt|rl-tb|rl-bt|tb-rl|tb-lr|bt-lr|bt-rl\",\n\t\"wob\": \"word-break:normal|keep-all|break-all\",\n\t\"wos\": \"word-spacing\",\n\t\"wow\": \"word-wrap:none|unrestricted|suppress|break-word|normal\",\n\t\"z\": \"z-index\",\n\t\"zom\": \"zoom:1\"\n};\n\nvar xslSnippets = {\n    \"tm|tmatch\": \"xsl:template[match mode]\",\n    \"tn|tname\": \"xsl:template[name]\",\n    \"call\": \"xsl:call-template[name]\",\n    \"ap\": \"xsl:apply-templates[select mode]\",\n    \"api\": \"xsl:apply-imports\",\n    \"imp\": \"xsl:import[href]\",\n    \"inc\": \"xsl:include[href]\",\n    \"ch\": \"xsl:choose\",\n    \"wh|xsl:when\": \"xsl:when[test]\",\n    \"ot\": \"xsl:otherwise\",\n    \"if\": \"xsl:if[test]\",\n    \"par\": \"xsl:param[name]\",\n    \"pare\": \"xsl:param[name select]\",\n    \"var\": \"xsl:variable[name]\",\n    \"vare\": \"xsl:variable[name select]\",\n    \"wp\": \"xsl:with-param[name select]\",\n    \"key\": \"xsl:key[name match use]\",\n    \"elem\": \"xsl:element[name]\",\n    \"attr\": \"xsl:attribute[name]\",\n    \"attrs\": \"xsl:attribute-set[name]\",\n    \"cp\": \"xsl:copy[select]\",\n    \"co\": \"xsl:copy-of[select]\",\n    \"val\": \"xsl:value-of[select]\",\n    \"for|each\": \"xsl:for-each[select]\",\n    \"tex\": \"xsl:text\",\n    \"com\": \"xsl:comment\",\n    \"msg\": \"xsl:message[terminate=no]\",\n    \"fall\": \"xsl:fallback\",\n    \"num\": \"xsl:number[value]\",\n    \"nam\": \"namespace-alias[stylesheet-prefix result-prefix]\",\n    \"pres\": \"xsl:preserve-space[elements]\",\n    \"strip\": \"xsl:strip-space[elements]\",\n    \"proc\": \"xsl:processing-instruction[name]\",\n    \"sort\": \"xsl:sort[select order]\",\n    \"choose\": \"xsl:choose>xsl:when+xsl:otherwise\",\n    \"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\",\n    \"!!!\": \"{<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>}\"\n};\n\nvar pugSnippets = {\n\t\"!!!\": \"{doctype html}\"\n};\n\nvar variables = {\n\t\"lang\": \"en\",\n\t\"locale\": \"en-US\",\n\t\"charset\": \"UTF-8\",\n\t\"indentation\": \"\\t\",\n\t\"newline\": \"\\n\"\n};\n\n/**\n * Default syntaxes for abbreviation types\n */\nconst defaultSyntaxes = {\n    markup: 'html',\n    stylesheet: 'css'\n};\nconst defaultOptions = {\n    'inlineElements': [\n        'a', 'abbr', 'acronym', 'applet', 'b', 'basefont', 'bdo',\n        'big', 'br', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i',\n        'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'map', 'object', 'q',\n        's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup',\n        'textarea', 'tt', 'u', 'var'\n    ],\n    'output.indent': '\\t',\n    'output.baseIndent': '',\n    'output.newline': '\\n',\n    'output.tagCase': '',\n    'output.attributeCase': '',\n    'output.attributeQuotes': 'double',\n    'output.format': true,\n    'output.formatLeafNode': false,\n    'output.formatSkip': ['html'],\n    'output.formatForce': ['body'],\n    'output.inlineBreak': 3,\n    'output.compactBoolean': false,\n    'output.booleanAttributes': [\n        'contenteditable', 'seamless', 'async', 'autofocus',\n        'autoplay', 'checked', 'controls', 'defer', 'disabled', 'formnovalidate',\n        'hidden', 'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'readonly',\n        'required', 'reversed', 'selected', 'typemustmatch'\n    ],\n    'output.reverseAttributes': false,\n    'output.selfClosingStyle': 'html',\n    'output.field': (index, placeholder) => placeholder,\n    'output.text': text => text,\n    'markup.href': true,\n    'comment.enabled': false,\n    'comment.trigger': ['id', 'class'],\n    'comment.before': '',\n    'comment.after': '\\n<!-- /[#ID][.CLASS] -->',\n    'bem.enabled': false,\n    'bem.element': '__',\n    'bem.modifier': '_',\n    'jsx.enabled': false,\n    'stylesheet.keywords': ['auto', 'inherit', 'unset', 'none'],\n    'stylesheet.unitless': ['z-index', 'line-height', 'opacity', 'font-weight', 'zoom', 'flex', 'flex-grow', 'flex-shrink'],\n    'stylesheet.shortHex': true,\n    'stylesheet.between': ': ',\n    'stylesheet.after': ';',\n    'stylesheet.intUnit': 'px',\n    'stylesheet.floatUnit': 'em',\n    'stylesheet.unitAliases': { e: 'em', p: '%', x: 'ex', r: 'rem' },\n    'stylesheet.json': false,\n    'stylesheet.jsonDoubleQuotes': false,\n    'stylesheet.fuzzySearchMinScore': 0\n};\nconst defaultConfig = {\n    type: 'markup',\n    syntax: 'html',\n    variables,\n    snippets: {},\n    options: defaultOptions\n};\n/**\n * Default per-syntax config\n */\nconst syntaxConfig = {\n    markup: {\n        snippets: parseSnippets(markupSnippets),\n    },\n    xhtml: {\n        options: {\n            'output.selfClosingStyle': 'xhtml'\n        }\n    },\n    xml: {\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    xsl: {\n        snippets: parseSnippets(xslSnippets),\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    jsx: {\n        options: {\n            'jsx.enabled': true\n        }\n    },\n    pug: {\n        snippets: parseSnippets(pugSnippets)\n    },\n    stylesheet: {\n        snippets: parseSnippets(stylesheetSnippets)\n    },\n    sass: {\n        options: {\n            'stylesheet.after': ''\n        }\n    },\n    stylus: {\n        options: {\n            'stylesheet.between': ' ',\n            'stylesheet.after': '',\n        }\n    }\n};\n/**\n * Parses raw snippets definitions with possibly multiple keys into a plan\n * snippet map\n */\nfunction parseSnippets(snippets) {\n    const result = {};\n    Object.keys(snippets).forEach(k => {\n        for (const name of k.split('|')) {\n            result[name] = snippets[k];\n        }\n    });\n    return result;\n}\nfunction resolveConfig(config = {}, globals = {}) {\n    const type = config.type || 'markup';\n    const syntax = config.syntax || defaultSyntaxes[type];\n    return Object.assign(Object.assign(Object.assign({}, defaultConfig), config), { type,\n        syntax, variables: mergedData(type, syntax, 'variables', config, globals), snippets: mergedData(type, syntax, 'snippets', config, globals), options: mergedData(type, syntax, 'options', config, globals) });\n}\nfunction mergedData(type, syntax, key, config, globals = {}) {\n    const typeDefaults = syntaxConfig[type];\n    const typeOverride = globals[type];\n    const syntaxDefaults = syntaxConfig[syntax];\n    const syntaxOverride = globals[syntax];\n    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, defaultConfig[key]), (typeDefaults && typeDefaults[key])), (syntaxDefaults && syntaxDefaults[key])), (typeOverride && typeOverride[key])), (syntaxOverride && syntaxOverride[key])), config[key]);\n}\n\n/**\n * Creates structure for scanning given string in backward direction\n */\nfunction backwardScanner(text, start = 0) {\n    return { text, start, pos: text.length };\n}\n/**\n * Check if given scanner position is at start of scanned text\n */\nfunction sol(scanner) {\n    return scanner.pos === scanner.start;\n}\n/**\n * “Peeks” character code an current scanner location without advancing it\n */\nfunction peek$1(scanner, offset = 0) {\n    return scanner.text.charCodeAt(scanner.pos - 1 + offset);\n}\n/**\n * Returns current character code and moves character location one symbol back\n */\nfunction previous(scanner) {\n    if (!sol(scanner)) {\n        return scanner.text.charCodeAt(--scanner.pos);\n    }\n}\n/**\n * Consumes current character code if it matches given `match` code or function\n */\nfunction consume(scanner, match) {\n    if (sol(scanner)) {\n        return false;\n    }\n    const ok = typeof match === 'function'\n        ? match(peek$1(scanner))\n        : match === peek$1(scanner);\n    if (ok) {\n        scanner.pos--;\n    }\n    return !!ok;\n}\nfunction consumeWhile(scanner, match) {\n    const start = scanner.pos;\n    while (consume(scanner, match)) {\n        // empty\n    }\n    return scanner.pos < start;\n}\n\n/**\n * Check if given character code is a quote\n */\nfunction isQuote(c) {\n    return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;\n}\n/**\n * Consumes quoted value, if possible\n * @return Returns `true` is value was consumed\n */\nfunction consumeQuoted(scanner) {\n    const start = scanner.pos;\n    const quote = previous(scanner);\n    if (isQuote(quote)) {\n        while (!sol(scanner)) {\n            if (previous(scanner) === quote && peek$1(scanner) !== 92 /* Escape */) {\n                return true;\n            }\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n\nconst bracePairs = {\n    [91 /* SquareL */]: 93 /* SquareR */,\n    [40 /* RoundL */]: 41 /* RoundR */,\n    [123 /* CurlyL */]: 125 /* CurlyR */,\n};\n\n/**\n * Check if given reader’s current position points at the end of HTML tag\n */\nfunction isHtml(scanner) {\n    const start = scanner.pos;\n    if (!consume(scanner, 62 /* AngleRight */)) {\n        return false;\n    }\n    let ok = false;\n    consume(scanner, 47 /* Slash */); // possibly self-closed element\n    while (!sol(scanner)) {\n        consumeWhile(scanner, isWhiteSpace);\n        if (consumeIdent(scanner)) {\n            // ate identifier: could be a tag name, boolean attribute or unquoted\n            // attribute value\n            if (consume(scanner, 47 /* Slash */)) {\n                // either closing tag or invalid tag\n                ok = consume(scanner, 60 /* AngleLeft */);\n                break;\n            }\n            else if (consume(scanner, 60 /* AngleLeft */)) {\n                // opening tag\n                ok = true;\n                break;\n            }\n            else if (consume(scanner, isWhiteSpace)) {\n                // boolean attribute\n                continue;\n            }\n            else if (consume(scanner, 61 /* Equals */)) {\n                // simple unquoted value or invalid attribute\n                if (consumeIdent(scanner)) {\n                    continue;\n                }\n                break;\n            }\n            else if (consumeAttributeWithUnquotedValue(scanner)) {\n                // identifier was a part of unquoted value\n                ok = true;\n                break;\n            }\n            // invalid tag\n            break;\n        }\n        if (consumeAttribute(scanner)) {\n            continue;\n        }\n        break;\n    }\n    scanner.pos = start;\n    return ok;\n}\n/**\n * Consumes HTML attribute from given string.\n * @return `true` if attribute was consumed.\n */\nfunction consumeAttribute(scanner) {\n    return consumeAttributeWithQuotedValue(scanner) || consumeAttributeWithUnquotedValue(scanner);\n}\nfunction consumeAttributeWithQuotedValue(scanner) {\n    const start = scanner.pos;\n    if (consumeQuoted(scanner) && consume(scanner, 61 /* Equals */) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\nfunction consumeAttributeWithUnquotedValue(scanner) {\n    const start = scanner.pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        const ch = peek$1(scanner);\n        if (isCloseBracket(ch)) {\n            stack.push(ch);\n        }\n        else if (isOpenBracket(ch)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // Unexpected open bracket\n                break;\n            }\n        }\n        else if (!isUnquotedValue(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (start !== scanner.pos && consume(scanner, 61 /* Equals */) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes HTML identifier from stream\n */\nfunction consumeIdent(scanner) {\n    return consumeWhile(scanner, isIdent);\n}\n/**\n * Check if given character code belongs to HTML identifier\n */\nfunction isIdent(ch) {\n    return ch === 58 /* Colon */ || ch === 45 /* Dash */ || isAlpha(ch) || isNumber(ch);\n}\n/**\n * Check if given character code is alpha code (letter though A to Z)\n */\nfunction isAlpha(ch) {\n    ch &= ~32; // quick hack to convert any char code to uppercase char code\n    return ch >= 65 && ch <= 90; // A-Z\n}\n/**\n * Check if given code is a number\n */\nfunction isNumber(ch) {\n    return ch > 47 && ch < 58;\n}\n/**\n * Check if given code is a whitespace\n */\nfunction isWhiteSpace(ch) {\n    return ch === 32 /* Space */ || ch === 9 /* Tab */;\n}\n/**\n * Check if given code may belong to unquoted attribute value\n */\nfunction isUnquotedValue(ch) {\n    return !isNaN(ch) && ch !== 61 /* Equals */ && !isWhiteSpace(ch) && !isQuote(ch);\n}\nfunction isOpenBracket(ch) {\n    return ch === 123 /* CurlyL */ || ch === 40 /* RoundL */ || ch === 91 /* SquareL */;\n}\nfunction isCloseBracket(ch) {\n    return ch === 125 /* CurlyR */ || ch === 41 /* RoundR */ || ch === 93 /* SquareR */;\n}\n\nconst code = (ch) => ch.charCodeAt(0);\nconst specialChars = '#.*:$-_!@%^+>/'.split('').map(code);\nconst defaultOptions$1 = {\n    type: 'markup',\n    lookAhead: true,\n    prefix: ''\n};\n/**\n * Extracts Emmet abbreviation from given string.\n * The goal of this module is to extract abbreviation from current editor’s line,\n * e.g. like this: `<span>.foo[title=bar|]</span>` -> `.foo[title=bar]`, where\n * `|` is a current caret position.\n * @param line A text line where abbreviation should be expanded\n * @param pos Caret position in line. If not given, uses end of line\n * @param options Extracting options\n */\nfunction extractAbbreviation$1(line, pos = line.length, options = {}) {\n    // make sure `pos` is within line range\n    const opt = Object.assign(Object.assign({}, defaultOptions$1), options);\n    pos = Math.min(line.length, Math.max(0, pos == null ? line.length : pos));\n    if (opt.lookAhead) {\n        pos = offsetPastAutoClosed(line, pos, opt);\n    }\n    let ch;\n    const start = getStartOffset(line, pos, opt.prefix || '');\n    if (start === -1) {\n        return void 0;\n    }\n    const scanner = backwardScanner(line, start);\n    scanner.pos = pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        ch = peek$1(scanner);\n        if (stack.includes(125 /* CurlyR */)) {\n            if (ch === 125 /* CurlyR */) {\n                stack.push(ch);\n                scanner.pos--;\n                continue;\n            }\n            if (ch !== 123 /* CurlyL */) {\n                scanner.pos--;\n                continue;\n            }\n        }\n        if (isCloseBrace(ch, opt.type)) {\n            stack.push(ch);\n        }\n        else if (isOpenBrace(ch, opt.type)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // unexpected brace\n                break;\n            }\n        }\n        else if (stack.includes(93 /* SquareR */) || stack.includes(125 /* CurlyR */)) {\n            // respect all characters inside attribute sets or text nodes\n            scanner.pos--;\n            continue;\n        }\n        else if (isHtml(scanner) || !isAbbreviation(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (!stack.length && scanner.pos !== pos) {\n        // Found something, remove some invalid symbols from the\n        // beginning and return abbreviation\n        const abbreviation = line.slice(scanner.pos, pos).replace(/^[*+>^]+/, '');\n        return {\n            abbreviation,\n            location: pos - abbreviation.length,\n            start: options.prefix\n                ? start - options.prefix.length\n                : pos - abbreviation.length,\n            end: pos\n        };\n    }\n}\n/**\n * Returns new `line` index which is right after characters beyound `pos` that\n * editor will likely automatically close, e.g. }, ], and quotes\n */\nfunction offsetPastAutoClosed(line, pos, options) {\n    // closing quote is allowed only as a next character\n    if (isQuote(line.charCodeAt(pos))) {\n        pos++;\n    }\n    // offset pointer until non-autoclosed character is found\n    while (isCloseBrace(line.charCodeAt(pos), options.type)) {\n        pos++;\n    }\n    return pos;\n}\n/**\n * Returns start offset (left limit) in `line` where we should stop looking for\n * abbreviation: it’s nearest to `pos` location of `prefix` token\n */\nfunction getStartOffset(line, pos, prefix) {\n    if (!prefix) {\n        return 0;\n    }\n    const scanner = backwardScanner(line);\n    const compiledPrefix = prefix.split('').map(code);\n    scanner.pos = pos;\n    let result;\n    while (!sol(scanner)) {\n        if (consumePair(scanner, 93 /* SquareR */, 91 /* SquareL */) || consumePair(scanner, 125 /* CurlyR */, 123 /* CurlyL */)) {\n            continue;\n        }\n        result = scanner.pos;\n        if (consumeArray(scanner, compiledPrefix)) {\n            return result;\n        }\n        scanner.pos--;\n    }\n    return -1;\n}\n/**\n * Consumes full character pair, if possible\n */\nfunction consumePair(scanner, close, open) {\n    const start = scanner.pos;\n    if (consume(scanner, close)) {\n        while (!sol(scanner)) {\n            if (consume(scanner, open)) {\n                return true;\n            }\n            scanner.pos--;\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes all character codes from given array, right-to-left, if possible\n */\nfunction consumeArray(scanner, arr) {\n    const start = scanner.pos;\n    let consumed = false;\n    for (let i = arr.length - 1; i >= 0 && !sol(scanner); i--) {\n        if (!consume(scanner, arr[i])) {\n            break;\n        }\n        consumed = i === 0;\n    }\n    if (!consumed) {\n        scanner.pos = start;\n    }\n    return consumed;\n}\nfunction isAbbreviation(ch) {\n    return (ch > 64 && ch < 91) // uppercase letter\n        || (ch > 96 && ch < 123) // lowercase letter\n        || (ch > 47 && ch < 58) // number\n        || specialChars.includes(ch); // special character\n}\nfunction isOpenBrace(ch, syntax) {\n    return ch === 40 /* RoundL */ || (syntax === 'markup' && (ch === 91 /* SquareL */ || ch === 123 /* CurlyL */));\n}\nfunction isCloseBrace(ch, syntax) {\n    return ch === 41 /* RoundR */ || (syntax === 'markup' && (ch === 93 /* SquareR */ || ch === 125 /* CurlyR */));\n}\n\nfunction expandAbbreviation$1(abbr, config) {\n    const resolvedConfig = resolveConfig(config);\n    return resolvedConfig.type === 'stylesheet'\n        ? stylesheet(abbr, resolvedConfig)\n        : markup(abbr, resolvedConfig);\n}\n/**\n * Expands given *markup* abbreviation (e.g. regular Emmet abbreviation that\n * produces structured output like HTML) and outputs it according to options\n * provided in config\n */\nfunction markup(abbr, config) {\n    return stringify(parse(abbr, config), config);\n}\n/**\n * Expands given *stylesheet* abbreviation (a special Emmet abbreviation designed for\n * stylesheet languages like CSS, SASS etc.) and outputs it according to options\n * provided in config\n */\nfunction stylesheet(abbr, config) {\n    return css(parse$1(abbr, config), config);\n}\n\nvar cssData = {\n    \"properties\": [\"additive-symbols\", \"align-content\", \"align-items\", \"justify-items\", \"justify-self\", \"justify-items\", \"align-self\", \"all\", \"alt\", \"animation\", \"animation-delay\", \"animation-direction\", \"animation-duration\", \"animation-fill-mode\", \"animation-iteration-count\", \"animation-name\", \"animation-play-state\", \"animation-timing-function\", \"backface-visibility\", \"background\", \"background-attachment\", \"background-blend-mode\", \"background-clip\", \"background-color\", \"background-image\", \"background-origin\", \"background-position\", \"background-position-x\", \"background-position-y\", \"background-repeat\", \"background-size\", \"behavior\", \"block-size\", \"border\", \"border-block-end\", \"border-block-start\", \"border-block-end-color\", \"border-block-start-color\", \"border-block-end-style\", \"border-block-start-style\", \"border-block-end-width\", \"border-block-start-width\", \"border-bottom\", \"border-bottom-color\", \"border-bottom-left-radius\", \"border-bottom-right-radius\", \"border-bottom-style\", \"border-bottom-width\", \"border-collapse\", \"border-color\", \"border-image\", \"border-image-outset\", \"border-image-repeat\", \"border-image-slice\", \"border-image-source\", \"border-image-width\", \"border-inline-end\", \"border-inline-start\", \"border-inline-end-color\", \"border-inline-start-color\", \"border-inline-end-style\", \"border-inline-start-style\", \"border-inline-end-width\", \"border-inline-start-width\", \"border-left\", \"border-left-color\", \"border-left-style\", \"border-left-width\", \"border-radius\", \"border-right\", \"border-right-color\", \"border-right-style\", \"border-right-width\", \"border-spacing\", \"border-style\", \"border-top\", \"border-top-color\", \"border-top-left-radius\", \"border-top-right-radius\", \"border-top-style\", \"border-top-width\", \"border-width\", \"bottom\", \"box-decoration-break\", \"box-shadow\", \"box-sizing\", \"break-after\", \"break-before\", \"break-inside\", \"caption-side\", \"caret-color\", \"clear\", \"clip\", \"clip-path\", \"clip-rule\", \"color\", \"color-interpolation-filters\", \"column-count\", \"column-fill\", \"column-gap\", \"column-rule\", \"column-rule-color\", \"column-rule-style\", \"column-rule-width\", \"columns\", \"column-span\", \"column-width\", \"contain\", \"content\", \"counter-increment\", \"counter-reset\", \"cursor\", \"direction\", \"display\", \"empty-cells\", \"enable-background\", \"fallback\", \"fill\", \"fill-opacity\", \"fill-rule\", \"filter\", \"flex\", \"flex-basis\", \"flex-direction\", \"flex-flow\", \"flex-grow\", \"flex-shrink\", \"flex-wrap\", \"float\", \"flood-color\", \"flood-opacity\", \"font\", \"font-family\", \"font-feature-settings\", \"font-kerning\", \"font-language-override\", \"font-size\", \"font-size-adjust\", \"font-stretch\", \"font-style\", \"font-synthesis\", \"font-variant\", \"font-variant-alternates\", \"font-variant-caps\", \"font-variant-east-asian\", \"font-variant-ligatures\", \"font-variant-numeric\", \"font-variant-position\", \"font-weight\", \"glyph-orientation-horizontal\", \"glyph-orientation-vertical\", \"grid-area\", \"grid-auto-columns\", \"grid-auto-flow\", \"grid-auto-rows\", \"grid-column\", \"grid-column-end\", \"grid-column-gap\", \"grid-column-start\", \"grid-gap\", \"grid-row\", \"grid-row-end\", \"grid-row-gap\", \"grid-row-start\", \"grid-template\", \"grid-template-areas\", \"grid-template-columns\", \"grid-template-rows\", \"height\", \"hyphens\", \"image-orientation\", \"image-rendering\", \"ime-mode\", \"inline-size\", \"isolation\", \"justify-content\", \"kerning\", \"left\", \"letter-spacing\", \"lighting-color\", \"line-break\", \"line-height\", \"list-style\", \"list-style-image\", \"list-style-position\", \"list-style-type\", \"margin\", \"margin-block-end\", \"margin-block-start\", \"margin-bottom\", \"margin-inline-end\", \"margin-inline-start\", \"margin-left\", \"margin-right\", \"margin-top\", \"marker\", \"marker-end\", \"marker-mid\", \"marker-start\", \"mask-type\", \"max-block-size\", \"max-height\", \"max-inline-size\", \"max-width\", \"min-block-size\", \"min-height\", \"min-inline-size\", \"min-width\", \"mix-blend-mode\", \"motion\", \"motion-offset\", \"motion-path\", \"motion-rotation\", \"-moz-animation\", \"-moz-animation-delay\", \"-moz-animation-direction\", \"-moz-animation-duration\", \"-moz-animation-iteration-count\", \"-moz-animation-name\", \"-moz-animation-play-state\", \"-moz-animation-timing-function\", \"-moz-appearance\", \"-moz-backface-visibility\", \"-moz-background-clip\", \"-moz-background-inline-policy\", \"-moz-background-origin\", \"-moz-border-bottom-colors\", \"-moz-border-image\", \"-moz-border-left-colors\", \"-moz-border-right-colors\", \"-moz-border-top-colors\", \"-moz-box-align\", \"-moz-box-direction\", \"-moz-box-flex\", \"-moz-box-flexgroup\", \"-moz-box-ordinal-group\", \"-moz-box-orient\", \"-moz-box-pack\", \"-moz-box-sizing\", \"-moz-column-count\", \"-moz-column-gap\", \"-moz-column-rule\", \"-moz-column-rule-color\", \"-moz-column-rule-style\", \"-moz-column-rule-width\", \"-moz-columns\", \"-moz-column-width\", \"-moz-font-feature-settings\", \"-moz-hyphens\", \"-moz-perspective\", \"-moz-perspective-origin\", \"-moz-text-align-last\", \"-moz-text-decoration-color\", \"-moz-text-decoration-line\", \"-moz-text-decoration-style\", \"-moz-text-size-adjust\", \"-moz-transform\", \"-moz-transform-origin\", \"-moz-transition\", \"-moz-transition-delay\", \"-moz-transition-duration\", \"-moz-transition-property\", \"-moz-transition-timing-function\", \"-moz-user-focus\", \"-moz-user-select\", \"-ms-accelerator\", \"-ms-behavior\", \"-ms-block-progression\", \"-ms-content-zoom-chaining\", \"-ms-content-zooming\", \"-ms-content-zoom-limit\", \"-ms-content-zoom-limit-max\", \"-ms-content-zoom-limit-min\", \"-ms-content-zoom-snap\", \"-ms-content-zoom-snap-points\", \"-ms-content-zoom-snap-type\", \"-ms-filter\", \"-ms-flex\", \"-ms-flex-align\", \"-ms-flex-direction\", \"-ms-flex-flow\", \"-ms-flex-item-align\", \"-ms-flex-line-pack\", \"-ms-flex-order\", \"-ms-flex-pack\", \"-ms-flex-wrap\", \"-ms-flow-from\", \"-ms-flow-into\", \"-ms-grid-column\", \"-ms-grid-column-align\", \"-ms-grid-columns\", \"-ms-grid-column-span\", \"-ms-grid-layer\", \"-ms-grid-row\", \"-ms-grid-row-align\", \"-ms-grid-rows\", \"-ms-grid-row-span\", \"-ms-high-contrast-adjust\", \"-ms-hyphenate-limit-chars\", \"-ms-hyphenate-limit-lines\", \"-ms-hyphenate-limit-zone\", \"-ms-hyphens\", \"-ms-ime-mode\", \"-ms-interpolation-mode\", \"-ms-layout-grid\", \"-ms-layout-grid-char\", \"-ms-layout-grid-line\", \"-ms-layout-grid-mode\", \"-ms-layout-grid-type\", \"-ms-line-break\", \"-ms-overflow-style\", \"-ms-perspective\", \"-ms-perspective-origin\", \"-ms-perspective-origin-x\", \"-ms-perspective-origin-y\", \"-ms-progress-appearance\", \"-ms-scrollbar-3dlight-color\", \"-ms-scrollbar-arrow-color\", \"-ms-scrollbar-base-color\", \"-ms-scrollbar-darkshadow-color\", \"-ms-scrollbar-face-color\", \"-ms-scrollbar-highlight-color\", \"-ms-scrollbar-shadow-color\", \"-ms-scrollbar-track-color\", \"-ms-scroll-chaining\", \"-ms-scroll-limit\", \"-ms-scroll-limit-x-max\", \"-ms-scroll-limit-x-min\", \"-ms-scroll-limit-y-max\", \"-ms-scroll-limit-y-min\", \"-ms-scroll-rails\", \"-ms-scroll-snap-points-x\", \"-ms-scroll-snap-points-y\", \"-ms-scroll-snap-type\", \"-ms-scroll-snap-x\", \"-ms-scroll-snap-y\", \"-ms-scroll-translation\", \"-ms-text-align-last\", \"-ms-text-autospace\", \"-ms-text-combine-horizontal\", \"-ms-text-justify\", \"-ms-text-kashida-space\", \"-ms-text-overflow\", \"-ms-text-size-adjust\", \"-ms-text-underline-position\", \"-ms-touch-action\", \"-ms-touch-select\", \"-ms-transform\", \"-ms-transform-origin\", \"-ms-transform-origin-x\", \"-ms-transform-origin-y\", \"-ms-transform-origin-z\", \"-ms-user-select\", \"-ms-word-break\", \"-ms-word-wrap\", \"-ms-wrap-flow\", \"-ms-wrap-margin\", \"-ms-wrap-through\", \"-ms-writing-mode\", \"-ms-zoom\", \"-ms-zoom-animation\", \"nav-down\", \"nav-index\", \"nav-left\", \"nav-right\", \"nav-up\", \"negative\", \"-o-animation\", \"-o-animation-delay\", \"-o-animation-direction\", \"-o-animation-duration\", \"-o-animation-fill-mode\", \"-o-animation-iteration-count\", \"-o-animation-name\", \"-o-animation-play-state\", \"-o-animation-timing-function\", \"object-fit\", \"object-position\", \"-o-border-image\", \"-o-object-fit\", \"-o-object-position\", \"opacity\", \"order\", \"orphans\", \"-o-table-baseline\", \"-o-tab-size\", \"-o-text-overflow\", \"-o-transform\", \"-o-transform-origin\", \"-o-transition\", \"-o-transition-delay\", \"-o-transition-duration\", \"-o-transition-property\", \"-o-transition-timing-function\", \"offset-block-end\", \"offset-block-start\", \"offset-inline-end\", \"offset-inline-start\", \"outline\", \"outline-color\", \"outline-offset\", \"outline-style\", \"outline-width\", \"overflow\", \"overflow-wrap\", \"overflow-x\", \"overflow-y\", \"pad\", \"padding\", \"padding-bottom\", \"padding-block-end\", \"padding-block-start\", \"padding-inline-end\", \"padding-inline-start\", \"padding-left\", \"padding-right\", \"padding-top\", \"page-break-after\", \"page-break-before\", \"page-break-inside\", \"paint-order\", \"perspective\", \"perspective-origin\", \"pointer-events\", \"position\", \"prefix\", \"quotes\", \"range\", \"resize\", \"right\", \"ruby-align\", \"ruby-overhang\", \"ruby-position\", \"ruby-span\", \"scrollbar-3dlight-color\", \"scrollbar-arrow-color\", \"scrollbar-base-color\", \"scrollbar-darkshadow-color\", \"scrollbar-face-color\", \"scrollbar-highlight-color\", \"scrollbar-shadow-color\", \"scrollbar-track-color\", \"scroll-behavior\", \"scroll-snap-coordinate\", \"scroll-snap-destination\", \"scroll-snap-points-x\", \"scroll-snap-points-y\", \"scroll-snap-type\", \"shape-image-threshold\", \"shape-margin\", \"shape-outside\", \"shape-rendering\", \"size\", \"src\", \"stop-color\", \"stop-opacity\", \"stroke\", \"stroke-dasharray\", \"stroke-dashoffset\", \"stroke-linecap\", \"stroke-linejoin\", \"stroke-miterlimit\", \"stroke-opacity\", \"stroke-width\", \"suffix\", \"system\", \"symbols\", \"table-layout\", \"tab-size\", \"text-align\", \"text-align-last\", \"text-anchor\", \"text-decoration\", \"text-decoration-color\", \"text-decoration-line\", \"text-decoration-style\", \"text-indent\", \"text-justify\", \"text-orientation\", \"text-overflow\", \"text-rendering\", \"text-shadow\", \"text-transform\", \"text-underline-position\", \"top\", \"touch-action\", \"transform\", \"transform-origin\", \"transform-style\", \"transition\", \"transition-delay\", \"transition-duration\", \"transition-property\", \"transition-timing-function\", \"unicode-bidi\", \"unicode-range\", \"user-select\", \"vertical-align\", \"visibility\", \"-webkit-animation\", \"-webkit-animation-delay\", \"-webkit-animation-direction\", \"-webkit-animation-duration\", \"-webkit-animation-fill-mode\", \"-webkit-animation-iteration-count\", \"-webkit-animation-name\", \"-webkit-animation-play-state\", \"-webkit-animation-timing-function\", \"-webkit-appearance\", \"-webkit-backdrop-filter\", \"-webkit-backface-visibility\", \"-webkit-background-clip\", \"-webkit-background-composite\", \"-webkit-background-origin\", \"-webkit-border-image\", \"-webkit-box-align\", \"-webkit-box-direction\", \"-webkit-box-flex\", \"-webkit-box-flex-group\", \"-webkit-box-ordinal-group\", \"-webkit-box-orient\", \"-webkit-box-pack\", \"-webkit-box-reflect\", \"-webkit-box-sizing\", \"-webkit-break-after\", \"-webkit-break-before\", \"-webkit-break-inside\", \"-webkit-column-break-after\", \"-webkit-column-break-before\", \"-webkit-column-break-inside\", \"-webkit-column-count\", \"-webkit-column-gap\", \"-webkit-column-rule\", \"-webkit-column-rule-color\", \"-webkit-column-rule-style\", \"-webkit-column-rule-width\", \"-webkit-columns\", \"-webkit-column-span\", \"-webkit-column-width\", \"-webkit-filter\", \"-webkit-flow-from\", \"-webkit-flow-into\", \"-webkit-font-feature-settings\", \"-webkit-hyphens\", \"-webkit-line-break\", \"-webkit-margin-bottom-collapse\", \"-webkit-margin-collapse\", \"-webkit-margin-start\", \"-webkit-margin-top-collapse\", \"-webkit-mask-clip\", \"-webkit-mask-image\", \"-webkit-mask-origin\", \"-webkit-mask-repeat\", \"-webkit-mask-size\", \"-webkit-nbsp-mode\", \"-webkit-overflow-scrolling\", \"-webkit-padding-start\", \"-webkit-perspective\", \"-webkit-perspective-origin\", \"-webkit-region-fragment\", \"-webkit-tap-highlight-color\", \"-webkit-text-fill-color\", \"-webkit-text-size-adjust\", \"-webkit-text-stroke\", \"-webkit-text-stroke-color\", \"-webkit-text-stroke-width\", \"-webkit-touch-callout\", \"-webkit-transform\", \"-webkit-transform-origin\", \"-webkit-transform-origin-x\", \"-webkit-transform-origin-y\", \"-webkit-transform-origin-z\", \"-webkit-transform-style\", \"-webkit-transition\", \"-webkit-transition-delay\", \"-webkit-transition-duration\", \"-webkit-transition-property\", \"-webkit-transition-timing-function\", \"-webkit-user-drag\", \"-webkit-user-modify\", \"-webkit-user-select\", \"white-space\", \"widows\", \"width\", \"will-change\", \"word-break\", \"word-spacing\", \"word-wrap\", \"writing-mode\", \"z-index\", \"zoom\"]\n};\nvar htmlData = {\n    \"tags\": [\n        \"body\", \"head\", \"html\",\n        \"address\", \"blockquote\", \"dd\", \"div\", \"section\", \"article\", \"aside\", \"header\", \"footer\", \"nav\", \"menu\", \"dl\", \"dt\", \"fieldset\", \"form\", \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"iframe\", \"noframes\", \"object\", \"ol\", \"p\", \"ul\", \"applet\", \"center\", \"dir\", \"hr\", \"pre\",\n        \"a\", \"abbr\", \"acronym\", \"area\", \"b\", \"base\", \"basefont\", \"bdo\", \"big\", \"br\", \"button\", \"caption\", \"cite\", \"code\", \"col\", \"colgroup\", \"del\", \"dfn\", \"em\", \"font\", \"i\", \"img\", \"input\", \"ins\", \"isindex\", \"kbd\", \"label\", \"legend\", \"li\", \"link\", \"map\", \"meta\", \"noscript\", \"optgroup\", \"option\", \"param\", \"q\", \"s\", \"samp\", \"script\", \"select\", \"small\", \"span\", \"strike\", \"strong\", \"style\", \"sub\", \"sup\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"title\", \"tr\", \"tt\", \"u\", \"var\",\n        \"canvas\", \"main\", \"figure\", \"plaintext\", \"figcaption\", \"hgroup\", \"details\", \"summary\"\n    ]\n};\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar snippetKeyCache = new Map();\nvar markupSnippetKeys;\nvar stylesheetCustomSnippetsKeyCache = new Map();\nvar htmlAbbreviationStartRegex = /^[a-z,A-Z,!,(,[,#,\\.\\{]/;\n// take off { for jsx because it interferes with the language\nvar jsxAbbreviationStartRegex = /^[a-z,A-Z,!,(,[,#,\\.]/;\nvar cssAbbreviationRegex = /^-?[a-z,A-Z,!,@,#]/;\nvar htmlAbbreviationRegex = /[a-z,A-Z\\.]/;\nvar commonlyUsedTags = __spreadArray(__spreadArray([], htmlData.tags, true), ['lorem'], false);\nvar bemFilterSuffix = 'bem';\nvar filterDelimitor = '|';\nvar trimFilterSuffix = 't';\nvar commentFilterSuffix = 'c';\nvar maxFilters = 3;\n/**\n * Returns all applicable emmet expansions for abbreviation at given position in a CompletionList\n * @param model TextModel in which completions are requested\n * @param position Position in the document at which completions are requested\n * @param syntax Emmet supported language\n * @param emmetConfig Emmet Configurations as derived from VS Code\n */\nfunction doComplete(monaco, model, position, syntax, emmetConfig) {\n    var _a;\n    var isStyleSheetRes = isStyleSheet(syntax);\n    // Fetch markupSnippets so that we can provide possible abbreviation completions\n    // For example, when text at position is `a`, completions should return `a:blank`, `a:link`, `acr` etc.\n    if (!isStyleSheetRes) {\n        if (!snippetKeyCache.has(syntax)) {\n            var registry = getDefaultSnippets(syntax);\n            snippetKeyCache.set(syntax, Object.keys(registry));\n        }\n        markupSnippetKeys = (_a = snippetKeyCache.get(syntax)) !== null && _a !== void 0 ? _a : [];\n    }\n    var extractOptions = {\n        lookAhead: !isStyleSheetRes,\n        type: getSyntaxType(syntax),\n    };\n    var extractedValue = extractAbbreviation(monaco, model, position, extractOptions);\n    if (!extractedValue)\n        return;\n    var abbreviationRange = extractedValue.abbreviationRange, abbreviation = extractedValue.abbreviation, currentLineTillPosition = extractedValue.currentLineTillPosition, filter = extractedValue.filter;\n    var currentWord = getCurrentWord(currentLineTillPosition);\n    // Don't attempt to expand open tags\n    if (currentWord === abbreviation && currentLineTillPosition.endsWith(\"<\".concat(abbreviation)) && !isStyleSheetRes) {\n        return;\n    }\n    var expandOptions = getExpandOptions(syntax, filter);\n    var expandedText = '';\n    var expandedAbbr;\n    var completionItems = [];\n    // Create completion item after expanding given abbreviation\n    // if abbreviation is valid and expanded value is not noise\n    var createExpandedAbbr = function (syntax, abbr) {\n        if (!isAbbreviationValid(syntax, abbreviation))\n            return;\n        try {\n            expandedText = expandAbbreviation$1(abbr, expandOptions);\n            // manually patch https://github.com/microsoft/vscode/issues/120245 for now\n            if (isStyleSheetRes && '!important'.startsWith(abbr)) {\n                expandedText = '!important';\n            }\n        }\n        catch (e) { }\n        if (!expandedText || isExpandedTextNoise(syntax, abbr, expandedText, expandOptions.options)) {\n            return;\n        }\n        expandedAbbr = {\n            kind: monaco.languages.CompletionItemKind.Property,\n            label: abbreviation + (filter ? '|' + filter.replace(',', '|') : ''),\n            documentation: replaceTabStopsWithCursors(expandedText),\n            detail: 'Emmet abbreviation',\n            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,\n            range: abbreviationRange,\n            insertText: escapeNonTabStopDollar(addFinalTabStop(expandedText)),\n        };\n        completionItems = [expandedAbbr];\n    };\n    createExpandedAbbr(syntax, abbreviation);\n    if (isStyleSheetRes) {\n        // When abbr is longer than usual emmet snippets and matches better with existing css property, then no emmet\n        if (abbreviation.length > 4 && cssData.properties.some(function (x) { return x.startsWith(abbreviation); })) {\n            return { suggestions: [], incomplete: true };\n        }\n        if (expandedAbbr && expandedText.length) {\n            expandedAbbr.range = abbreviationRange;\n            expandedAbbr.insertText = escapeNonTabStopDollar(addFinalTabStop(expandedText));\n            expandedAbbr.documentation = replaceTabStopsWithCursors(expandedText);\n            expandedAbbr.label = removeTabStops(expandedText);\n            expandedAbbr.filterText = abbreviation;\n            // Custom snippets should show up in completions if abbreviation is a prefix\n            var stylesheetCustomSnippetsKeys = stylesheetCustomSnippetsKeyCache.has(syntax)\n                ? stylesheetCustomSnippetsKeyCache.get(syntax)\n                : stylesheetCustomSnippetsKeyCache.get('css');\n            completionItems = makeSnippetSuggestion(monaco, stylesheetCustomSnippetsKeys !== null && stylesheetCustomSnippetsKeys !== void 0 ? stylesheetCustomSnippetsKeys : [], abbreviation, abbreviation, abbreviationRange, expandOptions, 'Emmet Custom Snippet', false);\n            if (!completionItems.find(function (x) { return x.insertText === (expandedAbbr === null || expandedAbbr === void 0 ? void 0 : expandedAbbr.insertText); })) {\n                // Fix for https://github.com/Microsoft/vscode/issues/28933#issuecomment-309236902\n                // When user types in propertyname, emmet uses it to match with snippet names, resulting in width -> widows or font-family -> font: family\n                // Filter out those cases here.\n                var abbrRegex = new RegExp('.*' +\n                    abbreviation\n                        .split('')\n                        .map(function (x) { return (x === '$' || x === '+' ? '\\\\' + x : x); })\n                        .join('.*') +\n                    '.*', 'i');\n                if (/\\d/.test(abbreviation) || abbrRegex.test(expandedAbbr.label)) {\n                    completionItems.push(expandedAbbr);\n                }\n            }\n        }\n    }\n    else {\n        var tagToFindMoreSuggestionsFor = abbreviation;\n        var newTagMatches = abbreviation.match(/(>|\\+)([\\w:-]+)$/);\n        if (newTagMatches && newTagMatches.length === 3) {\n            tagToFindMoreSuggestionsFor = newTagMatches[2];\n        }\n        if (syntax !== 'xml') {\n            var commonlyUsedTagSuggestions = makeSnippetSuggestion(monaco, commonlyUsedTags, tagToFindMoreSuggestionsFor, abbreviation, abbreviationRange, expandOptions, 'Emmet Abbreviation');\n            completionItems = completionItems.concat(commonlyUsedTagSuggestions);\n        }\n        if (emmetConfig.showAbbreviationSuggestions === true) {\n            var abbreviationSuggestions = makeSnippetSuggestion(monaco, markupSnippetKeys.filter(function (x) { return !commonlyUsedTags.includes(x); }), tagToFindMoreSuggestionsFor, abbreviation, abbreviationRange, expandOptions, 'Emmet Abbreviation');\n            // Workaround for the main expanded abbr not appearing before the snippet suggestions\n            if (expandedAbbr && abbreviationSuggestions.length > 0 && tagToFindMoreSuggestionsFor !== abbreviation) {\n                expandedAbbr.sortText = '0' + expandedAbbr.label;\n                abbreviationSuggestions.forEach(function (item) {\n                    // Workaround for snippet suggestions items getting filtered out as the complete abbr does not start with snippetKey\n                    item.filterText = abbreviation;\n                    // Workaround for the main expanded abbr not appearing before the snippet suggestions\n                    item.sortText = '9' + abbreviation;\n                });\n            }\n            completionItems = completionItems.concat(abbreviationSuggestions);\n        }\n        // https://github.com/microsoft/vscode/issues/66680\n        if (syntax === 'html' &&\n            completionItems.length >= 2 &&\n            abbreviation.includes(':') &&\n            (expandedAbbr === null || expandedAbbr === void 0 ? void 0 : expandedAbbr.insertText) === \"<\".concat(abbreviation, \">${0}</\").concat(abbreviation, \">\")) {\n            completionItems = completionItems.filter(function (item) { return item.label !== abbreviation; });\n        }\n    }\n    if (emmetConfig.showSuggestionsAsSnippets === true) {\n        completionItems.forEach(function (x) { return (x.kind = monaco.languages.CompletionItemKind.Snippet); });\n    }\n    return completionItems.length ? { suggestions: completionItems, incomplete: true } : undefined;\n}\n/**\n * Create & return snippets for snippet keys that start with given prefix\n */\nfunction makeSnippetSuggestion(monaco, snippetKeys, prefix, abbreviation, abbreviationRange, expandOptions, snippetDetail, skipFullMatch) {\n    if (skipFullMatch === void 0) { skipFullMatch = true; }\n    if (!prefix || !snippetKeys) {\n        return [];\n    }\n    var snippetCompletions = [];\n    snippetKeys.forEach(function (snippetKey) {\n        if (!snippetKey.startsWith(prefix.toLowerCase()) || (skipFullMatch && snippetKey === prefix.toLowerCase())) {\n            return;\n        }\n        var currentAbbr = abbreviation + snippetKey.substr(prefix.length);\n        var expandedAbbr;\n        try {\n            expandedAbbr = expandAbbreviation$1(currentAbbr, expandOptions);\n        }\n        catch (e) { }\n        if (!expandedAbbr) {\n            return;\n        }\n        var item = {\n            kind: monaco.languages.CompletionItemKind.Property,\n            label: prefix + snippetKey.substr(prefix.length),\n            documentation: replaceTabStopsWithCursors(expandedAbbr),\n            detail: snippetDetail,\n            insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,\n            range: abbreviationRange,\n            insertText: escapeNonTabStopDollar(addFinalTabStop(expandedAbbr)),\n        };\n        snippetCompletions.push(item);\n    });\n    return snippetCompletions;\n}\nfunction getCurrentWord(currentLineTillPosition) {\n    if (currentLineTillPosition) {\n        var matches = currentLineTillPosition.match(/[\\w,:,-,\\.]*$/);\n        if (matches) {\n            return matches[0];\n        }\n    }\n}\nfunction replaceTabStopsWithCursors(expandedWord) {\n    return expandedWord.replace(/([^\\\\])\\$\\{\\d+\\}/g, '$1|').replace(/\\$\\{\\d+:([^\\}]+)\\}/g, '$1');\n}\nfunction removeTabStops(expandedWord) {\n    return expandedWord.replace(/([^\\\\])\\$\\{\\d+\\}/g, '$1').replace(/\\$\\{\\d+:([^\\}]+)\\}/g, '$1');\n}\nfunction escapeNonTabStopDollar(text) {\n    return text ? text.replace(/([^\\\\])(\\$)([^\\{])/g, '$1\\\\$2$3') : text;\n}\nfunction addFinalTabStop(text) {\n    if (!text || !text.trim()) {\n        return text;\n    }\n    var maxTabStop = -1;\n    var maxTabStopRanges = [];\n    var foundLastStop = false;\n    var replaceWithLastStop = false;\n    var i = 0;\n    var n = text.length;\n    try {\n        while (i < n && !foundLastStop) {\n            // Look for ${\n            if (text[i++] != '$' || text[i++] != '{') {\n                continue;\n            }\n            // Find tabstop\n            var numberStart = -1;\n            var numberEnd = -1;\n            while (i < n && /\\d/.test(text[i])) {\n                numberStart = numberStart < 0 ? i : numberStart;\n                numberEnd = i + 1;\n                i++;\n            }\n            // If ${ was not followed by a number and either } or :, then its not a tabstop\n            if (numberStart === -1 || numberEnd === -1 || i >= n || (text[i] != '}' && text[i] != ':')) {\n                continue;\n            }\n            // If ${0} was found, then break\n            var currentTabStop = text.substring(numberStart, numberEnd);\n            foundLastStop = currentTabStop === '0';\n            if (foundLastStop) {\n                break;\n            }\n            var foundPlaceholder = false;\n            if (text[i++] == ':') {\n                // TODO: Nested placeholders may break here\n                while (i < n) {\n                    if (text[i] == '}') {\n                        foundPlaceholder = true;\n                        break;\n                    }\n                    i++;\n                }\n            }\n            // Decide to replace currentTabStop with ${0} only if its the max among all tabstops and is not a placeholder\n            if (Number(currentTabStop) > Number(maxTabStop)) {\n                maxTabStop = Number(currentTabStop);\n                maxTabStopRanges = [{ numberStart: numberStart, numberEnd: numberEnd }];\n                replaceWithLastStop = !foundPlaceholder;\n            }\n            else if (Number(currentTabStop) === maxTabStop) {\n                maxTabStopRanges.push({ numberStart: numberStart, numberEnd: numberEnd });\n            }\n        }\n    }\n    catch (e) { }\n    if (replaceWithLastStop && !foundLastStop) {\n        for (var i_1 = 0; i_1 < maxTabStopRanges.length; i_1++) {\n            var rangeStart = maxTabStopRanges[i_1].numberStart;\n            var rangeEnd = maxTabStopRanges[i_1].numberEnd;\n            text = text.substr(0, rangeStart) + '0' + text.substr(rangeEnd);\n        }\n    }\n    return text;\n}\nvar emmetSnippetField = function (index, placeholder) { return \"${\".concat(index).concat(placeholder ? ':' + placeholder : '', \"}\"); };\n/** Returns whether or not syntax is a supported stylesheet syntax, like CSS */\nfunction isStyleSheet(syntax) {\n    return syntax === 'css';\n}\n/** Returns the syntax type, either markup (e.g. for HTML) or stylesheet (e.g. for CSS) */\nfunction getSyntaxType(syntax) {\n    return isStyleSheet(syntax) ? 'stylesheet' : 'markup';\n}\n/** Returns the default snippets that Emmet suggests */\nfunction getDefaultSnippets(syntax) {\n    var syntaxType = getSyntaxType(syntax);\n    var emptyUserConfig = { type: syntaxType, syntax: syntax };\n    var resolvedConfig = resolveConfig(emptyUserConfig);\n    // https://github.com/microsoft/vscode/issues/97632\n    // don't return markup (HTML) snippets for XML\n    return syntax === 'xml' ? {} : resolvedConfig.snippets;\n}\nfunction getFilters(text, pos) {\n    var filter;\n    for (var i = 0; i < maxFilters; i++) {\n        if (text.endsWith(\"\".concat(filterDelimitor).concat(bemFilterSuffix), pos)) {\n            pos -= bemFilterSuffix.length + 1;\n            filter = filter ? bemFilterSuffix + ',' + filter : bemFilterSuffix;\n        }\n        else if (text.endsWith(\"\".concat(filterDelimitor).concat(commentFilterSuffix), pos)) {\n            pos -= commentFilterSuffix.length + 1;\n            filter = filter ? commentFilterSuffix + ',' + filter : commentFilterSuffix;\n        }\n        else if (text.endsWith(\"\".concat(filterDelimitor).concat(trimFilterSuffix), pos)) {\n            pos -= trimFilterSuffix.length + 1;\n            filter = filter ? trimFilterSuffix + ',' + filter : trimFilterSuffix;\n        }\n        else {\n            break;\n        }\n    }\n    return {\n        pos: pos,\n        filter: filter,\n    };\n}\n/**\n * Extracts abbreviation from the given position in the given document\n * @param model The TextModel from which abbreviation needs to be extracted\n * @param position The Position in the given document from where abbreviation needs to be extracted\n * @param options The options to pass to the @emmetio/extract-abbreviation module\n */\nfunction extractAbbreviation(monaco, model, position, options) {\n    var currentLine = model.getLineContent(position.lineNumber);\n    var currentLineTillPosition = currentLine.substr(0, position.column - 1);\n    var _a = getFilters(currentLineTillPosition, position.column - 1), pos = _a.pos, filter = _a.filter;\n    var lengthOccupiedByFilter = filter ? filter.length + 1 : 0;\n    var result = extractAbbreviation$1(currentLine, pos, options);\n    if (!result)\n        return;\n    var rangeToReplace = new monaco.Range(position.lineNumber, result.location + 1, position.lineNumber, result.location + result.abbreviation.length + lengthOccupiedByFilter + 1);\n    return {\n        abbreviationRange: rangeToReplace,\n        abbreviation: result.abbreviation,\n        currentLineTillPosition: currentLineTillPosition,\n        filter: filter,\n    };\n}\n/**\n * Returns a boolean denoting validity of given abbreviation in the context of given syntax\n * Not needed once https://github.com/emmetio/atom-plugin/issues/22 is fixed\n * @param syntax string\n * @param abbreviation string\n */\nfunction isAbbreviationValid(syntax, abbreviation) {\n    if (!abbreviation) {\n        return false;\n    }\n    if (isStyleSheet(syntax)) {\n        if (abbreviation.includes('#')) {\n            if (abbreviation.startsWith('#')) {\n                var hexColorRegex = /^#[\\d,a-f,A-F]{1,6}$/;\n                return hexColorRegex.test(abbreviation);\n            }\n            else if (commonlyUsedTags.includes(abbreviation.substring(0, abbreviation.indexOf('#')))) {\n                return false;\n            }\n        }\n        return cssAbbreviationRegex.test(abbreviation);\n    }\n    if (abbreviation.startsWith('!')) {\n        return !/[^!]/.test(abbreviation);\n    }\n    // Its common for users to type (sometextinsidebrackets), this should not be treated as an abbreviation\n    // Grouping in abbreviation is valid only if it's inside a text node or preceeded/succeeded with one of the symbols for nesting, sibling, repeater or climb up\n    // Also, cases such as `span[onclick=\"alert();\"]` are valid\n    if ((/\\(/.test(abbreviation) || /\\)/.test(abbreviation)) &&\n        !/\\{[^\\}\\{]*[\\(\\)]+[^\\}\\{]*\\}(?:[>\\+\\*\\^]|$)/.test(abbreviation) &&\n        !/\\(.*\\)[>\\+\\*\\^]/.test(abbreviation) &&\n        !/\\[[^\\[\\]\\(\\)]+=\".*\"\\]/.test(abbreviation) &&\n        !/[>\\+\\*\\^]\\(.*\\)/.test(abbreviation)) {\n        return false;\n    }\n    if (syntax === 'jsx') {\n        return jsxAbbreviationStartRegex.test(abbreviation) && htmlAbbreviationRegex.test(abbreviation);\n    }\n    return htmlAbbreviationStartRegex.test(abbreviation) && htmlAbbreviationRegex.test(abbreviation);\n}\nfunction isExpandedTextNoise(syntax, abbreviation, expandedText, options) {\n    var _a, _b;\n    // Unresolved css abbreviations get expanded to a blank property value\n    // Eg: abc -> abc: ; or abc:d -> abc: d; which is noise if it gets suggested for every word typed\n    if (isStyleSheet(syntax) && options) {\n        var between = (_a = options['stylesheet.between']) !== null && _a !== void 0 ? _a : ': ';\n        var after = (_b = options['stylesheet.after']) !== null && _b !== void 0 ? _b : ';';\n        // Remove overlapping between `abbreviation` and `between`, if any\n        var endPrefixIndex = abbreviation.indexOf(between[0], Math.max(abbreviation.length - between.length, 0));\n        endPrefixIndex = endPrefixIndex >= 0 ? endPrefixIndex : abbreviation.length;\n        var abbr = abbreviation.substring(0, endPrefixIndex);\n        return (expandedText === \"\".concat(abbr).concat(between, \"${0}\").concat(after) ||\n            expandedText.replace(/\\s/g, '') === abbreviation.replace(/\\s/g, '') + after);\n    }\n    // we don't want common html tags suggested for xml\n    if (syntax === 'xml' && commonlyUsedTags.some(function (tag) { return tag.startsWith(abbreviation.toLowerCase()); })) {\n        return true;\n    }\n    if (commonlyUsedTags.includes(abbreviation.toLowerCase()) || markupSnippetKeys.includes(abbreviation)) {\n        return false;\n    }\n    // Custom tags can have - or :\n    if (/[-,:]/.test(abbreviation) && !/--|::/.test(abbreviation) && !abbreviation.endsWith(':')) {\n        return false;\n    }\n    // Its common for users to type some text and end it with period, this should not be treated as an abbreviation\n    // Else it becomes noise.\n    // When user just types '.', return the expansion\n    // Otherwise emmet loses change to participate later\n    // For example in `.foo`. See https://github.com/Microsoft/vscode/issues/66013\n    if (abbreviation === '.') {\n        return false;\n    }\n    var dotMatches = abbreviation.match(/^([a-z,A-Z,\\d]*)\\.$/);\n    if (dotMatches) {\n        // Valid html tags such as `div.`\n        if (dotMatches[1] && htmlData.tags.includes(dotMatches[1])) {\n            return false;\n        }\n        return true;\n    }\n    // Fix for https://github.com/microsoft/vscode/issues/89746\n    // PascalCase tags are common in jsx code, which should not be treated as noise.\n    // Eg: MyAwesomComponent -> <MyAwesomComponent></MyAwesomComponent>\n    if (syntax === 'jsx' && /^([A-Z][A-Za-z0-9]*)+$/.test(abbreviation)) {\n        return false;\n    }\n    // Unresolved html abbreviations get expanded as if it were a tag\n    // Eg: abc -> <abc></abc> which is noise if it gets suggested for every word typed\n    return expandedText.toLowerCase() === \"<\".concat(abbreviation.toLowerCase(), \">${1}</\").concat(abbreviation.toLowerCase(), \">\");\n}\n/**\n * Returns options to be used by emmet\n */\nfunction getExpandOptions(syntax, filter) {\n    var type = getSyntaxType(syntax);\n    var filters = filter ? filter.split(',').map(function (x) { return x.trim(); }) : [];\n    var bemEnabled = filters.includes('bem');\n    var commentEnabled = filters.includes('c');\n    var combinedOptions = {\n        'output.formatSkip': ['html'],\n        'output.formatForce': ['body'],\n        'output.field': emmetSnippetField,\n        'output.inlineBreak': 0,\n        'output.compactBoolean': false,\n        'output.reverseAttributes': false,\n        'markup.href': true,\n        'comment.enabled': commentEnabled,\n        'comment.trigger': ['id', 'class'],\n        'comment.before': '',\n        'comment.after': '\\n<!-- /[#ID][.CLASS] -->',\n        'bem.enabled': bemEnabled,\n        'bem.element': '__',\n        'bem.modifier': '_',\n        'jsx.enabled': syntax === 'jsx',\n        'stylesheet.shortHex': true,\n        'stylesheet.between': syntax === 'stylus' ? ' ' : ': ',\n        'stylesheet.after': syntax === 'sass' || syntax === 'stylus' ? '' : ';',\n        'stylesheet.intUnit': 'px',\n        'stylesheet.floatUnit': 'em',\n        'stylesheet.unitAliases': {\n            e: 'em',\n            p: '%',\n            x: 'ex',\n            r: 'rem',\n        },\n        'stylesheet.fuzzySearchMinScore': 0.3,\n        'output.format': true,\n        'output.selfClosingStyle': 'html',\n    };\n    return {\n        type: type,\n        options: combinedOptions,\n        variables: {},\n        snippets: {},\n        syntax: syntax,\n        // context: null,\n        text: undefined,\n        maxRepeat: 1000,\n        // cache: null\n    };\n}\n/**\n * Expands given abbreviation using given options\n * @param abbreviation string or parsed abbreviation\n * @param config options used by the @emmetio/expand-abbreviation module to expand given abbreviation\n */\nfunction expandAbbreviation(abbreviation, config) {\n    var expandedText;\n    var resolvedConfig = resolveConfig(config);\n    if (config.type === 'stylesheet') {\n        if (typeof abbreviation === 'string') {\n            expandedText = expandAbbreviation$1(abbreviation, resolvedConfig);\n        }\n        else {\n            expandedText = css(abbreviation, resolvedConfig);\n        }\n    }\n    else {\n        if (typeof abbreviation === 'string') {\n            expandedText = expandAbbreviation$1(abbreviation, resolvedConfig);\n        }\n        else {\n            expandedText = stringify(abbreviation, resolvedConfig);\n        }\n    }\n    return escapeNonTabStopDollar(addFinalTabStop(expandedText));\n}\n\nfunction isValidEmmetToken(tokens, index, syntax, language) {\n    var currentTokenType = tokens[index].type;\n    if (syntax === 'html') {\n        // prevent emmet triggered within attributes\n        return ((currentTokenType === '' && (index === 0 || tokens[index - 1].type === 'delimiter.html')) ||\n            // #7 compatible with https://github.com/NeekSandhu/monaco-textmate\n            tokens[0].type === 'text.html.basic');\n    }\n    if (syntax === 'css') {\n        if (currentTokenType === '')\n            return true;\n        // less / scss allow nesting\n        return currentTokenType === 'tag.' + language;\n    }\n    if (syntax === 'jsx') {\n        // type must be `identifier` and not at start\n        return (!!index &&\n            ['identifier.js', 'type.identifier.js', 'identifier.ts', 'type.identifier.ts'].includes(currentTokenType));\n    }\n    return false;\n}\n// vscode did a complex node analysis, we just use monaco's built-in tokenizer\n// to achieve almost the same effect\nfunction isValidLocationForEmmetAbbreviation(model, position, syntax, language) {\n    var column = position.column, lineNumber = position.lineNumber;\n    // get current line's tokens\n    var _tokenization = model._tokenization;\n    var _tokenizationStateStore = _tokenization._tokenizationStateStore;\n    // monaco-editor 0.32.0 changes the api to `_tokenizationStateStore.tokenizationSupport`\n    var _tokenizationSupport = _tokenizationStateStore.tokenizationSupport || _tokenization._tokenizationSupport;\n    var state = _tokenizationStateStore.getBeginState(lineNumber - 1).clone();\n    var tokenizationResult = _tokenizationSupport.tokenize(model.getLineContent(lineNumber), true, state, 0);\n    var tokens = tokenizationResult.tokens;\n    var valid = false;\n    // get token type at current column\n    for (var i = tokens.length - 1; i >= 0; i--) {\n        if (column - 1 > tokens[i].offset) {\n            valid = isValidEmmetToken(tokens, i, syntax, language);\n            break;\n        }\n    }\n    return valid;\n}\n\n// https://github.com/microsoft/vscode/blob/main/extensions/emmet/src/util.ts#L86\nvar LANGUAGE_MODES = {\n    html: ['!', '.', '}', ':', '*', '$', ']', '/', '>', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    jade: ['!', '.', '}', ':', '*', '$', ']', '/', '>', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    slim: ['!', '.', '}', ':', '*', '$', ']', '/', '>', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    haml: ['!', '.', '}', ':', '*', '$', ']', '/', '>', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    xml: ['.', '}', '*', '$', ']', '/', '>', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    xsl: ['!', '.', '}', '*', '$', '/', ']', '>', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    css: [':', '!', '-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    scss: [':', '!', '-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    sass: [':', '!', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    less: [':', '!', '-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    stylus: [':', '!', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    javascript: ['!', '.', '}', '*', '$', ']', '/', '>', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    typescript: ['!', '.', '}', '*', '$', ']', '/', '>', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n};\n// https://github.com/microsoft/vscode/blob/main/extensions/emmet/src/util.ts#L124\nvar MAPPED_MODES = {\n    handlebars: 'html',\n    php: 'html',\n    twig: 'html',\n};\nvar DEFAULT_CONFIG = {\n    showExpandedAbbreviation: 'always',\n    showAbbreviationSuggestions: true,\n    showSuggestionsAsSnippets: false,\n};\n/**\n * add completion provider\n * @param monaco monaco self\n * @param language added language\n * @param isMarkup is markup language\n * @param isLegalToken check whether given token is legal or not\n * @param getLegalEmmetSets get legal emmet substring from a string.\n */\nfunction registerProvider(monaco, languages, syntax) {\n    if (!monaco) {\n        console.error(\"emmet-monaco-es: 'monaco' should be either declared on window or passed as first parameter\");\n        return;\n    }\n    var providers = languages.map(function (language) {\n        return monaco.languages.registerCompletionItemProvider(language, {\n            triggerCharacters: LANGUAGE_MODES[MAPPED_MODES[language] || language],\n            provideCompletionItems: function (model, position) {\n                return isValidLocationForEmmetAbbreviation(model, position, syntax, language)\n                    ? doComplete(monaco, model, position, syntax, DEFAULT_CONFIG)\n                    : undefined;\n            },\n        });\n    });\n    return function () {\n        providers.forEach(function (provider) { return provider.dispose(); });\n    };\n}\nfunction emmetHTML(monaco, languages) {\n    if (monaco === void 0) { monaco = window.monaco; }\n    if (languages === void 0) { languages = ['html']; }\n    return registerProvider(monaco, languages, 'html');\n}\nfunction emmetCSS(monaco, languages) {\n    if (monaco === void 0) { monaco = window.monaco; }\n    if (languages === void 0) { languages = ['css']; }\n    return registerProvider(monaco, languages, 'css');\n}\nfunction emmetJSX(monaco, languages) {\n    if (monaco === void 0) { monaco = window.monaco; }\n    if (languages === void 0) { languages = ['javascript']; }\n    return registerProvider(monaco, languages, 'jsx');\n}\n\nexport { emmetCSS, emmetHTML, emmetJSX, expandAbbreviation };\n","// The programming goals of Split.js are to deliver readable, understandable and\n// maintainable code, while at the same time manually optimizing for tiny minified file size,\n// browser compatibility without additional requirements\n// and very few assumptions about the user's page layout.\nvar global = typeof window !== 'undefined' ? window : null;\nvar ssr = global === null;\nvar document = !ssr ? global.document : undefined;\n\n// Save a couple long function names that are used frequently.\n// This optimization saves around 400 bytes.\nvar addEventListener = 'addEventListener';\nvar removeEventListener = 'removeEventListener';\nvar getBoundingClientRect = 'getBoundingClientRect';\nvar gutterStartDragging = '_a';\nvar aGutterSize = '_b';\nvar bGutterSize = '_c';\nvar HORIZONTAL = 'horizontal';\nvar NOOP = function () { return false; };\n\n// Helper function determines which prefixes of CSS calc we need.\n// We only need to do this once on startup, when this anonymous function is called.\n//\n// Tests -webkit, -moz and -o prefixes. Modified from StackOverflow:\n// http://stackoverflow.com/questions/16625140/js-feature-detection-to-detect-the-usage-of-webkit-calc-over-calc/16625167#16625167\nvar calc = ssr\n    ? 'calc'\n    : ((['', '-webkit-', '-moz-', '-o-']\n          .filter(function (prefix) {\n              var el = document.createElement('div');\n              el.style.cssText = \"width:\" + prefix + \"calc(9px)\";\n\n              return !!el.style.length\n          })\n          .shift()) + \"calc\");\n\n// Helper function checks if its argument is a string-like type\nvar isString = function (v) { return typeof v === 'string' || v instanceof String; };\n\n// Helper function allows elements and string selectors to be used\n// interchangeably. In either case an element is returned. This allows us to\n// do `Split([elem1, elem2])` as well as `Split(['#id1', '#id2'])`.\nvar elementOrSelector = function (el) {\n    if (isString(el)) {\n        var ele = document.querySelector(el);\n        if (!ele) {\n            throw new Error((\"Selector \" + el + \" did not match a DOM element\"))\n        }\n        return ele\n    }\n\n    return el\n};\n\n// Helper function gets a property from the properties object, with a default fallback\nvar getOption = function (options, propName, def) {\n    var value = options[propName];\n    if (value !== undefined) {\n        return value\n    }\n    return def\n};\n\nvar getGutterSize = function (gutterSize, isFirst, isLast, gutterAlign) {\n    if (isFirst) {\n        if (gutterAlign === 'end') {\n            return 0\n        }\n        if (gutterAlign === 'center') {\n            return gutterSize / 2\n        }\n    } else if (isLast) {\n        if (gutterAlign === 'start') {\n            return 0\n        }\n        if (gutterAlign === 'center') {\n            return gutterSize / 2\n        }\n    }\n\n    return gutterSize\n};\n\n// Default options\nvar defaultGutterFn = function (i, gutterDirection) {\n    var gut = document.createElement('div');\n    gut.className = \"gutter gutter-\" + gutterDirection;\n    return gut\n};\n\nvar defaultElementStyleFn = function (dim, size, gutSize) {\n    var style = {};\n\n    if (!isString(size)) {\n        style[dim] = calc + \"(\" + size + \"% - \" + gutSize + \"px)\";\n    } else {\n        style[dim] = size;\n    }\n\n    return style\n};\n\nvar defaultGutterStyleFn = function (dim, gutSize) {\n    var obj;\n\n    return (( obj = {}, obj[dim] = (gutSize + \"px\"), obj ));\n};\n\n// The main function to initialize a split. Split.js thinks about each pair\n// of elements as an independant pair. Dragging the gutter between two elements\n// only changes the dimensions of elements in that pair. This is key to understanding\n// how the following functions operate, since each function is bound to a pair.\n//\n// A pair object is shaped like this:\n//\n// {\n//     a: DOM element,\n//     b: DOM element,\n//     aMin: Number,\n//     bMin: Number,\n//     dragging: Boolean,\n//     parent: DOM element,\n//     direction: 'horizontal' | 'vertical'\n// }\n//\n// The basic sequence:\n//\n// 1. Set defaults to something sane. `options` doesn't have to be passed at all.\n// 2. Initialize a bunch of strings based on the direction we're splitting.\n//    A lot of the behavior in the rest of the library is paramatized down to\n//    rely on CSS strings and classes.\n// 3. Define the dragging helper functions, and a few helpers to go with them.\n// 4. Loop through the elements while pairing them off. Every pair gets an\n//    `pair` object and a gutter.\n// 5. Actually size the pair elements, insert gutters and attach event listeners.\nvar Split = function (idsOption, options) {\n    if ( options === void 0 ) options = {};\n\n    if (ssr) { return {} }\n\n    var ids = idsOption;\n    var dimension;\n    var clientAxis;\n    var position;\n    var positionEnd;\n    var clientSize;\n    var elements;\n\n    // Allow HTMLCollection to be used as an argument when supported\n    if (Array.from) {\n        ids = Array.from(ids);\n    }\n\n    // All DOM elements in the split should have a common parent. We can grab\n    // the first elements parent and hope users read the docs because the\n    // behavior will be whacky otherwise.\n    var firstElement = elementOrSelector(ids[0]);\n    var parent = firstElement.parentNode;\n    var parentStyle = getComputedStyle ? getComputedStyle(parent) : null;\n    var parentFlexDirection = parentStyle ? parentStyle.flexDirection : null;\n\n    // Set default options.sizes to equal percentages of the parent element.\n    var sizes = getOption(options, 'sizes') || ids.map(function () { return 100 / ids.length; });\n\n    // Standardize minSize and maxSize to an array if it isn't already.\n    // This allows minSize and maxSize to be passed as a number.\n    var minSize = getOption(options, 'minSize', 100);\n    var minSizes = Array.isArray(minSize) ? minSize : ids.map(function () { return minSize; });\n    var maxSize = getOption(options, 'maxSize', Infinity);\n    var maxSizes = Array.isArray(maxSize) ? maxSize : ids.map(function () { return maxSize; });\n\n    // Get other options\n    var expandToMin = getOption(options, 'expandToMin', false);\n    var gutterSize = getOption(options, 'gutterSize', 10);\n    var gutterAlign = getOption(options, 'gutterAlign', 'center');\n    var snapOffset = getOption(options, 'snapOffset', 30);\n    var snapOffsets = Array.isArray(snapOffset) ? snapOffset : ids.map(function () { return snapOffset; });\n    var dragInterval = getOption(options, 'dragInterval', 1);\n    var direction = getOption(options, 'direction', HORIZONTAL);\n    var cursor = getOption(\n        options,\n        'cursor',\n        direction === HORIZONTAL ? 'col-resize' : 'row-resize'\n    );\n    var gutter = getOption(options, 'gutter', defaultGutterFn);\n    var elementStyle = getOption(\n        options,\n        'elementStyle',\n        defaultElementStyleFn\n    );\n    var gutterStyle = getOption(options, 'gutterStyle', defaultGutterStyleFn);\n\n    // 2. Initialize a bunch of strings based on the direction we're splitting.\n    // A lot of the behavior in the rest of the library is paramatized down to\n    // rely on CSS strings and classes.\n    if (direction === HORIZONTAL) {\n        dimension = 'width';\n        clientAxis = 'clientX';\n        position = 'left';\n        positionEnd = 'right';\n        clientSize = 'clientWidth';\n    } else if (direction === 'vertical') {\n        dimension = 'height';\n        clientAxis = 'clientY';\n        position = 'top';\n        positionEnd = 'bottom';\n        clientSize = 'clientHeight';\n    }\n\n    // 3. Define the dragging helper functions, and a few helpers to go with them.\n    // Each helper is bound to a pair object that contains its metadata. This\n    // also makes it easy to store references to listeners that that will be\n    // added and removed.\n    //\n    // Even though there are no other functions contained in them, aliasing\n    // this to self saves 50 bytes or so since it's used so frequently.\n    //\n    // The pair object saves metadata like dragging state, position and\n    // event listener references.\n\n    function setElementSize(el, size, gutSize, i) {\n        // Split.js allows setting sizes via numbers (ideally), or if you must,\n        // by string, like '300px'. This is less than ideal, because it breaks\n        // the fluid layout that `calc(% - px)` provides. You're on your own if you do that,\n        // make sure you calculate the gutter size by hand.\n        var style = elementStyle(dimension, size, gutSize, i);\n\n        Object.keys(style).forEach(function (prop) {\n            // eslint-disable-next-line no-param-reassign\n            el.style[prop] = style[prop];\n        });\n    }\n\n    function setGutterSize(gutterElement, gutSize, i) {\n        var style = gutterStyle(dimension, gutSize, i);\n\n        Object.keys(style).forEach(function (prop) {\n            // eslint-disable-next-line no-param-reassign\n            gutterElement.style[prop] = style[prop];\n        });\n    }\n\n    function getSizes() {\n        return elements.map(function (element) { return element.size; })\n    }\n\n    // Supports touch events, but not multitouch, so only the first\n    // finger `touches[0]` is counted.\n    function getMousePosition(e) {\n        if ('touches' in e) { return e.touches[0][clientAxis] }\n        return e[clientAxis]\n    }\n\n    // Actually adjust the size of elements `a` and `b` to `offset` while dragging.\n    // calc is used to allow calc(percentage + gutterpx) on the whole split instance,\n    // which allows the viewport to be resized without additional logic.\n    // Element a's size is the same as offset. b's size is total size - a size.\n    // Both sizes are calculated from the initial parent percentage,\n    // then the gutter size is subtracted.\n    function adjust(offset) {\n        var a = elements[this.a];\n        var b = elements[this.b];\n        var percentage = a.size + b.size;\n\n        a.size = (offset / this.size) * percentage;\n        b.size = percentage - (offset / this.size) * percentage;\n\n        setElementSize(a.element, a.size, this[aGutterSize], a.i);\n        setElementSize(b.element, b.size, this[bGutterSize], b.i);\n    }\n\n    // drag, where all the magic happens. The logic is really quite simple:\n    //\n    // 1. Ignore if the pair is not dragging.\n    // 2. Get the offset of the event.\n    // 3. Snap offset to min if within snappable range (within min + snapOffset).\n    // 4. Actually adjust each element in the pair to offset.\n    //\n    // ---------------------------------------------------------------------\n    // |    | <- a.minSize               ||              b.minSize -> |    |\n    // |    |  | <- this.snapOffset      ||     this.snapOffset -> |  |    |\n    // |    |  |                         ||                        |  |    |\n    // |    |  |                         ||                        |  |    |\n    // ---------------------------------------------------------------------\n    // | <- this.start                                        this.size -> |\n    function drag(e) {\n        var offset;\n        var a = elements[this.a];\n        var b = elements[this.b];\n\n        if (!this.dragging) { return }\n\n        // Get the offset of the event from the first side of the\n        // pair `this.start`. Then offset by the initial position of the\n        // mouse compared to the gutter size.\n        offset =\n            getMousePosition(e) -\n            this.start +\n            (this[aGutterSize] - this.dragOffset);\n\n        if (dragInterval > 1) {\n            offset = Math.round(offset / dragInterval) * dragInterval;\n        }\n\n        // If within snapOffset of min or max, set offset to min or max.\n        // snapOffset buffers a.minSize and b.minSize, so logic is opposite for both.\n        // Include the appropriate gutter sizes to prevent overflows.\n        if (offset <= a.minSize + a.snapOffset + this[aGutterSize]) {\n            offset = a.minSize + this[aGutterSize];\n        } else if (\n            offset >=\n            this.size - (b.minSize + b.snapOffset + this[bGutterSize])\n        ) {\n            offset = this.size - (b.minSize + this[bGutterSize]);\n        }\n\n        if (offset >= a.maxSize - a.snapOffset + this[aGutterSize]) {\n            offset = a.maxSize + this[aGutterSize];\n        } else if (\n            offset <=\n            this.size - (b.maxSize - b.snapOffset + this[bGutterSize])\n        ) {\n            offset = this.size - (b.maxSize + this[bGutterSize]);\n        }\n\n        // Actually adjust the size.\n        adjust.call(this, offset);\n\n        // Call the drag callback continously. Don't do anything too intensive\n        // in this callback.\n        getOption(options, 'onDrag', NOOP)(getSizes());\n    }\n\n    // Cache some important sizes when drag starts, so we don't have to do that\n    // continously:\n    //\n    // `size`: The total size of the pair. First + second + first gutter + second gutter.\n    // `start`: The leading side of the first element.\n    //\n    // ------------------------------------------------\n    // |      aGutterSize -> |||                      |\n    // |                     |||                      |\n    // |                     |||                      |\n    // |                     ||| <- bGutterSize       |\n    // ------------------------------------------------\n    // | <- start                             size -> |\n    function calculateSizes() {\n        // Figure out the parent size minus padding.\n        var a = elements[this.a].element;\n        var b = elements[this.b].element;\n\n        var aBounds = a[getBoundingClientRect]();\n        var bBounds = b[getBoundingClientRect]();\n\n        this.size =\n            aBounds[dimension] +\n            bBounds[dimension] +\n            this[aGutterSize] +\n            this[bGutterSize];\n        this.start = aBounds[position];\n        this.end = aBounds[positionEnd];\n    }\n\n    function innerSize(element) {\n        // Return nothing if getComputedStyle is not supported (< IE9)\n        // Or if parent element has no layout yet\n        if (!getComputedStyle) { return null }\n\n        var computedStyle = getComputedStyle(element);\n\n        if (!computedStyle) { return null }\n\n        var size = element[clientSize];\n\n        if (size === 0) { return null }\n\n        if (direction === HORIZONTAL) {\n            size -=\n                parseFloat(computedStyle.paddingLeft) +\n                parseFloat(computedStyle.paddingRight);\n        } else {\n            size -=\n                parseFloat(computedStyle.paddingTop) +\n                parseFloat(computedStyle.paddingBottom);\n        }\n\n        return size\n    }\n\n    // When specifying percentage sizes that are less than the computed\n    // size of the element minus the gutter, the lesser percentages must be increased\n    // (and decreased from the other elements) to make space for the pixels\n    // subtracted by the gutters.\n    function trimToMin(sizesToTrim) {\n        // Try to get inner size of parent element.\n        // If it's no supported, return original sizes.\n        var parentSize = innerSize(parent);\n        if (parentSize === null) {\n            return sizesToTrim\n        }\n\n        if (minSizes.reduce(function (a, b) { return a + b; }, 0) > parentSize) {\n            return sizesToTrim\n        }\n\n        // Keep track of the excess pixels, the amount of pixels over the desired percentage\n        // Also keep track of the elements with pixels to spare, to decrease after if needed\n        var excessPixels = 0;\n        var toSpare = [];\n\n        var pixelSizes = sizesToTrim.map(function (size, i) {\n            // Convert requested percentages to pixel sizes\n            var pixelSize = (parentSize * size) / 100;\n            var elementGutterSize = getGutterSize(\n                gutterSize,\n                i === 0,\n                i === sizesToTrim.length - 1,\n                gutterAlign\n            );\n            var elementMinSize = minSizes[i] + elementGutterSize;\n\n            // If element is too smal, increase excess pixels by the difference\n            // and mark that it has no pixels to spare\n            if (pixelSize < elementMinSize) {\n                excessPixels += elementMinSize - pixelSize;\n                toSpare.push(0);\n                return elementMinSize\n            }\n\n            // Otherwise, mark the pixels it has to spare and return it's original size\n            toSpare.push(pixelSize - elementMinSize);\n            return pixelSize\n        });\n\n        // If nothing was adjusted, return the original sizes\n        if (excessPixels === 0) {\n            return sizesToTrim\n        }\n\n        return pixelSizes.map(function (pixelSize, i) {\n            var newPixelSize = pixelSize;\n\n            // While there's still pixels to take, and there's enough pixels to spare,\n            // take as many as possible up to the total excess pixels\n            if (excessPixels > 0 && toSpare[i] - excessPixels > 0) {\n                var takenPixels = Math.min(\n                    excessPixels,\n                    toSpare[i] - excessPixels\n                );\n\n                // Subtract the amount taken for the next iteration\n                excessPixels -= takenPixels;\n                newPixelSize = pixelSize - takenPixels;\n            }\n\n            // Return the pixel size adjusted as a percentage\n            return (newPixelSize / parentSize) * 100\n        })\n    }\n\n    // stopDragging is very similar to startDragging in reverse.\n    function stopDragging() {\n        var self = this;\n        var a = elements[self.a].element;\n        var b = elements[self.b].element;\n\n        if (self.dragging) {\n            getOption(options, 'onDragEnd', NOOP)(getSizes());\n        }\n\n        self.dragging = false;\n\n        // Remove the stored event listeners. This is why we store them.\n        global[removeEventListener]('mouseup', self.stop);\n        global[removeEventListener]('touchend', self.stop);\n        global[removeEventListener]('touchcancel', self.stop);\n        global[removeEventListener]('mousemove', self.move);\n        global[removeEventListener]('touchmove', self.move);\n\n        // Clear bound function references\n        self.stop = null;\n        self.move = null;\n\n        a[removeEventListener]('selectstart', NOOP);\n        a[removeEventListener]('dragstart', NOOP);\n        b[removeEventListener]('selectstart', NOOP);\n        b[removeEventListener]('dragstart', NOOP);\n\n        a.style.userSelect = '';\n        a.style.webkitUserSelect = '';\n        a.style.MozUserSelect = '';\n        a.style.pointerEvents = '';\n\n        b.style.userSelect = '';\n        b.style.webkitUserSelect = '';\n        b.style.MozUserSelect = '';\n        b.style.pointerEvents = '';\n\n        self.gutter.style.cursor = '';\n        self.parent.style.cursor = '';\n        document.body.style.cursor = '';\n    }\n\n    // startDragging calls `calculateSizes` to store the inital size in the pair object.\n    // It also adds event listeners for mouse/touch events,\n    // and prevents selection while dragging so avoid the selecting text.\n    function startDragging(e) {\n        // Right-clicking can't start dragging.\n        if ('button' in e && e.button !== 0) {\n            return\n        }\n\n        // Alias frequently used variables to save space. 200 bytes.\n        var self = this;\n        var a = elements[self.a].element;\n        var b = elements[self.b].element;\n\n        // Call the onDragStart callback.\n        if (!self.dragging) {\n            getOption(options, 'onDragStart', NOOP)(getSizes());\n        }\n\n        // Don't actually drag the element. We emulate that in the drag function.\n        e.preventDefault();\n\n        // Set the dragging property of the pair object.\n        self.dragging = true;\n\n        // Create two event listeners bound to the same pair object and store\n        // them in the pair object.\n        self.move = drag.bind(self);\n        self.stop = stopDragging.bind(self);\n\n        // All the binding. `window` gets the stop events in case we drag out of the elements.\n        global[addEventListener]('mouseup', self.stop);\n        global[addEventListener]('touchend', self.stop);\n        global[addEventListener]('touchcancel', self.stop);\n        global[addEventListener]('mousemove', self.move);\n        global[addEventListener]('touchmove', self.move);\n\n        // Disable selection. Disable!\n        a[addEventListener]('selectstart', NOOP);\n        a[addEventListener]('dragstart', NOOP);\n        b[addEventListener]('selectstart', NOOP);\n        b[addEventListener]('dragstart', NOOP);\n\n        a.style.userSelect = 'none';\n        a.style.webkitUserSelect = 'none';\n        a.style.MozUserSelect = 'none';\n        a.style.pointerEvents = 'none';\n\n        b.style.userSelect = 'none';\n        b.style.webkitUserSelect = 'none';\n        b.style.MozUserSelect = 'none';\n        b.style.pointerEvents = 'none';\n\n        // Set the cursor at multiple levels\n        self.gutter.style.cursor = cursor;\n        self.parent.style.cursor = cursor;\n        document.body.style.cursor = cursor;\n\n        // Cache the initial sizes of the pair.\n        calculateSizes.call(self);\n\n        // Determine the position of the mouse compared to the gutter\n        self.dragOffset = getMousePosition(e) - self.end;\n    }\n\n    // adjust sizes to ensure percentage is within min size and gutter.\n    sizes = trimToMin(sizes);\n\n    // 5. Create pair and element objects. Each pair has an index reference to\n    // elements `a` and `b` of the pair (first and second elements).\n    // Loop through the elements while pairing them off. Every pair gets a\n    // `pair` object and a gutter.\n    //\n    // Basic logic:\n    //\n    // - Starting with the second element `i > 0`, create `pair` objects with\n    //   `a = i - 1` and `b = i`\n    // - Set gutter sizes based on the _pair_ being first/last. The first and last\n    //   pair have gutterSize / 2, since they only have one half gutter, and not two.\n    // - Create gutter elements and add event listeners.\n    // - Set the size of the elements, minus the gutter sizes.\n    //\n    // -----------------------------------------------------------------------\n    // |     i=0     |         i=1         |        i=2       |      i=3     |\n    // |             |                     |                  |              |\n    // |           pair 0                pair 1             pair 2           |\n    // |             |                     |                  |              |\n    // -----------------------------------------------------------------------\n    var pairs = [];\n    elements = ids.map(function (id, i) {\n        // Create the element object.\n        var element = {\n            element: elementOrSelector(id),\n            size: sizes[i],\n            minSize: minSizes[i],\n            maxSize: maxSizes[i],\n            snapOffset: snapOffsets[i],\n            i: i,\n        };\n\n        var pair;\n\n        if (i > 0) {\n            // Create the pair object with its metadata.\n            pair = {\n                a: i - 1,\n                b: i,\n                dragging: false,\n                direction: direction,\n                parent: parent,\n            };\n\n            pair[aGutterSize] = getGutterSize(\n                gutterSize,\n                i - 1 === 0,\n                false,\n                gutterAlign\n            );\n            pair[bGutterSize] = getGutterSize(\n                gutterSize,\n                false,\n                i === ids.length - 1,\n                gutterAlign\n            );\n\n            // if the parent has a reverse flex-direction, switch the pair elements.\n            if (\n                parentFlexDirection === 'row-reverse' ||\n                parentFlexDirection === 'column-reverse'\n            ) {\n                var temp = pair.a;\n                pair.a = pair.b;\n                pair.b = temp;\n            }\n        }\n\n        // Determine the size of the current element. IE8 is supported by\n        // staticly assigning sizes without draggable gutters. Assigns a string\n        // to `size`.\n        //\n        // Create gutter elements for each pair.\n        if (i > 0) {\n            var gutterElement = gutter(i, direction, element.element);\n            setGutterSize(gutterElement, gutterSize, i);\n\n            // Save bound event listener for removal later\n            pair[gutterStartDragging] = startDragging.bind(pair);\n\n            // Attach bound event listener\n            gutterElement[addEventListener](\n                'mousedown',\n                pair[gutterStartDragging]\n            );\n            gutterElement[addEventListener](\n                'touchstart',\n                pair[gutterStartDragging]\n            );\n\n            parent.insertBefore(gutterElement, element.element);\n\n            pair.gutter = gutterElement;\n        }\n\n        setElementSize(\n            element.element,\n            element.size,\n            getGutterSize(\n                gutterSize,\n                i === 0,\n                i === ids.length - 1,\n                gutterAlign\n            ),\n            i\n        );\n\n        // After the first iteration, and we have a pair object, append it to the\n        // list of pairs.\n        if (i > 0) {\n            pairs.push(pair);\n        }\n\n        return element\n    });\n\n    function adjustToMin(element) {\n        var isLast = element.i === pairs.length;\n        var pair = isLast ? pairs[element.i - 1] : pairs[element.i];\n\n        calculateSizes.call(pair);\n\n        var size = isLast\n            ? pair.size - element.minSize - pair[bGutterSize]\n            : element.minSize + pair[aGutterSize];\n\n        adjust.call(pair, size);\n    }\n\n    elements.forEach(function (element) {\n        var computedSize = element.element[getBoundingClientRect]()[dimension];\n\n        if (computedSize < element.minSize) {\n            if (expandToMin) {\n                adjustToMin(element);\n            } else {\n                // eslint-disable-next-line no-param-reassign\n                element.minSize = computedSize;\n            }\n        }\n    });\n\n    function setSizes(newSizes) {\n        var trimmed = trimToMin(newSizes);\n        trimmed.forEach(function (newSize, i) {\n            if (i > 0) {\n                var pair = pairs[i - 1];\n\n                var a = elements[pair.a];\n                var b = elements[pair.b];\n\n                a.size = trimmed[i - 1];\n                b.size = newSize;\n\n                setElementSize(a.element, a.size, pair[aGutterSize], a.i);\n                setElementSize(b.element, b.size, pair[bGutterSize], b.i);\n            }\n        });\n    }\n\n    function destroy(preserveStyles, preserveGutter) {\n        pairs.forEach(function (pair) {\n            if (preserveGutter !== true) {\n                pair.parent.removeChild(pair.gutter);\n            } else {\n                pair.gutter[removeEventListener](\n                    'mousedown',\n                    pair[gutterStartDragging]\n                );\n                pair.gutter[removeEventListener](\n                    'touchstart',\n                    pair[gutterStartDragging]\n                );\n            }\n\n            if (preserveStyles !== true) {\n                var style = elementStyle(\n                    dimension,\n                    pair.a.size,\n                    pair[aGutterSize]\n                );\n\n                Object.keys(style).forEach(function (prop) {\n                    elements[pair.a].element.style[prop] = '';\n                    elements[pair.b].element.style[prop] = '';\n                });\n            }\n        });\n    }\n\n    return {\n        setSizes: setSizes,\n        getSizes: getSizes,\n        collapse: function collapse(i) {\n            adjustToMin(elements[i]);\n        },\n        destroy: destroy,\n        parent: parent,\n        pairs: pairs,\n    }\n};\n\nexport default Split;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport Split from 'split.js';\n\nfunction objectWithoutProperties (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }\n\nvar SplitWrapper = /*@__PURE__*/(function (superclass) {\n    function SplitWrapper () {\n        superclass.apply(this, arguments);\n    }\n\n    if ( superclass ) SplitWrapper.__proto__ = superclass;\n    SplitWrapper.prototype = Object.create( superclass && superclass.prototype );\n    SplitWrapper.prototype.constructor = SplitWrapper;\n\n    SplitWrapper.prototype.componentDidMount = function componentDidMount () {\n        var ref = this.props;\n        ref.children;\n        var gutter = ref.gutter;\n        var rest = objectWithoutProperties( ref, [\"children\", \"gutter\"] );\n        var options = rest;\n\n        options.gutter = function (index, direction) {\n            var gutterElement;\n\n            if (gutter) {\n                gutterElement = gutter(index, direction);\n            } else {\n                gutterElement = document.createElement('div');\n                gutterElement.className = \"gutter gutter-\" + direction;\n            }\n\n            // eslint-disable-next-line no-underscore-dangle\n            gutterElement.__isSplitGutter = true;\n            return gutterElement\n        };\n\n        this.split = Split(this.parent.children, options);\n    };\n\n    SplitWrapper.prototype.componentDidUpdate = function componentDidUpdate (prevProps) {\n        var this$1 = this;\n\n        var ref = this.props;\n        ref.children;\n        var minSize = ref.minSize;\n        var sizes = ref.sizes;\n        var collapsed = ref.collapsed;\n        var rest = objectWithoutProperties( ref, [\"children\", \"minSize\", \"sizes\", \"collapsed\"] );\n        var options = rest;\n        var prevMinSize = prevProps.minSize;\n        var prevSizes = prevProps.sizes;\n        var prevCollapsed = prevProps.collapsed;\n\n        var otherProps = [\n            'maxSize',\n            'expandToMin',\n            'gutterSize',\n            'gutterAlign',\n            'snapOffset',\n            'dragInterval',\n            'direction',\n            'cursor' ];\n\n        var needsRecreate = otherProps\n            // eslint-disable-next-line react/destructuring-assignment\n            .map(function (prop) { return this$1.props[prop] !== prevProps[prop]; })\n            .reduce(function (accum, same) { return accum || same; }, false);\n\n        // Compare minSize when both are arrays, when one is an array and when neither is an array\n        if (Array.isArray(minSize) && Array.isArray(prevMinSize)) {\n            var minSizeChanged = false;\n\n            minSize.forEach(function (minSizeI, i) {\n                minSizeChanged = minSizeChanged || minSizeI !== prevMinSize[i];\n            });\n\n            needsRecreate = needsRecreate || minSizeChanged;\n        } else if (Array.isArray(minSize) || Array.isArray(prevMinSize)) {\n            needsRecreate = true;\n        } else {\n            needsRecreate = needsRecreate || minSize !== prevMinSize;\n        }\n\n        // Destroy and re-create split if options changed\n        if (needsRecreate) {\n            options.minSize = minSize;\n            options.sizes = sizes || this.split.getSizes();\n            this.split.destroy(true, true);\n            options.gutter = function (index, direction, pairB) { return pairB.previousSibling; };\n            this.split = Split(\n                Array.from(this.parent.children).filter(\n                    // eslint-disable-next-line no-underscore-dangle\n                    function (element) { return !element.__isSplitGutter; }\n                ),\n                options\n            );\n        } else if (sizes) {\n            // If only the size has changed, set the size. No need to do this if re-created.\n            var sizeChanged = false;\n\n            sizes.forEach(function (sizeI, i) {\n                sizeChanged = sizeChanged || sizeI !== prevSizes[i];\n            });\n\n            if (sizeChanged) {\n                // eslint-disable-next-line react/destructuring-assignment\n                this.split.setSizes(this.props.sizes);\n            }\n        }\n\n        // Collapse after re-created or when collapsed changed.\n        if (\n            Number.isInteger(collapsed) &&\n            (collapsed !== prevCollapsed || needsRecreate)\n        ) {\n            this.split.collapse(collapsed);\n        }\n    };\n\n    SplitWrapper.prototype.componentWillUnmount = function componentWillUnmount () {\n        this.split.destroy();\n        delete this.split;\n    };\n\n    SplitWrapper.prototype.render = function render () {\n        var this$1 = this;\n\n        var ref = this.props;\n        ref.sizes;\n        ref.minSize;\n        ref.maxSize;\n        ref.expandToMin;\n        ref.gutterSize;\n        ref.gutterAlign;\n        ref.snapOffset;\n        ref.dragInterval;\n        ref.direction;\n        ref.cursor;\n        ref.gutter;\n        ref.elementStyle;\n        ref.gutterStyle;\n        ref.onDrag;\n        ref.onDragStart;\n        ref.onDragEnd;\n        ref.collapsed;\n        var children = ref.children;\n        var rest$1 = objectWithoutProperties( ref, [\"sizes\", \"minSize\", \"maxSize\", \"expandToMin\", \"gutterSize\", \"gutterAlign\", \"snapOffset\", \"dragInterval\", \"direction\", \"cursor\", \"gutter\", \"elementStyle\", \"gutterStyle\", \"onDrag\", \"onDragStart\", \"onDragEnd\", \"collapsed\", \"children\"] );\n        var rest = rest$1;\n\n        return (\n            React.createElement( 'div', Object.assign({},\n                { ref: function (parent) {\n                    this$1.parent = parent;\n                } }, rest),\n                children\n            )\n        )\n    };\n\n    return SplitWrapper;\n}(React.Component));\n\nSplitWrapper.propTypes = {\n    sizes: PropTypes.arrayOf(PropTypes.number),\n    minSize: PropTypes.oneOfType([\n        PropTypes.number,\n        PropTypes.arrayOf(PropTypes.number) ]),\n    maxSize: PropTypes.oneOfType([\n        PropTypes.number,\n        PropTypes.arrayOf(PropTypes.number) ]),\n    expandToMin: PropTypes.bool,\n    gutterSize: PropTypes.number,\n    gutterAlign: PropTypes.string,\n    snapOffset: PropTypes.oneOfType([\n        PropTypes.number,\n        PropTypes.arrayOf(PropTypes.number) ]),\n    dragInterval: PropTypes.number,\n    direction: PropTypes.string,\n    cursor: PropTypes.string,\n    gutter: PropTypes.func,\n    elementStyle: PropTypes.func,\n    gutterStyle: PropTypes.func,\n    onDrag: PropTypes.func,\n    onDragStart: PropTypes.func,\n    onDragEnd: PropTypes.func,\n    collapsed: PropTypes.number,\n    children: PropTypes.arrayOf(PropTypes.element),\n};\n\nSplitWrapper.defaultProps = {\n    sizes: undefined,\n    minSize: undefined,\n    maxSize: undefined,\n    expandToMin: undefined,\n    gutterSize: undefined,\n    gutterAlign: undefined,\n    snapOffset: undefined,\n    dragInterval: undefined,\n    direction: undefined,\n    cursor: undefined,\n    gutter: undefined,\n    elementStyle: undefined,\n    gutterStyle: undefined,\n    onDrag: undefined,\n    onDragStart: undefined,\n    onDragEnd: undefined,\n    collapsed: undefined,\n    children: undefined,\n};\n\nexport default SplitWrapper;\n","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import rng from './rng.js';\nimport stringify from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport default v4;","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeReflectConstruct from \"./isNativeReflectConstruct.js\";\nexport default function _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nimport setPrototypeOf from \"./setPrototypeOf.js\";\nimport isNativeFunction from \"./isNativeFunction.js\";\nimport construct from \"./construct.js\";\nexport default function _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}","export default function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}"],"names":["_interopRequireDefault","require","exports","_createSvgIcon","_jsxRuntime","_default","default","jsx","d","createSvgIcon","_jsx","__spreadArray","to","from","pack","arguments","length","ar","i","l","Array","prototype","slice","call","concat","isNumber$1","code","isAlpha$1","isAlphaNumericWord","isAlphaWord","isSpace","isWhiteSpace$3","isQuote$2","Scanner","str","start","end","this","string","pos","charCodeAt","match","ch","peek","ok","next","eof","eat","n","substring","message","ScannerError","Error","tokenScanner$1","tokens","size","peek$3","scanner","readable$1","consume$2","test","token","error$1","err","statements","options","node","result","type","elements","ctx","stack","element$2","group","push","isChildOperator","isSiblingOperator$1","isClimbOperator","pop","isGroupStart","isBracket$2","repeat","isRepeater","repeater","attr","elem","name","attributes","value","selfClose","isCapitalizedLiteral","isClassNameOperator","isElementName","elementName","isEmpty","text","getText","shortAttribute","attributeSet","isCloseOperator","isArray","isAttributeSetStart","attribute","isAttributeSetEnd","isWhiteSpace$2","isOperator$1","expression","literal$2","quoted","isEquals","quote","isQuote$1","single","allowBrackets","brackets","context","open","isTextStart","isOpen","Boolean","operator","isSingle","isLiteral$2","escaped","getToken$1","index","eatWhile","Number","current","consumePlaceholder$2","error","field$2","repeaterPlaceholder","reverse","base","parent","repeaterNumber","count","implicit","repeater$1","whiteSpace$1","isAllowedOperator","isElementName$1","isAllowedSpace","isAllowedRepeater","bracketType","literal$1$1","op","operatorType$1","operator$1","isOpenBracket$2","bracket$1","stream","operators","child","class","climb","id","equal","close","sibling","tokenVisitor","Literal","Quote","Bracket","Operator","Field","state","getVariable","RepeaterPlaceholder","repeaters","inserted","RepeaterNumber","lastIx","parentIx","Math","max","parentRepeater","String","WhiteSpace","stringify$1","urlRegex","emailRegex","convertStatement","items","original","Object","assign","cleanText","isGroup","convertGroup","convertElement","target","last$1","deepest","deepestNode","insertText","repeatGuard","children","stringifyName","stringifyValue$1","selfClosing","convertAttribute","some","isField$1","item","attachRepeater","implied","isBoolean","valueType","shift","boolean","arr","insertHref","_a","href","startsWith","hrefAttribute","find","parseAbbreviation","abbr","textInserted","filter","s","trim","maxRepeat","POSITIVE_INFINITY","undefined","join","varValue","variables","convert","abbreviation","source","tokenize$1","getToken","short","consumePlaceholder$1","field$1","afterNegative","hasDecimal","prevPos","hasFloat","consumeNumber","rawValue","unit","numberValue","valueStart","color","alpha","isHex","colorAlpha","r","g","b","a","parseInt","parseColor","raw","createLiteral","colorValue","finished","stringValue","isBracket","bracket","whiteSpace","isIdentPrefix","isKeyword","isLiteral","literal$1","shouldConsumeDashAfter","mergeTokens","tokenScanner","peek$2","readable","consume$1","consumeProperty","valueFragment","important","valueMode","isLiteral$1","t1","t2","isFunctionStart","isValueDelimiter","isWhiteSpace$1","isImportant","consumeValue","isFragmentDelimiter","inArgument","args","isValue","consumeArguments","isOpenBracket$1","isCloseBracket$1","isArgumentDelimiter","isBracket$1","isOperator","isSiblingOperator","parse$2","tokenize","property","parser","mergeValue","prev","glue","append","mergeDeclarations","dest","src","config","findDeepest","isNode","walkResolve","resolve","resolved","mergeNodes","createOutputStream","level","offset","line","column","_push","processText","pushString","lines","split","splitByLines","il","pushNewline","indent","baseIndent","pushIndent","pushField","placeholder","field","attrName","strCase","attrQuote","isBooleanAttribute","includes","toLowerCase","isInline","inlineElements","toUpperCase","elementMap","p","ul","ol","table","tr","tbody","thead","tfoot","colgroup","select","optgroup","audio","video","object","map","resolveImplicitTag","ancestors","getParentElement","contextName","parentName","vocabularies","ru","sp","latin","reLorem","rand","floor","random","sample","len","iterations","min","sentence","words","word","val","insertCommas","hasComma","totalCommas","paragraph","dict","wordCount","startWithCommon","totalWords","common","rename","isAllowed","reElement","reModifier","blockCandidates1","className","blockCandidates2","bem","data","getBEMData","classNames","cl","ix","indexOf","uniqueClass","block","findBlockName","updateClass","expandClassNames","path","prefix","m","originalClass","getBlockName","arrClassNames","expandShortNotation","_bem","classValue","stringifyValue","parseBEM","getBEMDataFromContext","depth","maxParentIx","t","walk$1","visitor","callback","forEach","createWalkState","out","caret","isSnippet","isInlineElement","isField","pushTokens","largestIndex","shouldOutputAttribute","template","consumePlaceholder","namePos","afterPos","isTokenStart","isToken","before","after","shouldComment","comment","enabled","trigger","output","attrs","htmlTagRegex","html","createCommentState","element","format","shouldFormat","getIndent","tagName","commentNodeBefore","pushAttribute","pushSnippet","innerFormat","hasNewline","matches","exec","startsWithBlockTag","commentNodeAfter","lQuote","rQuote","fieldIx","findIndex","trimLeft","adjacentInline","indentFormat","element$1","primary","secondary","isPrimaryAttribute","collectAttributes","shouldFormat$1","beforeName","afterName","replace","pushPrimaryAttributes","beforeAttribute","booleanValue","glueAttribute","afterAttribute","pushSecondaryAttributes","splitByLines$1","lineLengths","maxLength","valueLength","beforeTextLine","afterTextLine","pushValue","formatters","haml","slim","pug","parse","oldTextValue","parseOpt","reversed","snippet","snippets","snippetAbbr","topNode","resolveSnippets","fn","walk","transform","stringify","syntax","implicitTag","lookup","mergeAttributes","db","minWordCount","findRepeater","lorem","xsl","reProperty","opt","createSnippet","key","keywords","parsed","parseValue","collectKeywords","dependencies","snippetsSort","isProperty","cssVal","v","scoreMatch","str1","str2","partialMatch","str1Len","str2Len","minLength","j","score","ch1","ch2","found","acronym","matchRatio","delta","maxScore","sum","shortHex","isShortHex","toShortHex","toHex","asHex","values","frac","asRGB","num","digits","toFixed","hex","toString","pad","css","isJSON","_","letter","getSingleNumeric","getQuote","outputValue","propertyValue","outputImportant","outputToken","separator","prevEnd","gradientName","parse$1","cache","stylesheetSnippets","keys","sort","cur","nest","convertSnippets","isValueScope","filteredSnippets","getSnippetsForScope","resolveNode","gradientFn","cssValue","resolveGradient","propName","resolveValueKeywords","findBestMatch","inlineValue","lastPos","getUnmatchedPart","kw","resolveKeyword","defaultValue","hasField","wrapWithField","resolveAsProperty","reField","inputValue","literal","tail","resolveAsSnippet","aliases","unitless","resolveNumericValue","minScore","matchedItem","getScoringPart","ref","dep","q","defaultSyntaxes","markup","stylesheet","defaultConfig","e","x","syntaxConfig","parseSnippets","xhtml","xml","sass","stylus","k","resolveConfig","globals","mergedData","typeDefaults","typeOverride","syntaxDefaults","syntaxOverride","backwardScanner","sol","peek$1","previous","consume","consumeWhile","isQuote","c","bracePairs","isHtml","isWhiteSpace","consumeIdent","consumeAttributeWithUnquotedValue","consumeAttribute","consumeQuoted","consumeAttributeWithQuotedValue","isCloseBracket","isOpenBracket","isUnquotedValue","isIdent","isAlpha","isNumber","isNaN","specialChars","defaultOptions$1","lookAhead","offsetPastAutoClosed","isCloseBrace","getStartOffset","compiledPrefix","consumePair","consumeArray","consumed","isAbbreviation","isOpenBrace","expandAbbreviation$1","resolvedConfig","markupSnippetKeys","cssData","htmlData","snippetKeyCache","Map","stylesheetCustomSnippetsKeyCache","htmlAbbreviationStartRegex","jsxAbbreviationStartRegex","cssAbbreviationRegex","htmlAbbreviationRegex","commonlyUsedTags","tags","bemFilterSuffix","filterDelimitor","trimFilterSuffix","commentFilterSuffix","doComplete","monaco","model","position","emmetConfig","isStyleSheetRes","isStyleSheet","has","registry","getSyntaxType","getDefaultSnippets","set","get","extractOptions","extractedValue","currentLine","getLineContent","lineNumber","currentLineTillPosition","substr","endsWith","getFilters","lengthOccupiedByFilter","location","extractAbbreviation$1","abbreviationRange","Range","extractAbbreviation","currentWord","getCurrentWord","expandedAbbr","expandOptions","filters","bemEnabled","commentEnabled","emmetSnippetField","getExpandOptions","expandedText","completionItems","isAbbreviationValid","_b","between","endPrefixIndex","tag","dotMatches","isExpandedTextNoise","kind","languages","CompletionItemKind","Property","label","documentation","replaceTabStopsWithCursors","detail","insertTextRules","CompletionItemInsertTextRule","InsertAsSnippet","range","escapeNonTabStopDollar","addFinalTabStop","createExpandedAbbr","properties","suggestions","incomplete","filterText","stylesheetCustomSnippetsKeys","makeSnippetSuggestion","abbrRegex","RegExp","tagToFindMoreSuggestionsFor","newTagMatches","commonlyUsedTagSuggestions","showAbbreviationSuggestions","abbreviationSuggestions","sortText","showSuggestionsAsSnippets","Snippet","snippetKeys","snippetDetail","skipFullMatch","snippetCompletions","snippetKey","currentAbbr","expandedWord","maxTabStop","maxTabStopRanges","foundLastStop","replaceWithLastStop","numberStart","numberEnd","currentTabStop","foundPlaceholder","i_1","rangeStart","rangeEnd","isValidEmmetToken","language","currentTokenType","LANGUAGE_MODES","jade","scss","less","javascript","typescript","MAPPED_MODES","handlebars","php","twig","DEFAULT_CONFIG","showExpandedAbbreviation","registerProvider","providers","registerCompletionItemProvider","triggerCharacters","provideCompletionItems","_tokenization","_tokenizationStateStore","_tokenizationSupport","tokenizationSupport","getBeginState","clone","valid","isValidLocationForEmmetAbbreviation","provider","dispose","console","emmetHTML","window","emmetCSS","emmetJSX","global","ssr","document","HORIZONTAL","NOOP","calc","el","createElement","style","cssText","isString","elementOrSelector","ele","querySelector","getOption","def","getGutterSize","gutterSize","isFirst","isLast","gutterAlign","defaultGutterFn","gutterDirection","gut","defaultElementStyleFn","dim","gutSize","defaultGutterStyleFn","obj","idsOption","dimension","clientAxis","positionEnd","clientSize","ids","parentNode","parentStyle","getComputedStyle","parentFlexDirection","flexDirection","sizes","minSize","minSizes","maxSize","Infinity","maxSizes","expandToMin","snapOffset","snapOffsets","dragInterval","direction","cursor","gutter","elementStyle","gutterStyle","setElementSize","prop","getSizes","getMousePosition","touches","adjust","percentage","drag","dragging","dragOffset","round","calculateSizes","aBounds","bBounds","trimToMin","sizesToTrim","parentSize","computedStyle","parseFloat","paddingLeft","paddingRight","paddingTop","paddingBottom","innerSize","reduce","excessPixels","toSpare","pixelSizes","pixelSize","elementGutterSize","elementMinSize","newPixelSize","takenPixels","stopDragging","self","stop","move","userSelect","webkitUserSelect","MozUserSelect","pointerEvents","body","startDragging","button","preventDefault","bind","pairs","adjustToMin","pair","temp","gutterElement","setGutterSize","insertBefore","computedSize","setSizes","newSizes","trimmed","newSize","collapse","destroy","preserveStyles","preserveGutter","removeChild","objectWithoutProperties","exclude","hasOwnProperty","SplitWrapper","superclass","apply","__proto__","create","constructor","componentDidMount","props","__isSplitGutter","Split","componentDidUpdate","prevProps","this$1","collapsed","prevMinSize","prevSizes","prevCollapsed","needsRecreate","accum","same","minSizeChanged","minSizeI","pairB","previousSibling","sizeChanged","sizeI","isInteger","componentWillUnmount","render","onDrag","onDragStart","onDragEnd","rest","React","propTypes","PropTypes","defaultProps","getRandomValues","rnds8","Uint8Array","rng","crypto","msCrypto","uuid","REGEX","byteToHex","validate","TypeError","buf","rnds","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","F","done","_e","f","normalCompletion","didErr","step","_e2","_construct","Parent","Class","isNativeReflectConstruct","Reflect","construct","instance","Function","setPrototypeOf","_wrapNativeSuper","_cache","Wrapper","getPrototypeOf","enumerable","writable","configurable"],"sourceRoot":""}